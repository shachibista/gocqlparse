// Code generated from Cql3.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Cql3

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Cql3Parser struct {
	*antlr.BaseParser
}

var Cql3ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cql3ParserInit() {
	staticData := &Cql3ParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "','", "'*'", "'+'", "'-'", "'/'", "'%'", "'.'", "'['", "']'",
		"'('", "')'", "'{'", "'}'", "':'", "'expr('", "'='", "'<'", "'<='",
		"'>'", "'>='", "'!='", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "'?'", "'..'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "K_SELECT", "K_FROM", "K_AS", "K_WHERE", "K_AND",
		"K_KEY", "K_KEYS", "K_ENTRIES", "K_FULL", "K_INSERT", "K_UPDATE", "K_WITH",
		"K_LIMIT", "K_PER", "K_PARTITION", "K_USING", "K_USE", "K_DISTINCT",
		"K_COUNT", "K_SET", "K_BEGIN", "K_UNLOGGED", "K_BATCH", "K_APPLY", "K_TRUNCATE",
		"K_DELETE", "K_IN", "K_CREATE", "K_SCHEMA", "K_KEYSPACE", "K_KEYSPACES",
		"K_COLUMNFAMILY", "K_TABLES", "K_MATERIALIZED", "K_VIEW", "K_INDEX",
		"K_CUSTOM", "K_ON", "K_TO", "K_DROP", "K_PRIMARY", "K_INTO", "K_VALUES",
		"K_TIMESTAMP", "K_TTL", "K_CAST", "K_ALTER", "K_RENAME", "K_ADD", "K_TYPE",
		"K_TYPES", "K_COMPACT", "K_STORAGE", "K_ORDER", "K_BY", "K_ASC", "K_DESC",
		"K_ALLOW", "K_FILTERING", "K_IF", "K_IS", "K_CONTAINS", "K_BETWEEN",
		"K_GROUP", "K_CLUSTER", "K_INTERNALS", "K_ONLY", "K_GRANT", "K_ALL",
		"K_PERMISSION", "K_PERMISSIONS", "K_OF", "K_REVOKE", "K_MODIFY", "K_AUTHORIZE",
		"K_DESCRIBE", "K_EXECUTE", "K_NORECURSIVE", "K_MBEAN", "K_MBEANS", "K_USER",
		"K_USERS", "K_ROLE", "K_ROLES", "K_SUPERUSERS", "K_SUPERUSER", "K_NOSUPERUSER",
		"K_GENERATED", "K_PASSWORD", "K_HASHED", "K_LOGIN", "K_NOLOGIN", "K_OPTIONS",
		"K_ACCESS", "K_DATACENTERS", "K_CIDRS", "K_IDENTITY", "K_CLUSTERING",
		"K_ASCII", "K_BIGINT", "K_BLOB", "K_BOOLEAN", "K_COUNTER", "K_DECIMAL",
		"K_DOUBLE", "K_DURATION", "K_FLOAT", "K_INET", "K_INT", "K_SMALLINT",
		"K_TINYINT", "K_TEXT", "K_UUID", "K_VARCHAR", "K_VARINT", "K_TIMEUUID",
		"K_TOKEN", "K_WRITETIME", "K_MAXWRITETIME", "K_DATE", "K_TIME", "K_NULL",
		"K_NOT", "K_EXISTS", "K_MAP", "K_LIST", "K_POSITIVE_NAN", "K_NEGATIVE_NAN",
		"K_POSITIVE_INFINITY", "K_NEGATIVE_INFINITY", "K_TUPLE", "K_TRIGGER",
		"K_STATIC", "K_FROZEN", "K_FUNCTION", "K_FUNCTIONS", "K_AGGREGATE",
		"K_AGGREGATES", "K_SFUNC", "K_STYPE", "K_FINALFUNC", "K_INITCOND", "K_RETURNS",
		"K_CALLED", "K_INPUT", "K_LANGUAGE", "K_OR", "K_REPLACE", "K_JSON",
		"K_DEFAULT", "K_UNSET", "K_LIKE", "K_MASKED", "K_UNMASK", "K_SELECT_MASKED",
		"K_VECTOR", "K_ANN", "STRING_LITERAL", "QUOTED_NAME", "EMPTY_QUOTED_NAME",
		"INTEGER", "QMARK", "RANGE", "FLOAT", "BOOLEAN", "DURATION", "IDENT",
		"HEXNUMBER", "UUID", "WS", "COMMENT", "MULTILINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"cqlStatements", "cqlStatement", "useStatement", "selectStatement",
		"selectClause", "selectors", "selector", "unaliasedSelector", "selectionAddition",
		"selectionMultiplication", "selectionGroup", "selectionGroupWithField",
		"selectorModifier", "collectionSubSelection", "selectionGroupWithoutField",
		"selectionTypeHint", "selectionList", "selectionMapOrSet", "selectionMap",
		"selectionSet", "selectionTupleOrNestedSelector", "simpleUnaliasedSelector",
		"selectionFunction", "selectionLiteral", "marker", "selectionFunctionArgs",
		"sident", "whereClause", "relationOrExpression", "customIndexExpression",
		"orderByClause", "groupByClause", "createKeyspaceStatement", "createTableStatement",
		"ifNotExists", "ifExists", "tableDefinition", "tableColumns", "columnMask",
		"columnMaskArguments", "tablePartitionKey", "tableProperty", "tableClusteringOrder",
		"createTypeStatement", "typeColumns", "createTriggerStatement", "dropTriggerStatement",
		"alterKeyspaceStatement", "alterMaterializedViewStatement", "dropKeyspaceStatement",
		"dropTableStatement", "dropTypeStatement", "dropIndexStatement", "dropMaterializedViewStatement",
		"truncateStatement", "grantRoleStatement", "revokeRoleStatement", "createUserStatement",
		"alterUserStatement", "dropUserStatement", "addIdentityStatement", "dropIdentityStatement",
		"listUsersStatement", "dropRoleStatement", "listRolesStatement", "listSuperUsersStatement",
		"userPassword", "cident", "ident", "fident", "noncol_ident", "keyspaceName",
		"indexName", "columnFamilyName", "userTypeName", "userOrRoleName", "ksName",
		"cfName", "idxName", "roleName", "constant", "fullMapLiteral", "setOrMapLiteral",
		"setLiteral", "mapLiteral", "collectionLiteral", "listLiteral", "usertypeLiteral",
		"tupleLiteral", "value", "intValue", "functionName", "allowedFunctionName",
		"function", "functionArgs", "term", "termAddition", "termMultiplication",
		"termGroup", "simpleTerm", "properties", "property", "propertyValue",
		"singleColumnBetweenValues", "relationType", "relation", "containsOperator",
		"inOperator", "inMarker", "tupleOfIdentifiers", "singleColumnInValues",
		"terms", "multiColumnValue", "multiColumnInValues", "tupleOfTupleLiterals",
		"tupleOfMarkersForTuples", "comparatorType", "native_type", "collection_type",
		"tuple_type", "vector_type", "username", "identity", "non_type_ident",
		"unreserved_keyword", "unreserved_function_keyword", "basic_unreserved_keyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 194, 1436, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 1, 0, 1, 0, 1, 0, 5, 0, 258, 8, 0, 10, 0, 12, 0, 261, 9, 0, 1, 0,
		5, 0, 264, 8, 0, 10, 0, 12, 0, 267, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 296,
		8, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 303, 8, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 310, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 5, 3, 317, 8,
		3, 10, 3, 12, 3, 320, 9, 3, 3, 3, 322, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 5, 3, 329, 8, 3, 10, 3, 12, 3, 332, 9, 3, 3, 3, 334, 8, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 3, 3, 340, 8, 3, 1, 3, 1, 3, 3, 3, 344, 8, 3, 1, 3, 1, 3,
		3, 3, 348, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 353, 8, 4, 1, 5, 1, 5, 1, 5, 5,
		5, 358, 8, 5, 10, 5, 12, 5, 361, 9, 5, 1, 5, 3, 5, 364, 8, 5, 1, 6, 1,
		6, 1, 6, 3, 6, 369, 8, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5,
		8, 378, 8, 8, 10, 8, 12, 8, 381, 9, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 5, 9, 390, 8, 9, 10, 9, 12, 9, 393, 9, 9, 1, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 399, 8, 10, 1, 11, 1, 11, 4, 11, 403, 8, 11, 11, 11, 12,
		11, 404, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 413, 8, 12, 1,
		13, 1, 13, 1, 13, 1, 13, 3, 13, 419, 8, 13, 3, 13, 421, 8, 13, 1, 13, 1,
		13, 3, 13, 425, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 432, 8,
		14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16,
		443, 8, 16, 10, 16, 12, 16, 446, 9, 16, 3, 16, 448, 8, 16, 1, 16, 1, 16,
		1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 456, 8, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 462, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		5, 18, 471, 8, 18, 10, 18, 12, 18, 474, 9, 18, 1, 19, 1, 19, 5, 19, 478,
		8, 19, 10, 19, 12, 19, 481, 9, 19, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 487,
		8, 20, 10, 20, 12, 20, 490, 9, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 3,
		21, 497, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		5, 22, 507, 8, 22, 10, 22, 12, 22, 510, 9, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 5, 22, 518, 8, 22, 10, 22, 12, 22, 521, 9, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 529, 8, 22, 10, 22, 12, 22, 532,
		9, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 3, 22, 546, 8, 22, 1, 23, 1, 23, 1, 23, 3, 23, 551, 8,
		23, 1, 24, 1, 24, 1, 24, 3, 24, 556, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25,
		5, 25, 562, 8, 25, 10, 25, 12, 25, 565, 9, 25, 3, 25, 567, 8, 25, 1, 25,
		1, 25, 1, 26, 1, 26, 1, 26, 3, 26, 574, 8, 26, 1, 27, 1, 27, 1, 27, 5,
		27, 579, 8, 27, 10, 27, 12, 27, 582, 9, 27, 1, 28, 1, 28, 3, 28, 586, 8,
		28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30,
		3, 30, 598, 8, 30, 1, 30, 3, 30, 601, 8, 30, 1, 31, 1, 31, 1, 32, 1, 32,
		1, 32, 3, 32, 608, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1,
		33, 3, 33, 617, 8, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 633, 8, 36, 5,
		36, 635, 8, 36, 10, 36, 12, 36, 638, 9, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 5, 36, 645, 8, 36, 10, 36, 12, 36, 648, 9, 36, 3, 36, 650, 8, 36,
		1, 37, 1, 37, 1, 37, 3, 37, 655, 8, 37, 1, 37, 3, 37, 658, 8, 37, 1, 37,
		1, 37, 3, 37, 662, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5,
		37, 670, 8, 37, 10, 37, 12, 37, 673, 9, 37, 1, 37, 1, 37, 3, 37, 677, 8,
		37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 687,
		8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 5, 39, 695, 8, 39, 10,
		39, 12, 39, 698, 9, 39, 1, 39, 1, 39, 3, 39, 702, 8, 39, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 5, 40, 709, 8, 40, 10, 40, 12, 40, 712, 9, 40, 1,
		40, 1, 40, 3, 40, 716, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 728, 8, 41, 10, 41, 12, 41, 731, 9,
		41, 1, 41, 1, 41, 3, 41, 735, 8, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43,
		1, 43, 3, 43, 743, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 750,
		8, 43, 5, 43, 752, 8, 43, 10, 43, 12, 43, 755, 9, 43, 1, 43, 1, 43, 1,
		44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 3, 45, 765, 8, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 3, 46, 776, 8, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3, 47, 785, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 795, 8, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 3, 49, 804, 8, 49, 1, 49,
		1, 49, 1, 50, 1, 50, 1, 50, 3, 50, 811, 8, 50, 1, 50, 1, 50, 1, 51, 1,
		51, 1, 51, 3, 51, 818, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 3, 52,
		825, 8, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 833, 8, 53,
		1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 839, 8, 54, 1, 54, 1, 54, 1, 55, 1,
		55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57,
		1, 57, 3, 57, 856, 8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 861, 8, 57, 1, 57,
		3, 57, 864, 8, 57, 1, 58, 1, 58, 1, 58, 3, 58, 869, 8, 58, 1, 58, 1, 58,
		1, 58, 3, 58, 874, 8, 58, 1, 58, 3, 58, 877, 8, 58, 1, 59, 1, 59, 1, 59,
		3, 59, 882, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 3, 60, 889, 8, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 3, 61, 899, 8,
		61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 3, 63, 909,
		8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 917, 8, 64, 1,
		64, 3, 64, 920, 8, 64, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 3, 66, 932, 8, 66, 1, 67, 1, 67, 3, 67, 936, 8, 67,
		1, 68, 1, 68, 1, 68, 3, 68, 941, 8, 68, 1, 69, 1, 69, 1, 69, 3, 69, 946,
		8, 69, 1, 70, 1, 70, 1, 70, 3, 70, 951, 8, 70, 1, 71, 1, 71, 1, 72, 1,
		72, 1, 72, 3, 72, 958, 8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 3, 73,
		965, 8, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 3, 74, 972, 8, 74, 1, 74,
		1, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 982, 8, 76, 1,
		77, 1, 77, 1, 77, 1, 77, 3, 77, 988, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78,
		3, 78, 994, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1001, 8, 79,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3,
		80, 1013, 8, 80, 3, 80, 1015, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81,
		1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 1026, 8, 81, 10, 81, 12, 81, 1029, 9,
		81, 3, 81, 1031, 8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 3, 82, 1037, 8, 82,
		1, 83, 1, 83, 5, 83, 1041, 8, 83, 10, 83, 12, 83, 1044, 9, 83, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1053, 8, 84, 10, 84, 12,
		84, 1056, 9, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85,
		3, 85, 1066, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1072, 8, 86, 10,
		86, 12, 86, 1075, 9, 86, 3, 86, 1077, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1090, 8, 87, 10,
		87, 12, 87, 1093, 9, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88,
		1101, 8, 88, 10, 88, 12, 88, 1104, 9, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 3, 89, 1114, 8, 89, 1, 90, 1, 90, 3, 90, 1118,
		8, 90, 1, 91, 1, 91, 1, 91, 3, 91, 1123, 8, 91, 1, 91, 1, 91, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 3, 92, 1132, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93,
		1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1143, 8, 93, 1, 94, 1, 94, 1,
		94, 5, 94, 1148, 8, 94, 10, 94, 12, 94, 1151, 9, 94, 1, 95, 1, 95, 1, 96,
		1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 1160, 8, 96, 10, 96, 12, 96, 1163, 9,
		96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 1172, 8, 97,
		10, 97, 12, 97, 1175, 9, 97, 1, 98, 1, 98, 1, 98, 3, 98, 1180, 8, 98, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 3, 99, 1196, 8, 99, 1, 100, 1, 100, 1, 100, 5, 100,
		1201, 8, 100, 10, 100, 12, 100, 1204, 9, 100, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1214, 8, 101, 1, 102, 1, 102,
		3, 102, 1218, 8, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1243,
		8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105,
		1252, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 3, 105, 1273, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		3, 105, 1279, 8, 105, 1, 106, 1, 106, 3, 106, 1283, 8, 106, 1, 106, 1,
		106, 1, 106, 3, 106, 1288, 8, 106, 3, 106, 1290, 8, 106, 1, 107, 1, 107,
		1, 107, 3, 107, 1295, 8, 107, 1, 108, 1, 108, 1, 108, 3, 108, 1300, 8,
		108, 1, 109, 1, 109, 1, 109, 1, 109, 5, 109, 1306, 8, 109, 10, 109, 12,
		109, 1309, 9, 109, 1, 109, 1, 109, 1, 110, 1, 110, 3, 110, 1315, 8, 110,
		1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 1321, 8, 111, 10, 111, 12, 111,
		1324, 9, 111, 3, 111, 1326, 8, 111, 1, 111, 1, 111, 1, 112, 1, 112, 3,
		112, 1332, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1339,
		8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1345, 8, 114, 10, 114,
		12, 114, 1348, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115,
		5, 115, 1356, 8, 115, 10, 115, 12, 115, 1359, 9, 115, 1, 115, 1, 115, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 3, 116, 1374, 8, 116, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1395, 8, 118, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 5, 119, 1402, 8, 119, 10, 119, 12, 119, 1405,
		9, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120,
		1, 120, 1, 121, 1, 121, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123,
		3, 123, 1424, 8, 123, 1, 124, 1, 124, 3, 124, 1428, 8, 124, 1, 125, 1,
		125, 3, 125, 1432, 8, 125, 1, 126, 1, 126, 1, 126, 0, 0, 127, 0, 2, 4,
		6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 0, 9, 1, 0, 78, 79, 1,
		0, 108, 109, 1, 0, 149, 150, 1, 0, 17, 22, 3, 0, 66, 66, 121, 138, 142,
		143, 2, 0, 180, 181, 189, 189, 2, 0, 142, 142, 189, 189, 5, 0, 28, 28,
		40, 41, 67, 68, 140, 141, 171, 171, 16, 0, 25, 25, 29, 29, 36, 37, 53,
		53, 55, 55, 59, 59, 65, 65, 72, 75, 81, 81, 84, 89, 91, 93, 101, 120, 146,
		148, 153, 168, 170, 170, 172, 179, 1547, 0, 254, 1, 0, 0, 0, 2, 295, 1,
		0, 0, 0, 4, 297, 1, 0, 0, 0, 6, 300, 1, 0, 0, 0, 8, 352, 1, 0, 0, 0, 10,
		363, 1, 0, 0, 0, 12, 365, 1, 0, 0, 0, 14, 370, 1, 0, 0, 0, 16, 372, 1,
		0, 0, 0, 18, 382, 1, 0, 0, 0, 20, 398, 1, 0, 0, 0, 22, 400, 1, 0, 0, 0,
		24, 412, 1, 0, 0, 0, 26, 424, 1, 0, 0, 0, 28, 431, 1, 0, 0, 0, 30, 433,
		1, 0, 0, 0, 32, 438, 1, 0, 0, 0, 34, 461, 1, 0, 0, 0, 36, 463, 1, 0, 0,
		0, 38, 479, 1, 0, 0, 0, 40, 482, 1, 0, 0, 0, 42, 496, 1, 0, 0, 0, 44, 545,
		1, 0, 0, 0, 46, 550, 1, 0, 0, 0, 48, 555, 1, 0, 0, 0, 50, 557, 1, 0, 0,
		0, 52, 573, 1, 0, 0, 0, 54, 575, 1, 0, 0, 0, 56, 585, 1, 0, 0, 0, 58, 587,
		1, 0, 0, 0, 60, 593, 1, 0, 0, 0, 62, 602, 1, 0, 0, 0, 64, 604, 1, 0, 0,
		0, 66, 613, 1, 0, 0, 0, 68, 621, 1, 0, 0, 0, 70, 625, 1, 0, 0, 0, 72, 628,
		1, 0, 0, 0, 74, 676, 1, 0, 0, 0, 76, 686, 1, 0, 0, 0, 78, 701, 1, 0, 0,
		0, 80, 715, 1, 0, 0, 0, 82, 734, 1, 0, 0, 0, 84, 736, 1, 0, 0, 0, 86, 739,
		1, 0, 0, 0, 88, 758, 1, 0, 0, 0, 90, 761, 1, 0, 0, 0, 92, 772, 1, 0, 0,
		0, 94, 781, 1, 0, 0, 0, 96, 790, 1, 0, 0, 0, 98, 800, 1, 0, 0, 0, 100,
		807, 1, 0, 0, 0, 102, 814, 1, 0, 0, 0, 104, 821, 1, 0, 0, 0, 106, 828,
		1, 0, 0, 0, 108, 836, 1, 0, 0, 0, 110, 842, 1, 0, 0, 0, 112, 847, 1, 0,
		0, 0, 114, 852, 1, 0, 0, 0, 116, 865, 1, 0, 0, 0, 118, 878, 1, 0, 0, 0,
		120, 885, 1, 0, 0, 0, 122, 895, 1, 0, 0, 0, 124, 902, 1, 0, 0, 0, 126,
		905, 1, 0, 0, 0, 128, 912, 1, 0, 0, 0, 130, 921, 1, 0, 0, 0, 132, 931,
		1, 0, 0, 0, 134, 935, 1, 0, 0, 0, 136, 940, 1, 0, 0, 0, 138, 945, 1, 0,
		0, 0, 140, 950, 1, 0, 0, 0, 142, 952, 1, 0, 0, 0, 144, 957, 1, 0, 0, 0,
		146, 964, 1, 0, 0, 0, 148, 971, 1, 0, 0, 0, 150, 975, 1, 0, 0, 0, 152,
		981, 1, 0, 0, 0, 154, 987, 1, 0, 0, 0, 156, 993, 1, 0, 0, 0, 158, 1000,
		1, 0, 0, 0, 160, 1014, 1, 0, 0, 0, 162, 1016, 1, 0, 0, 0, 164, 1036, 1,
		0, 0, 0, 166, 1042, 1, 0, 0, 0, 168, 1045, 1, 0, 0, 0, 170, 1065, 1, 0,
		0, 0, 172, 1067, 1, 0, 0, 0, 174, 1080, 1, 0, 0, 0, 176, 1096, 1, 0, 0,
		0, 178, 1113, 1, 0, 0, 0, 180, 1117, 1, 0, 0, 0, 182, 1122, 1, 0, 0, 0,
		184, 1131, 1, 0, 0, 0, 186, 1142, 1, 0, 0, 0, 188, 1144, 1, 0, 0, 0, 190,
		1152, 1, 0, 0, 0, 192, 1154, 1, 0, 0, 0, 194, 1164, 1, 0, 0, 0, 196, 1179,
		1, 0, 0, 0, 198, 1195, 1, 0, 0, 0, 200, 1197, 1, 0, 0, 0, 202, 1213, 1,
		0, 0, 0, 204, 1217, 1, 0, 0, 0, 206, 1219, 1, 0, 0, 0, 208, 1223, 1, 0,
		0, 0, 210, 1278, 1, 0, 0, 0, 212, 1289, 1, 0, 0, 0, 214, 1294, 1, 0, 0,
		0, 216, 1299, 1, 0, 0, 0, 218, 1301, 1, 0, 0, 0, 220, 1314, 1, 0, 0, 0,
		222, 1316, 1, 0, 0, 0, 224, 1331, 1, 0, 0, 0, 226, 1338, 1, 0, 0, 0, 228,
		1340, 1, 0, 0, 0, 230, 1351, 1, 0, 0, 0, 232, 1373, 1, 0, 0, 0, 234, 1375,
		1, 0, 0, 0, 236, 1394, 1, 0, 0, 0, 238, 1396, 1, 0, 0, 0, 240, 1408, 1,
		0, 0, 0, 242, 1415, 1, 0, 0, 0, 244, 1417, 1, 0, 0, 0, 246, 1423, 1, 0,
		0, 0, 248, 1427, 1, 0, 0, 0, 250, 1431, 1, 0, 0, 0, 252, 1433, 1, 0, 0,
		0, 254, 259, 3, 2, 1, 0, 255, 256, 5, 1, 0, 0, 256, 258, 3, 2, 1, 0, 257,
		255, 1, 0, 0, 0, 258, 261, 1, 0, 0, 0, 259, 257, 1, 0, 0, 0, 259, 260,
		1, 0, 0, 0, 260, 265, 1, 0, 0, 0, 261, 259, 1, 0, 0, 0, 262, 264, 5, 1,
		0, 0, 263, 262, 1, 0, 0, 0, 264, 267, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0,
		265, 266, 1, 0, 0, 0, 266, 268, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 268,
		269, 5, 0, 0, 1, 269, 1, 1, 0, 0, 0, 270, 296, 3, 6, 3, 0, 271, 296, 3,
		4, 2, 0, 272, 296, 3, 108, 54, 0, 273, 296, 3, 64, 32, 0, 274, 296, 3,
		66, 33, 0, 275, 296, 3, 98, 49, 0, 276, 296, 3, 100, 50, 0, 277, 296, 3,
		104, 52, 0, 278, 296, 3, 94, 47, 0, 279, 296, 3, 114, 57, 0, 280, 296,
		3, 116, 58, 0, 281, 296, 3, 118, 59, 0, 282, 296, 3, 124, 62, 0, 283, 296,
		3, 92, 46, 0, 284, 296, 3, 86, 43, 0, 285, 296, 3, 102, 51, 0, 286, 296,
		3, 126, 63, 0, 287, 296, 3, 128, 64, 0, 288, 296, 3, 110, 55, 0, 289, 296,
		3, 112, 56, 0, 290, 296, 3, 106, 53, 0, 291, 296, 3, 96, 48, 0, 292, 296,
		3, 120, 60, 0, 293, 296, 3, 122, 61, 0, 294, 296, 3, 130, 65, 0, 295, 270,
		1, 0, 0, 0, 295, 271, 1, 0, 0, 0, 295, 272, 1, 0, 0, 0, 295, 273, 1, 0,
		0, 0, 295, 274, 1, 0, 0, 0, 295, 275, 1, 0, 0, 0, 295, 276, 1, 0, 0, 0,
		295, 277, 1, 0, 0, 0, 295, 278, 1, 0, 0, 0, 295, 279, 1, 0, 0, 0, 295,
		280, 1, 0, 0, 0, 295, 281, 1, 0, 0, 0, 295, 282, 1, 0, 0, 0, 295, 283,
		1, 0, 0, 0, 295, 284, 1, 0, 0, 0, 295, 285, 1, 0, 0, 0, 295, 286, 1, 0,
		0, 0, 295, 287, 1, 0, 0, 0, 295, 288, 1, 0, 0, 0, 295, 289, 1, 0, 0, 0,
		295, 290, 1, 0, 0, 0, 295, 291, 1, 0, 0, 0, 295, 292, 1, 0, 0, 0, 295,
		293, 1, 0, 0, 0, 295, 294, 1, 0, 0, 0, 296, 3, 1, 0, 0, 0, 297, 298, 5,
		39, 0, 0, 298, 299, 3, 142, 71, 0, 299, 5, 1, 0, 0, 0, 300, 302, 5, 23,
		0, 0, 301, 303, 5, 171, 0, 0, 302, 301, 1, 0, 0, 0, 302, 303, 1, 0, 0,
		0, 303, 304, 1, 0, 0, 0, 304, 305, 3, 8, 4, 0, 305, 306, 5, 24, 0, 0, 306,
		309, 3, 146, 73, 0, 307, 308, 5, 26, 0, 0, 308, 310, 3, 54, 27, 0, 309,
		307, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 321, 1, 0, 0, 0, 311, 312,
		5, 86, 0, 0, 312, 313, 5, 77, 0, 0, 313, 318, 3, 62, 31, 0, 314, 315, 5,
		2, 0, 0, 315, 317, 3, 62, 31, 0, 316, 314, 1, 0, 0, 0, 317, 320, 1, 0,
		0, 0, 318, 316, 1, 0, 0, 0, 318, 319, 1, 0, 0, 0, 319, 322, 1, 0, 0, 0,
		320, 318, 1, 0, 0, 0, 321, 311, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322,
		333, 1, 0, 0, 0, 323, 324, 5, 76, 0, 0, 324, 325, 5, 77, 0, 0, 325, 330,
		3, 60, 30, 0, 326, 327, 5, 2, 0, 0, 327, 329, 3, 60, 30, 0, 328, 326, 1,
		0, 0, 0, 329, 332, 1, 0, 0, 0, 330, 328, 1, 0, 0, 0, 330, 331, 1, 0, 0,
		0, 331, 334, 1, 0, 0, 0, 332, 330, 1, 0, 0, 0, 333, 323, 1, 0, 0, 0, 333,
		334, 1, 0, 0, 0, 334, 339, 1, 0, 0, 0, 335, 336, 5, 36, 0, 0, 336, 337,
		5, 37, 0, 0, 337, 338, 5, 35, 0, 0, 338, 340, 3, 180, 90, 0, 339, 335,
		1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 343, 1, 0, 0, 0, 341, 342, 5, 35,
		0, 0, 342, 344, 3, 180, 90, 0, 343, 341, 1, 0, 0, 0, 343, 344, 1, 0, 0,
		0, 344, 347, 1, 0, 0, 0, 345, 346, 5, 80, 0, 0, 346, 348, 5, 81, 0, 0,
		347, 345, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 7, 1, 0, 0, 0, 349, 350,
		5, 40, 0, 0, 350, 353, 3, 10, 5, 0, 351, 353, 3, 10, 5, 0, 352, 349, 1,
		0, 0, 0, 352, 351, 1, 0, 0, 0, 353, 9, 1, 0, 0, 0, 354, 359, 3, 12, 6,
		0, 355, 356, 5, 2, 0, 0, 356, 358, 3, 12, 6, 0, 357, 355, 1, 0, 0, 0, 358,
		361, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 364,
		1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 362, 364, 5, 3, 0, 0, 363, 354, 1, 0,
		0, 0, 363, 362, 1, 0, 0, 0, 364, 11, 1, 0, 0, 0, 365, 368, 3, 14, 7, 0,
		366, 367, 5, 25, 0, 0, 367, 369, 3, 140, 70, 0, 368, 366, 1, 0, 0, 0, 368,
		369, 1, 0, 0, 0, 369, 13, 1, 0, 0, 0, 370, 371, 3, 16, 8, 0, 371, 15, 1,
		0, 0, 0, 372, 379, 3, 18, 9, 0, 373, 374, 5, 4, 0, 0, 374, 378, 3, 18,
		9, 0, 375, 376, 5, 5, 0, 0, 376, 378, 3, 18, 9, 0, 377, 373, 1, 0, 0, 0,
		377, 375, 1, 0, 0, 0, 378, 381, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 379,
		380, 1, 0, 0, 0, 380, 17, 1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 382, 391, 3,
		20, 10, 0, 383, 384, 5, 3, 0, 0, 384, 390, 3, 20, 10, 0, 385, 386, 5, 6,
		0, 0, 386, 390, 3, 20, 10, 0, 387, 388, 5, 7, 0, 0, 388, 390, 3, 20, 10,
		0, 389, 383, 1, 0, 0, 0, 389, 385, 1, 0, 0, 0, 389, 387, 1, 0, 0, 0, 390,
		393, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 19, 1,
		0, 0, 0, 393, 391, 1, 0, 0, 0, 394, 399, 3, 22, 11, 0, 395, 399, 3, 28,
		14, 0, 396, 397, 5, 5, 0, 0, 397, 399, 3, 20, 10, 0, 398, 394, 1, 0, 0,
		0, 398, 395, 1, 0, 0, 0, 398, 396, 1, 0, 0, 0, 399, 21, 1, 0, 0, 0, 400,
		402, 3, 28, 14, 0, 401, 403, 3, 24, 12, 0, 402, 401, 1, 0, 0, 0, 403, 404,
		1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 23, 1, 0,
		0, 0, 406, 407, 5, 8, 0, 0, 407, 413, 3, 138, 69, 0, 408, 409, 5, 9, 0,
		0, 409, 410, 3, 26, 13, 0, 410, 411, 5, 10, 0, 0, 411, 413, 1, 0, 0, 0,
		412, 406, 1, 0, 0, 0, 412, 408, 1, 0, 0, 0, 413, 25, 1, 0, 0, 0, 414, 425,
		3, 190, 95, 0, 415, 420, 3, 190, 95, 0, 416, 418, 5, 185, 0, 0, 417, 419,
		3, 190, 95, 0, 418, 417, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 421, 1,
		0, 0, 0, 420, 416, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 425, 1, 0, 0,
		0, 422, 423, 5, 185, 0, 0, 423, 425, 3, 190, 95, 0, 424, 414, 1, 0, 0,
		0, 424, 415, 1, 0, 0, 0, 424, 422, 1, 0, 0, 0, 425, 27, 1, 0, 0, 0, 426,
		432, 3, 42, 21, 0, 427, 432, 3, 30, 15, 0, 428, 432, 3, 40, 20, 0, 429,
		432, 3, 32, 16, 0, 430, 432, 3, 34, 17, 0, 431, 426, 1, 0, 0, 0, 431, 427,
		1, 0, 0, 0, 431, 428, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 430, 1, 0,
		0, 0, 432, 29, 1, 0, 0, 0, 433, 434, 5, 11, 0, 0, 434, 435, 3, 232, 116,
		0, 435, 436, 5, 12, 0, 0, 436, 437, 3, 28, 14, 0, 437, 31, 1, 0, 0, 0,
		438, 447, 5, 9, 0, 0, 439, 444, 3, 14, 7, 0, 440, 441, 5, 2, 0, 0, 441,
		443, 3, 14, 7, 0, 442, 440, 1, 0, 0, 0, 443, 446, 1, 0, 0, 0, 444, 442,
		1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446, 444, 1, 0,
		0, 0, 447, 439, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0,
		449, 450, 5, 10, 0, 0, 450, 33, 1, 0, 0, 0, 451, 452, 5, 13, 0, 0, 452,
		455, 3, 14, 7, 0, 453, 456, 3, 36, 18, 0, 454, 456, 3, 38, 19, 0, 455,
		453, 1, 0, 0, 0, 455, 454, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 458,
		5, 14, 0, 0, 458, 462, 1, 0, 0, 0, 459, 460, 5, 13, 0, 0, 460, 462, 5,
		14, 0, 0, 461, 451, 1, 0, 0, 0, 461, 459, 1, 0, 0, 0, 462, 35, 1, 0, 0,
		0, 463, 464, 5, 15, 0, 0, 464, 472, 3, 14, 7, 0, 465, 466, 5, 2, 0, 0,
		466, 467, 3, 14, 7, 0, 467, 468, 5, 15, 0, 0, 468, 469, 3, 14, 7, 0, 469,
		471, 1, 0, 0, 0, 470, 465, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470,
		1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 37, 1, 0, 0, 0, 474, 472, 1, 0,
		0, 0, 475, 476, 5, 2, 0, 0, 476, 478, 3, 14, 7, 0, 477, 475, 1, 0, 0, 0,
		478, 481, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480,
		39, 1, 0, 0, 0, 481, 479, 1, 0, 0, 0, 482, 483, 5, 11, 0, 0, 483, 488,
		3, 14, 7, 0, 484, 485, 5, 2, 0, 0, 485, 487, 3, 14, 7, 0, 486, 484, 1,
		0, 0, 0, 487, 490, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 488, 489, 1, 0, 0,
		0, 489, 491, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 491, 492, 5, 12, 0, 0, 492,
		41, 1, 0, 0, 0, 493, 497, 3, 52, 26, 0, 494, 497, 3, 46, 23, 0, 495, 497,
		3, 44, 22, 0, 496, 493, 1, 0, 0, 0, 496, 494, 1, 0, 0, 0, 496, 495, 1,
		0, 0, 0, 497, 43, 1, 0, 0, 0, 498, 499, 5, 41, 0, 0, 499, 500, 5, 11, 0,
		0, 500, 501, 5, 3, 0, 0, 501, 546, 5, 12, 0, 0, 502, 503, 5, 141, 0, 0,
		503, 504, 5, 11, 0, 0, 504, 508, 3, 52, 26, 0, 505, 507, 3, 24, 12, 0,
		506, 505, 1, 0, 0, 0, 507, 510, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0, 508,
		509, 1, 0, 0, 0, 509, 511, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 511, 512,
		5, 12, 0, 0, 512, 546, 1, 0, 0, 0, 513, 514, 5, 140, 0, 0, 514, 515, 5,
		11, 0, 0, 515, 519, 3, 52, 26, 0, 516, 518, 3, 24, 12, 0, 517, 516, 1,
		0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 519, 520, 1, 0, 0,
		0, 520, 522, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 522, 523, 5, 12, 0, 0, 523,
		546, 1, 0, 0, 0, 524, 525, 5, 67, 0, 0, 525, 526, 5, 11, 0, 0, 526, 530,
		3, 52, 26, 0, 527, 529, 3, 24, 12, 0, 528, 527, 1, 0, 0, 0, 529, 532, 1,
		0, 0, 0, 530, 528, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 533, 1, 0, 0,
		0, 532, 530, 1, 0, 0, 0, 533, 534, 5, 12, 0, 0, 534, 546, 1, 0, 0, 0, 535,
		536, 5, 68, 0, 0, 536, 537, 5, 11, 0, 0, 537, 538, 3, 14, 7, 0, 538, 539,
		5, 25, 0, 0, 539, 540, 3, 234, 117, 0, 540, 541, 5, 12, 0, 0, 541, 546,
		1, 0, 0, 0, 542, 543, 3, 182, 91, 0, 543, 544, 3, 50, 25, 0, 544, 546,
		1, 0, 0, 0, 545, 498, 1, 0, 0, 0, 545, 502, 1, 0, 0, 0, 545, 513, 1, 0,
		0, 0, 545, 524, 1, 0, 0, 0, 545, 535, 1, 0, 0, 0, 545, 542, 1, 0, 0, 0,
		546, 45, 1, 0, 0, 0, 547, 551, 3, 160, 80, 0, 548, 551, 5, 144, 0, 0, 549,
		551, 3, 48, 24, 0, 550, 547, 1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 550, 549,
		1, 0, 0, 0, 551, 47, 1, 0, 0, 0, 552, 553, 5, 15, 0, 0, 553, 556, 3, 140,
		70, 0, 554, 556, 5, 184, 0, 0, 555, 552, 1, 0, 0, 0, 555, 554, 1, 0, 0,
		0, 556, 49, 1, 0, 0, 0, 557, 566, 5, 11, 0, 0, 558, 563, 3, 14, 7, 0, 559,
		560, 5, 2, 0, 0, 560, 562, 3, 14, 7, 0, 561, 559, 1, 0, 0, 0, 562, 565,
		1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 567, 1, 0,
		0, 0, 565, 563, 1, 0, 0, 0, 566, 558, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0,
		567, 568, 1, 0, 0, 0, 568, 569, 5, 12, 0, 0, 569, 51, 1, 0, 0, 0, 570,
		574, 5, 189, 0, 0, 571, 574, 5, 181, 0, 0, 572, 574, 3, 248, 124, 0, 573,
		570, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0, 573, 572, 1, 0, 0, 0, 574, 53, 1,
		0, 0, 0, 575, 580, 3, 56, 28, 0, 576, 577, 5, 27, 0, 0, 577, 579, 3, 56,
		28, 0, 578, 576, 1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0,
		580, 581, 1, 0, 0, 0, 581, 55, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 583, 586,
		3, 210, 105, 0, 584, 586, 3, 58, 29, 0, 585, 583, 1, 0, 0, 0, 585, 584,
		1, 0, 0, 0, 586, 57, 1, 0, 0, 0, 587, 588, 5, 16, 0, 0, 588, 589, 3, 156,
		78, 0, 589, 590, 5, 2, 0, 0, 590, 591, 3, 190, 95, 0, 591, 592, 5, 12,
		0, 0, 592, 59, 1, 0, 0, 0, 593, 597, 3, 134, 67, 0, 594, 595, 5, 179, 0,
		0, 595, 596, 5, 94, 0, 0, 596, 598, 3, 190, 95, 0, 597, 594, 1, 0, 0, 0,
		597, 598, 1, 0, 0, 0, 598, 600, 1, 0, 0, 0, 599, 601, 7, 0, 0, 0, 600,
		599, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 61, 1, 0, 0, 0, 602, 603, 3,
		14, 7, 0, 603, 63, 1, 0, 0, 0, 604, 605, 5, 50, 0, 0, 605, 607, 5, 52,
		0, 0, 606, 608, 3, 68, 34, 0, 607, 606, 1, 0, 0, 0, 607, 608, 1, 0, 0,
		0, 608, 609, 1, 0, 0, 0, 609, 610, 3, 142, 71, 0, 610, 611, 5, 34, 0, 0,
		611, 612, 3, 200, 100, 0, 612, 65, 1, 0, 0, 0, 613, 614, 5, 50, 0, 0, 614,
		616, 5, 54, 0, 0, 615, 617, 3, 68, 34, 0, 616, 615, 1, 0, 0, 0, 616, 617,
		1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 619, 3, 146, 73, 0, 619, 620, 3,
		72, 36, 0, 620, 67, 1, 0, 0, 0, 621, 622, 5, 82, 0, 0, 622, 623, 5, 145,
		0, 0, 623, 624, 5, 146, 0, 0, 624, 69, 1, 0, 0, 0, 625, 626, 5, 82, 0,
		0, 626, 627, 5, 146, 0, 0, 627, 71, 1, 0, 0, 0, 628, 629, 5, 11, 0, 0,
		629, 636, 3, 74, 37, 0, 630, 632, 5, 2, 0, 0, 631, 633, 3, 74, 37, 0, 632,
		631, 1, 0, 0, 0, 632, 633, 1, 0, 0, 0, 633, 635, 1, 0, 0, 0, 634, 630,
		1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 636, 637, 1, 0,
		0, 0, 637, 639, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 639, 649, 5, 12, 0, 0,
		640, 641, 5, 34, 0, 0, 641, 646, 3, 82, 41, 0, 642, 643, 5, 27, 0, 0, 643,
		645, 3, 82, 41, 0, 644, 642, 1, 0, 0, 0, 645, 648, 1, 0, 0, 0, 646, 644,
		1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1, 0,
		0, 0, 649, 640, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 73, 1, 0, 0, 0,
		651, 652, 3, 136, 68, 0, 652, 654, 3, 232, 116, 0, 653, 655, 5, 155, 0,
		0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 657, 1, 0, 0, 0, 656,
		658, 3, 76, 38, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 661,
		1, 0, 0, 0, 659, 660, 5, 63, 0, 0, 660, 662, 5, 28, 0, 0, 661, 659, 1,
		0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 677, 1, 0, 0, 0, 663, 664, 5, 63, 0,
		0, 664, 665, 5, 28, 0, 0, 665, 666, 5, 11, 0, 0, 666, 671, 3, 80, 40, 0,
		667, 668, 5, 2, 0, 0, 668, 670, 3, 136, 68, 0, 669, 667, 1, 0, 0, 0, 670,
		673, 1, 0, 0, 0, 671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 674,
		1, 0, 0, 0, 673, 671, 1, 0, 0, 0, 674, 675, 5, 12, 0, 0, 675, 677, 1, 0,
		0, 0, 676, 651, 1, 0, 0, 0, 676, 663, 1, 0, 0, 0, 677, 75, 1, 0, 0, 0,
		678, 679, 5, 175, 0, 0, 679, 680, 5, 34, 0, 0, 680, 681, 3, 182, 91, 0,
		681, 682, 3, 78, 39, 0, 682, 687, 1, 0, 0, 0, 683, 684, 5, 175, 0, 0, 684,
		685, 5, 34, 0, 0, 685, 687, 5, 172, 0, 0, 686, 678, 1, 0, 0, 0, 686, 683,
		1, 0, 0, 0, 687, 77, 1, 0, 0, 0, 688, 689, 5, 11, 0, 0, 689, 702, 5, 12,
		0, 0, 690, 691, 5, 11, 0, 0, 691, 696, 3, 190, 95, 0, 692, 693, 5, 2, 0,
		0, 693, 695, 3, 190, 95, 0, 694, 692, 1, 0, 0, 0, 695, 698, 1, 0, 0, 0,
		696, 694, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 699, 1, 0, 0, 0, 698,
		696, 1, 0, 0, 0, 699, 700, 5, 12, 0, 0, 700, 702, 1, 0, 0, 0, 701, 688,
		1, 0, 0, 0, 701, 690, 1, 0, 0, 0, 702, 79, 1, 0, 0, 0, 703, 716, 3, 136,
		68, 0, 704, 705, 5, 11, 0, 0, 705, 710, 3, 136, 68, 0, 706, 707, 5, 2,
		0, 0, 707, 709, 3, 136, 68, 0, 708, 706, 1, 0, 0, 0, 709, 712, 1, 0, 0,
		0, 710, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 713, 1, 0, 0, 0, 712,
		710, 1, 0, 0, 0, 713, 714, 5, 12, 0, 0, 714, 716, 1, 0, 0, 0, 715, 703,
		1, 0, 0, 0, 715, 704, 1, 0, 0, 0, 716, 81, 1, 0, 0, 0, 717, 735, 3, 202,
		101, 0, 718, 719, 5, 74, 0, 0, 719, 735, 5, 75, 0, 0, 720, 721, 5, 120,
		0, 0, 721, 722, 5, 76, 0, 0, 722, 723, 5, 77, 0, 0, 723, 724, 5, 11, 0,
		0, 724, 729, 3, 84, 42, 0, 725, 726, 5, 2, 0, 0, 726, 728, 3, 84, 42, 0,
		727, 725, 1, 0, 0, 0, 728, 731, 1, 0, 0, 0, 729, 727, 1, 0, 0, 0, 729,
		730, 1, 0, 0, 0, 730, 732, 1, 0, 0, 0, 731, 729, 1, 0, 0, 0, 732, 733,
		5, 12, 0, 0, 733, 735, 1, 0, 0, 0, 734, 717, 1, 0, 0, 0, 734, 718, 1, 0,
		0, 0, 734, 720, 1, 0, 0, 0, 735, 83, 1, 0, 0, 0, 736, 737, 3, 136, 68,
		0, 737, 738, 7, 0, 0, 0, 738, 85, 1, 0, 0, 0, 739, 740, 5, 50, 0, 0, 740,
		742, 5, 72, 0, 0, 741, 743, 3, 68, 34, 0, 742, 741, 1, 0, 0, 0, 742, 743,
		1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 745, 3, 148, 74, 0, 745, 746, 5,
		11, 0, 0, 746, 753, 3, 88, 44, 0, 747, 749, 5, 2, 0, 0, 748, 750, 3, 88,
		44, 0, 749, 748, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 752, 1, 0, 0, 0,
		751, 747, 1, 0, 0, 0, 752, 755, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753,
		754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 753, 1, 0, 0, 0, 756, 757,
		5, 12, 0, 0, 757, 87, 1, 0, 0, 0, 758, 759, 3, 138, 69, 0, 759, 760, 3,
		232, 116, 0, 760, 89, 1, 0, 0, 0, 761, 762, 5, 50, 0, 0, 762, 764, 5, 154,
		0, 0, 763, 765, 3, 68, 34, 0, 764, 763, 1, 0, 0, 0, 764, 765, 1, 0, 0,
		0, 765, 766, 1, 0, 0, 0, 766, 767, 3, 136, 68, 0, 767, 768, 5, 60, 0, 0,
		768, 769, 3, 146, 73, 0, 769, 770, 5, 38, 0, 0, 770, 771, 5, 180, 0, 0,
		771, 91, 1, 0, 0, 0, 772, 773, 5, 62, 0, 0, 773, 775, 5, 154, 0, 0, 774,
		776, 3, 70, 35, 0, 775, 774, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 777,
		1, 0, 0, 0, 777, 778, 3, 136, 68, 0, 778, 779, 5, 60, 0, 0, 779, 780, 3,
		146, 73, 0, 780, 93, 1, 0, 0, 0, 781, 782, 5, 69, 0, 0, 782, 784, 5, 52,
		0, 0, 783, 785, 3, 70, 35, 0, 784, 783, 1, 0, 0, 0, 784, 785, 1, 0, 0,
		0, 785, 786, 1, 0, 0, 0, 786, 787, 3, 142, 71, 0, 787, 788, 5, 34, 0, 0,
		788, 789, 3, 200, 100, 0, 789, 95, 1, 0, 0, 0, 790, 791, 5, 69, 0, 0, 791,
		792, 5, 56, 0, 0, 792, 794, 5, 57, 0, 0, 793, 795, 3, 70, 35, 0, 794, 793,
		1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 797, 3, 146,
		73, 0, 797, 798, 5, 34, 0, 0, 798, 799, 3, 200, 100, 0, 799, 97, 1, 0,
		0, 0, 800, 801, 5, 62, 0, 0, 801, 803, 5, 52, 0, 0, 802, 804, 3, 70, 35,
		0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805,
		806, 3, 142, 71, 0, 806, 99, 1, 0, 0, 0, 807, 808, 5, 62, 0, 0, 808, 810,
		5, 54, 0, 0, 809, 811, 3, 70, 35, 0, 810, 809, 1, 0, 0, 0, 810, 811, 1,
		0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 813, 3, 146, 73, 0, 813, 101, 1, 0,
		0, 0, 814, 815, 5, 62, 0, 0, 815, 817, 5, 72, 0, 0, 816, 818, 3, 70, 35,
		0, 817, 816, 1, 0, 0, 0, 817, 818, 1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819,
		820, 3, 148, 74, 0, 820, 103, 1, 0, 0, 0, 821, 822, 5, 62, 0, 0, 822, 824,
		5, 58, 0, 0, 823, 825, 3, 70, 35, 0, 824, 823, 1, 0, 0, 0, 824, 825, 1,
		0, 0, 0, 825, 826, 1, 0, 0, 0, 826, 827, 3, 144, 72, 0, 827, 105, 1, 0,
		0, 0, 828, 829, 5, 62, 0, 0, 829, 830, 5, 56, 0, 0, 830, 832, 5, 57, 0,
		0, 831, 833, 3, 70, 35, 0, 832, 831, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0,
		833, 834, 1, 0, 0, 0, 834, 835, 3, 146, 73, 0, 835, 107, 1, 0, 0, 0, 836,
		838, 5, 47, 0, 0, 837, 839, 5, 54, 0, 0, 838, 837, 1, 0, 0, 0, 838, 839,
		1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 841, 3, 146, 73, 0, 841, 109, 1,
		0, 0, 0, 842, 843, 5, 90, 0, 0, 843, 844, 3, 150, 75, 0, 844, 845, 5, 61,
		0, 0, 845, 846, 3, 150, 75, 0, 846, 111, 1, 0, 0, 0, 847, 848, 5, 95, 0,
		0, 848, 849, 3, 150, 75, 0, 849, 850, 5, 24, 0, 0, 850, 851, 3, 150, 75,
		0, 851, 113, 1, 0, 0, 0, 852, 853, 5, 50, 0, 0, 853, 855, 5, 103, 0, 0,
		854, 856, 3, 68, 34, 0, 855, 854, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856,
		857, 1, 0, 0, 0, 857, 860, 3, 242, 121, 0, 858, 859, 5, 34, 0, 0, 859,
		861, 3, 132, 66, 0, 860, 858, 1, 0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 863,
		1, 0, 0, 0, 862, 864, 7, 1, 0, 0, 863, 862, 1, 0, 0, 0, 863, 864, 1, 0,
		0, 0, 864, 115, 1, 0, 0, 0, 865, 866, 5, 69, 0, 0, 866, 868, 5, 103, 0,
		0, 867, 869, 3, 70, 35, 0, 868, 867, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0,
		869, 870, 1, 0, 0, 0, 870, 873, 3, 242, 121, 0, 871, 872, 5, 34, 0, 0,
		872, 874, 3, 132, 66, 0, 873, 871, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874,
		876, 1, 0, 0, 0, 875, 877, 7, 1, 0, 0, 876, 875, 1, 0, 0, 0, 876, 877,
		1, 0, 0, 0, 877, 117, 1, 0, 0, 0, 878, 879, 5, 62, 0, 0, 879, 881, 5, 103,
		0, 0, 880, 882, 3, 70, 35, 0, 881, 880, 1, 0, 0, 0, 881, 882, 1, 0, 0,
		0, 882, 883, 1, 0, 0, 0, 883, 884, 3, 242, 121, 0, 884, 119, 1, 0, 0, 0,
		885, 886, 5, 71, 0, 0, 886, 888, 5, 119, 0, 0, 887, 889, 3, 68, 34, 0,
		888, 887, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890,
		891, 3, 244, 122, 0, 891, 892, 5, 61, 0, 0, 892, 893, 5, 105, 0, 0, 893,
		894, 3, 244, 122, 0, 894, 121, 1, 0, 0, 0, 895, 896, 5, 62, 0, 0, 896,
		898, 5, 119, 0, 0, 897, 899, 3, 70, 35, 0, 898, 897, 1, 0, 0, 0, 898, 899,
		1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 901, 3, 244, 122, 0, 901, 123, 1,
		0, 0, 0, 902, 903, 5, 148, 0, 0, 903, 904, 5, 104, 0, 0, 904, 125, 1, 0,
		0, 0, 905, 906, 5, 62, 0, 0, 906, 908, 5, 105, 0, 0, 907, 909, 3, 70, 35,
		0, 908, 907, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910,
		911, 3, 150, 75, 0, 911, 127, 1, 0, 0, 0, 912, 913, 5, 148, 0, 0, 913,
		916, 5, 106, 0, 0, 914, 915, 5, 94, 0, 0, 915, 917, 3, 158, 79, 0, 916,
		914, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 919, 1, 0, 0, 0, 918, 920,
		5, 100, 0, 0, 919, 918, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 129, 1,
		0, 0, 0, 921, 922, 5, 148, 0, 0, 922, 923, 5, 107, 0, 0, 923, 131, 1, 0,
		0, 0, 924, 925, 5, 111, 0, 0, 925, 932, 5, 180, 0, 0, 926, 927, 5, 112,
		0, 0, 927, 928, 5, 111, 0, 0, 928, 932, 5, 180, 0, 0, 929, 930, 5, 110,
		0, 0, 930, 932, 5, 111, 0, 0, 931, 924, 1, 0, 0, 0, 931, 926, 1, 0, 0,
		0, 931, 929, 1, 0, 0, 0, 932, 133, 1, 0, 0, 0, 933, 936, 5, 182, 0, 0,
		934, 936, 3, 136, 68, 0, 935, 933, 1, 0, 0, 0, 935, 934, 1, 0, 0, 0, 936,
		135, 1, 0, 0, 0, 937, 941, 5, 189, 0, 0, 938, 941, 5, 181, 0, 0, 939, 941,
		3, 248, 124, 0, 940, 937, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 939, 1,
		0, 0, 0, 941, 137, 1, 0, 0, 0, 942, 946, 5, 189, 0, 0, 943, 946, 5, 181,
		0, 0, 944, 946, 3, 248, 124, 0, 945, 942, 1, 0, 0, 0, 945, 943, 1, 0, 0,
		0, 945, 944, 1, 0, 0, 0, 946, 139, 1, 0, 0, 0, 947, 951, 5, 189, 0, 0,
		948, 951, 5, 181, 0, 0, 949, 951, 3, 248, 124, 0, 950, 947, 1, 0, 0, 0,
		950, 948, 1, 0, 0, 0, 950, 949, 1, 0, 0, 0, 951, 141, 1, 0, 0, 0, 952,
		953, 3, 152, 76, 0, 953, 143, 1, 0, 0, 0, 954, 955, 3, 152, 76, 0, 955,
		956, 5, 8, 0, 0, 956, 958, 1, 0, 0, 0, 957, 954, 1, 0, 0, 0, 957, 958,
		1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 960, 3, 156, 78, 0, 960, 145, 1,
		0, 0, 0, 961, 962, 3, 152, 76, 0, 962, 963, 5, 8, 0, 0, 963, 965, 1, 0,
		0, 0, 964, 961, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0,
		966, 967, 3, 154, 77, 0, 967, 147, 1, 0, 0, 0, 968, 969, 3, 140, 70, 0,
		969, 970, 5, 8, 0, 0, 970, 972, 1, 0, 0, 0, 971, 968, 1, 0, 0, 0, 971,
		972, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 974, 3, 246, 123, 0, 974, 149,
		1, 0, 0, 0, 975, 976, 3, 158, 79, 0, 976, 151, 1, 0, 0, 0, 977, 982, 5,
		189, 0, 0, 978, 982, 5, 181, 0, 0, 979, 982, 3, 248, 124, 0, 980, 982,
		5, 184, 0, 0, 981, 977, 1, 0, 0, 0, 981, 978, 1, 0, 0, 0, 981, 979, 1,
		0, 0, 0, 981, 980, 1, 0, 0, 0, 982, 153, 1, 0, 0, 0, 983, 988, 5, 189,
		0, 0, 984, 988, 5, 181, 0, 0, 985, 988, 3, 248, 124, 0, 986, 988, 5, 184,
		0, 0, 987, 983, 1, 0, 0, 0, 987, 984, 1, 0, 0, 0, 987, 985, 1, 0, 0, 0,
		987, 986, 1, 0, 0, 0, 988, 155, 1, 0, 0, 0, 989, 994, 5, 189, 0, 0, 990,
		994, 5, 181, 0, 0, 991, 994, 3, 248, 124, 0, 992, 994, 5, 184, 0, 0, 993,
		989, 1, 0, 0, 0, 993, 990, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0, 993, 992,
		1, 0, 0, 0, 994, 157, 1, 0, 0, 0, 995, 1001, 5, 189, 0, 0, 996, 1001, 5,
		180, 0, 0, 997, 1001, 5, 181, 0, 0, 998, 1001, 3, 248, 124, 0, 999, 1001,
		5, 184, 0, 0, 1000, 995, 1, 0, 0, 0, 1000, 996, 1, 0, 0, 0, 1000, 997,
		1, 0, 0, 0, 1000, 998, 1, 0, 0, 0, 1000, 999, 1, 0, 0, 0, 1001, 159, 1,
		0, 0, 0, 1002, 1015, 5, 180, 0, 0, 1003, 1015, 5, 183, 0, 0, 1004, 1015,
		5, 186, 0, 0, 1005, 1015, 5, 187, 0, 0, 1006, 1015, 5, 188, 0, 0, 1007,
		1015, 5, 191, 0, 0, 1008, 1015, 5, 190, 0, 0, 1009, 1013, 7, 2, 0, 0, 1010,
		1013, 5, 151, 0, 0, 1011, 1013, 5, 152, 0, 0, 1012, 1009, 1, 0, 0, 0, 1012,
		1010, 1, 0, 0, 0, 1012, 1011, 1, 0, 0, 0, 1013, 1015, 1, 0, 0, 0, 1014,
		1002, 1, 0, 0, 0, 1014, 1003, 1, 0, 0, 0, 1014, 1004, 1, 0, 0, 0, 1014,
		1005, 1, 0, 0, 0, 1014, 1006, 1, 0, 0, 0, 1014, 1007, 1, 0, 0, 0, 1014,
		1008, 1, 0, 0, 0, 1014, 1012, 1, 0, 0, 0, 1015, 161, 1, 0, 0, 0, 1016,
		1030, 5, 13, 0, 0, 1017, 1018, 3, 190, 95, 0, 1018, 1019, 5, 15, 0, 0,
		1019, 1027, 3, 190, 95, 0, 1020, 1021, 5, 2, 0, 0, 1021, 1022, 3, 190,
		95, 0, 1022, 1023, 5, 15, 0, 0, 1023, 1024, 3, 190, 95, 0, 1024, 1026,
		1, 0, 0, 0, 1025, 1020, 1, 0, 0, 0, 1026, 1029, 1, 0, 0, 0, 1027, 1025,
		1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1031, 1, 0, 0, 0, 1029, 1027,
		1, 0, 0, 0, 1030, 1017, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031, 1032,
		1, 0, 0, 0, 1032, 1033, 5, 14, 0, 0, 1033, 163, 1, 0, 0, 0, 1034, 1037,
		3, 168, 84, 0, 1035, 1037, 3, 166, 83, 0, 1036, 1034, 1, 0, 0, 0, 1036,
		1035, 1, 0, 0, 0, 1037, 165, 1, 0, 0, 0, 1038, 1039, 5, 2, 0, 0, 1039,
		1041, 3, 190, 95, 0, 1040, 1038, 1, 0, 0, 0, 1041, 1044, 1, 0, 0, 0, 1042,
		1040, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 167, 1, 0, 0, 0, 1044,
		1042, 1, 0, 0, 0, 1045, 1046, 5, 15, 0, 0, 1046, 1054, 3, 190, 95, 0, 1047,
		1048, 5, 2, 0, 0, 1048, 1049, 3, 190, 95, 0, 1049, 1050, 5, 15, 0, 0, 1050,
		1051, 3, 190, 95, 0, 1051, 1053, 1, 0, 0, 0, 1052, 1047, 1, 0, 0, 0, 1053,
		1056, 1, 0, 0, 0, 1054, 1052, 1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055,
		169, 1, 0, 0, 0, 1056, 1054, 1, 0, 0, 0, 1057, 1066, 3, 172, 86, 0, 1058,
		1059, 5, 13, 0, 0, 1059, 1060, 3, 190, 95, 0, 1060, 1061, 3, 164, 82, 0,
		1061, 1062, 5, 14, 0, 0, 1062, 1066, 1, 0, 0, 0, 1063, 1064, 5, 13, 0,
		0, 1064, 1066, 5, 14, 0, 0, 1065, 1057, 1, 0, 0, 0, 1065, 1058, 1, 0, 0,
		0, 1065, 1063, 1, 0, 0, 0, 1066, 171, 1, 0, 0, 0, 1067, 1076, 5, 9, 0,
		0, 1068, 1073, 3, 190, 95, 0, 1069, 1070, 5, 2, 0, 0, 1070, 1072, 3, 190,
		95, 0, 1071, 1069, 1, 0, 0, 0, 1072, 1075, 1, 0, 0, 0, 1073, 1071, 1, 0,
		0, 0, 1073, 1074, 1, 0, 0, 0, 1074, 1077, 1, 0, 0, 0, 1075, 1073, 1, 0,
		0, 0, 1076, 1068, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1078, 1, 0,
		0, 0, 1078, 1079, 5, 10, 0, 0, 1079, 173, 1, 0, 0, 0, 1080, 1081, 5, 13,
		0, 0, 1081, 1082, 3, 138, 69, 0, 1082, 1083, 5, 15, 0, 0, 1083, 1091, 3,
		190, 95, 0, 1084, 1085, 5, 2, 0, 0, 1085, 1086, 3, 138, 69, 0, 1086, 1087,
		5, 15, 0, 0, 1087, 1088, 3, 190, 95, 0, 1088, 1090, 1, 0, 0, 0, 1089, 1084,
		1, 0, 0, 0, 1090, 1093, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092,
		1, 0, 0, 0, 1092, 1094, 1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1094, 1095,
		5, 14, 0, 0, 1095, 175, 1, 0, 0, 0, 1096, 1097, 5, 11, 0, 0, 1097, 1102,
		3, 190, 95, 0, 1098, 1099, 5, 2, 0, 0, 1099, 1101, 3, 190, 95, 0, 1100,
		1098, 1, 0, 0, 0, 1101, 1104, 1, 0, 0, 0, 1102, 1100, 1, 0, 0, 0, 1102,
		1103, 1, 0, 0, 0, 1103, 1105, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1105,
		1106, 5, 12, 0, 0, 1106, 177, 1, 0, 0, 0, 1107, 1114, 3, 160, 80, 0, 1108,
		1114, 3, 170, 85, 0, 1109, 1114, 3, 174, 87, 0, 1110, 1114, 3, 176, 88,
		0, 1111, 1114, 5, 144, 0, 0, 1112, 1114, 3, 48, 24, 0, 1113, 1107, 1, 0,
		0, 0, 1113, 1108, 1, 0, 0, 0, 1113, 1109, 1, 0, 0, 0, 1113, 1110, 1, 0,
		0, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1112, 1, 0, 0, 0, 1114, 179, 1, 0,
		0, 0, 1115, 1118, 5, 183, 0, 0, 1116, 1118, 3, 48, 24, 0, 1117, 1115, 1,
		0, 0, 0, 1117, 1116, 1, 0, 0, 0, 1118, 181, 1, 0, 0, 0, 1119, 1120, 3,
		142, 71, 0, 1120, 1121, 5, 8, 0, 0, 1121, 1123, 1, 0, 0, 0, 1122, 1119,
		1, 0, 0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 1125,
		3, 184, 92, 0, 1125, 183, 1, 0, 0, 0, 1126, 1132, 5, 189, 0, 0, 1127, 1132,
		5, 181, 0, 0, 1128, 1132, 3, 250, 125, 0, 1129, 1132, 5, 139, 0, 0, 1130,
		1132, 5, 41, 0, 0, 1131, 1126, 1, 0, 0, 0, 1131, 1127, 1, 0, 0, 0, 1131,
		1128, 1, 0, 0, 0, 1131, 1129, 1, 0, 0, 0, 1131, 1130, 1, 0, 0, 0, 1132,
		185, 1, 0, 0, 0, 1133, 1134, 3, 182, 91, 0, 1134, 1135, 5, 11, 0, 0, 1135,
		1136, 5, 12, 0, 0, 1136, 1143, 1, 0, 0, 0, 1137, 1138, 3, 182, 91, 0, 1138,
		1139, 5, 11, 0, 0, 1139, 1140, 3, 188, 94, 0, 1140, 1141, 5, 12, 0, 0,
		1141, 1143, 1, 0, 0, 0, 1142, 1133, 1, 0, 0, 0, 1142, 1137, 1, 0, 0, 0,
		1143, 187, 1, 0, 0, 0, 1144, 1149, 3, 190, 95, 0, 1145, 1146, 5, 2, 0,
		0, 1146, 1148, 3, 190, 95, 0, 1147, 1145, 1, 0, 0, 0, 1148, 1151, 1, 0,
		0, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150, 189, 1, 0,
		0, 0, 1151, 1149, 1, 0, 0, 0, 1152, 1153, 3, 192, 96, 0, 1153, 191, 1,
		0, 0, 0, 1154, 1161, 3, 194, 97, 0, 1155, 1156, 5, 4, 0, 0, 1156, 1160,
		3, 194, 97, 0, 1157, 1158, 5, 5, 0, 0, 1158, 1160, 3, 194, 97, 0, 1159,
		1155, 1, 0, 0, 0, 1159, 1157, 1, 0, 0, 0, 1160, 1163, 1, 0, 0, 0, 1161,
		1159, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 193, 1, 0, 0, 0, 1163,
		1161, 1, 0, 0, 0, 1164, 1173, 3, 196, 98, 0, 1165, 1166, 5, 3, 0, 0, 1166,
		1172, 3, 196, 98, 0, 1167, 1168, 5, 6, 0, 0, 1168, 1172, 3, 196, 98, 0,
		1169, 1170, 5, 7, 0, 0, 1170, 1172, 3, 196, 98, 0, 1171, 1165, 1, 0, 0,
		0, 1171, 1167, 1, 0, 0, 0, 1171, 1169, 1, 0, 0, 0, 1172, 1175, 1, 0, 0,
		0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174, 195, 1, 0, 0,
		0, 1175, 1173, 1, 0, 0, 0, 1176, 1180, 3, 198, 99, 0, 1177, 1178, 5, 5,
		0, 0, 1178, 1180, 3, 198, 99, 0, 1179, 1176, 1, 0, 0, 0, 1179, 1177, 1,
		0, 0, 0, 1180, 197, 1, 0, 0, 0, 1181, 1196, 3, 178, 89, 0, 1182, 1196,
		3, 186, 93, 0, 1183, 1184, 5, 11, 0, 0, 1184, 1185, 3, 232, 116, 0, 1185,
		1186, 5, 12, 0, 0, 1186, 1187, 3, 198, 99, 0, 1187, 1196, 1, 0, 0, 0, 1188,
		1189, 5, 68, 0, 0, 1189, 1190, 5, 11, 0, 0, 1190, 1191, 3, 198, 99, 0,
		1191, 1192, 5, 25, 0, 0, 1192, 1193, 3, 234, 117, 0, 1193, 1194, 5, 12,
		0, 0, 1194, 1196, 1, 0, 0, 0, 1195, 1181, 1, 0, 0, 0, 1195, 1182, 1, 0,
		0, 0, 1195, 1183, 1, 0, 0, 0, 1195, 1188, 1, 0, 0, 0, 1196, 199, 1, 0,
		0, 0, 1197, 1202, 3, 202, 101, 0, 1198, 1199, 5, 27, 0, 0, 1199, 1201,
		3, 202, 101, 0, 1200, 1198, 1, 0, 0, 0, 1201, 1204, 1, 0, 0, 0, 1202, 1200,
		1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203, 201, 1, 0, 0, 0, 1204, 1202,
		1, 0, 0, 0, 1205, 1206, 3, 140, 70, 0, 1206, 1207, 5, 17, 0, 0, 1207, 1208,
		3, 204, 102, 0, 1208, 1214, 1, 0, 0, 0, 1209, 1210, 3, 140, 70, 0, 1210,
		1211, 5, 17, 0, 0, 1211, 1212, 3, 162, 81, 0, 1212, 1214, 1, 0, 0, 0, 1213,
		1205, 1, 0, 0, 0, 1213, 1209, 1, 0, 0, 0, 1214, 203, 1, 0, 0, 0, 1215,
		1218, 3, 160, 80, 0, 1216, 1218, 3, 248, 124, 0, 1217, 1215, 1, 0, 0, 0,
		1217, 1216, 1, 0, 0, 0, 1218, 205, 1, 0, 0, 0, 1219, 1220, 3, 190, 95,
		0, 1220, 1221, 5, 27, 0, 0, 1221, 1222, 3, 190, 95, 0, 1222, 207, 1, 0,
		0, 0, 1223, 1224, 7, 3, 0, 0, 1224, 209, 1, 0, 0, 0, 1225, 1242, 3, 134,
		67, 0, 1226, 1227, 3, 208, 104, 0, 1227, 1228, 3, 190, 95, 0, 1228, 1243,
		1, 0, 0, 0, 1229, 1230, 5, 85, 0, 0, 1230, 1243, 3, 206, 103, 0, 1231,
		1232, 5, 174, 0, 0, 1232, 1243, 3, 190, 95, 0, 1233, 1234, 5, 83, 0, 0,
		1234, 1235, 5, 145, 0, 0, 1235, 1243, 5, 144, 0, 0, 1236, 1237, 3, 214,
		107, 0, 1237, 1238, 3, 220, 110, 0, 1238, 1243, 1, 0, 0, 0, 1239, 1240,
		3, 212, 106, 0, 1240, 1241, 3, 190, 95, 0, 1241, 1243, 1, 0, 0, 0, 1242,
		1226, 1, 0, 0, 0, 1242, 1229, 1, 0, 0, 0, 1242, 1231, 1, 0, 0, 0, 1242,
		1233, 1, 0, 0, 0, 1242, 1236, 1, 0, 0, 0, 1242, 1239, 1, 0, 0, 0, 1243,
		1279, 1, 0, 0, 0, 1244, 1245, 5, 139, 0, 0, 1245, 1251, 3, 218, 109, 0,
		1246, 1247, 3, 208, 104, 0, 1247, 1248, 3, 190, 95, 0, 1248, 1252, 1, 0,
		0, 0, 1249, 1250, 5, 85, 0, 0, 1250, 1252, 3, 206, 103, 0, 1251, 1246,
		1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1279, 1, 0, 0, 0, 1253, 1254,
		3, 134, 67, 0, 1254, 1255, 5, 9, 0, 0, 1255, 1256, 3, 190, 95, 0, 1256,
		1257, 5, 10, 0, 0, 1257, 1258, 3, 208, 104, 0, 1258, 1259, 3, 190, 95,
		0, 1259, 1279, 1, 0, 0, 0, 1260, 1272, 3, 218, 109, 0, 1261, 1262, 3, 214,
		107, 0, 1262, 1263, 3, 226, 113, 0, 1263, 1273, 1, 0, 0, 0, 1264, 1265,
		3, 208, 104, 0, 1265, 1266, 3, 224, 112, 0, 1266, 1273, 1, 0, 0, 0, 1267,
		1268, 5, 85, 0, 0, 1268, 1269, 3, 224, 112, 0, 1269, 1270, 5, 27, 0, 0,
		1270, 1271, 3, 224, 112, 0, 1271, 1273, 1, 0, 0, 0, 1272, 1261, 1, 0, 0,
		0, 1272, 1264, 1, 0, 0, 0, 1272, 1267, 1, 0, 0, 0, 1273, 1279, 1, 0, 0,
		0, 1274, 1275, 5, 11, 0, 0, 1275, 1276, 3, 210, 105, 0, 1276, 1277, 5,
		12, 0, 0, 1277, 1279, 1, 0, 0, 0, 1278, 1225, 1, 0, 0, 0, 1278, 1244, 1,
		0, 0, 0, 1278, 1253, 1, 0, 0, 0, 1278, 1260, 1, 0, 0, 0, 1278, 1274, 1,
		0, 0, 0, 1279, 211, 1, 0, 0, 0, 1280, 1282, 5, 84, 0, 0, 1281, 1283, 5,
		28, 0, 0, 1282, 1281, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1290, 1,
		0, 0, 0, 1284, 1285, 5, 145, 0, 0, 1285, 1287, 5, 84, 0, 0, 1286, 1288,
		5, 28, 0, 0, 1287, 1286, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1290,
		1, 0, 0, 0, 1289, 1280, 1, 0, 0, 0, 1289, 1284, 1, 0, 0, 0, 1290, 213,
		1, 0, 0, 0, 1291, 1295, 5, 49, 0, 0, 1292, 1293, 5, 145, 0, 0, 1293, 1295,
		5, 49, 0, 0, 1294, 1291, 1, 0, 0, 0, 1294, 1292, 1, 0, 0, 0, 1295, 215,
		1, 0, 0, 0, 1296, 1300, 5, 184, 0, 0, 1297, 1298, 5, 15, 0, 0, 1298, 1300,
		3, 140, 70, 0, 1299, 1296, 1, 0, 0, 0, 1299, 1297, 1, 0, 0, 0, 1300, 217,
		1, 0, 0, 0, 1301, 1302, 5, 11, 0, 0, 1302, 1307, 3, 134, 67, 0, 1303, 1304,
		5, 2, 0, 0, 1304, 1306, 3, 134, 67, 0, 1305, 1303, 1, 0, 0, 0, 1306, 1309,
		1, 0, 0, 0, 1307, 1305, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1310,
		1, 0, 0, 0, 1309, 1307, 1, 0, 0, 0, 1310, 1311, 5, 12, 0, 0, 1311, 219,
		1, 0, 0, 0, 1312, 1315, 3, 222, 111, 0, 1313, 1315, 3, 216, 108, 0, 1314,
		1312, 1, 0, 0, 0, 1314, 1313, 1, 0, 0, 0, 1315, 221, 1, 0, 0, 0, 1316,
		1325, 5, 11, 0, 0, 1317, 1322, 3, 190, 95, 0, 1318, 1319, 5, 2, 0, 0, 1319,
		1321, 3, 190, 95, 0, 1320, 1318, 1, 0, 0, 0, 1321, 1324, 1, 0, 0, 0, 1322,
		1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 1324,
		1322, 1, 0, 0, 0, 1325, 1317, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326,
		1327, 1, 0, 0, 0, 1327, 1328, 5, 12, 0, 0, 1328, 223, 1, 0, 0, 0, 1329,
		1332, 3, 176, 88, 0, 1330, 1332, 3, 48, 24, 0, 1331, 1329, 1, 0, 0, 0,
		1331, 1330, 1, 0, 0, 0, 1332, 225, 1, 0, 0, 0, 1333, 1334, 5, 11, 0, 0,
		1334, 1339, 5, 12, 0, 0, 1335, 1339, 3, 216, 108, 0, 1336, 1339, 3, 228,
		114, 0, 1337, 1339, 3, 230, 115, 0, 1338, 1333, 1, 0, 0, 0, 1338, 1335,
		1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338, 1337, 1, 0, 0, 0, 1339, 227,
		1, 0, 0, 0, 1340, 1341, 5, 11, 0, 0, 1341, 1346, 3, 176, 88, 0, 1342, 1343,
		5, 2, 0, 0, 1343, 1345, 3, 176, 88, 0, 1344, 1342, 1, 0, 0, 0, 1345, 1348,
		1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1349,
		1, 0, 0, 0, 1348, 1346, 1, 0, 0, 0, 1349, 1350, 5, 12, 0, 0, 1350, 229,
		1, 0, 0, 0, 1351, 1352, 5, 11, 0, 0, 1352, 1357, 3, 48, 24, 0, 1353, 1354,
		5, 2, 0, 0, 1354, 1356, 3, 48, 24, 0, 1355, 1353, 1, 0, 0, 0, 1356, 1359,
		1, 0, 0, 0, 1357, 1355, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358, 1360,
		1, 0, 0, 0, 1359, 1357, 1, 0, 0, 0, 1360, 1361, 5, 12, 0, 0, 1361, 231,
		1, 0, 0, 0, 1362, 1374, 3, 234, 117, 0, 1363, 1374, 3, 236, 118, 0, 1364,
		1374, 3, 238, 119, 0, 1365, 1374, 3, 240, 120, 0, 1366, 1374, 3, 148, 74,
		0, 1367, 1368, 5, 156, 0, 0, 1368, 1369, 5, 18, 0, 0, 1369, 1370, 3, 232,
		116, 0, 1370, 1371, 5, 20, 0, 0, 1371, 1374, 1, 0, 0, 0, 1372, 1374, 5,
		180, 0, 0, 1373, 1362, 1, 0, 0, 0, 1373, 1363, 1, 0, 0, 0, 1373, 1364,
		1, 0, 0, 0, 1373, 1365, 1, 0, 0, 0, 1373, 1366, 1, 0, 0, 0, 1373, 1367,
		1, 0, 0, 0, 1373, 1372, 1, 0, 0, 0, 1374, 233, 1, 0, 0, 0, 1375, 1376,
		7, 4, 0, 0, 1376, 235, 1, 0, 0, 0, 1377, 1378, 5, 147, 0, 0, 1378, 1379,
		5, 18, 0, 0, 1379, 1380, 3, 232, 116, 0, 1380, 1381, 5, 2, 0, 0, 1381,
		1382, 3, 232, 116, 0, 1382, 1383, 5, 20, 0, 0, 1383, 1395, 1, 0, 0, 0,
		1384, 1385, 5, 148, 0, 0, 1385, 1386, 5, 18, 0, 0, 1386, 1387, 3, 232,
		116, 0, 1387, 1388, 5, 20, 0, 0, 1388, 1395, 1, 0, 0, 0, 1389, 1390, 5,
		42, 0, 0, 1390, 1391, 5, 18, 0, 0, 1391, 1392, 3, 232, 116, 0, 1392, 1393,
		5, 20, 0, 0, 1393, 1395, 1, 0, 0, 0, 1394, 1377, 1, 0, 0, 0, 1394, 1384,
		1, 0, 0, 0, 1394, 1389, 1, 0, 0, 0, 1395, 237, 1, 0, 0, 0, 1396, 1397,
		5, 153, 0, 0, 1397, 1398, 5, 18, 0, 0, 1398, 1403, 3, 232, 116, 0, 1399,
		1400, 5, 2, 0, 0, 1400, 1402, 3, 232, 116, 0, 1401, 1399, 1, 0, 0, 0, 1402,
		1405, 1, 0, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404,
		1406, 1, 0, 0, 0, 1405, 1403, 1, 0, 0, 0, 1406, 1407, 5, 20, 0, 0, 1407,
		239, 1, 0, 0, 0, 1408, 1409, 5, 178, 0, 0, 1409, 1410, 5, 18, 0, 0, 1410,
		1411, 3, 232, 116, 0, 1411, 1412, 5, 2, 0, 0, 1412, 1413, 5, 183, 0, 0,
		1413, 1414, 5, 20, 0, 0, 1414, 241, 1, 0, 0, 0, 1415, 1416, 7, 5, 0, 0,
		1416, 243, 1, 0, 0, 0, 1417, 1418, 7, 5, 0, 0, 1418, 245, 1, 0, 0, 0, 1419,
		1424, 7, 6, 0, 0, 1420, 1424, 5, 181, 0, 0, 1421, 1424, 3, 252, 126, 0,
		1422, 1424, 5, 28, 0, 0, 1423, 1419, 1, 0, 0, 0, 1423, 1420, 1, 0, 0, 0,
		1423, 1421, 1, 0, 0, 0, 1423, 1422, 1, 0, 0, 0, 1424, 247, 1, 0, 0, 0,
		1425, 1428, 3, 250, 125, 0, 1426, 1428, 7, 7, 0, 0, 1427, 1425, 1, 0, 0,
		0, 1427, 1426, 1, 0, 0, 0, 1428, 249, 1, 0, 0, 0, 1429, 1432, 3, 252, 126,
		0, 1430, 1432, 3, 234, 117, 0, 1431, 1429, 1, 0, 0, 0, 1431, 1430, 1, 0,
		0, 0, 1432, 251, 1, 0, 0, 0, 1433, 1434, 7, 8, 0, 0, 1434, 253, 1, 0, 0,
		0, 153, 259, 265, 295, 302, 309, 318, 321, 330, 333, 339, 343, 347, 352,
		359, 363, 368, 377, 379, 389, 391, 398, 404, 412, 418, 420, 424, 431, 444,
		447, 455, 461, 472, 479, 488, 496, 508, 519, 530, 545, 550, 555, 563, 566,
		573, 580, 585, 597, 600, 607, 616, 632, 636, 646, 649, 654, 657, 661, 671,
		676, 686, 696, 701, 710, 715, 729, 734, 742, 749, 753, 764, 775, 784, 794,
		803, 810, 817, 824, 832, 838, 855, 860, 863, 868, 873, 876, 881, 888, 898,
		908, 916, 919, 931, 935, 940, 945, 950, 957, 964, 971, 981, 987, 993, 1000,
		1012, 1014, 1027, 1030, 1036, 1042, 1054, 1065, 1073, 1076, 1091, 1102,
		1113, 1117, 1122, 1131, 1142, 1149, 1159, 1161, 1171, 1173, 1179, 1195,
		1202, 1213, 1217, 1242, 1251, 1272, 1278, 1282, 1287, 1289, 1294, 1299,
		1307, 1314, 1322, 1325, 1331, 1338, 1346, 1357, 1373, 1394, 1403, 1423,
		1427, 1431,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Cql3ParserInit initializes any static state used to implement Cql3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCql3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Cql3ParserInit() {
	staticData := &Cql3ParserStaticData
	staticData.once.Do(cql3ParserInit)
}

// NewCql3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewCql3Parser(input antlr.TokenStream) *Cql3Parser {
	Cql3ParserInit()
	this := new(Cql3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Cql3ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Cql3.g4"

	return this
}

// Cql3Parser tokens.
const (
	Cql3ParserEOF                 = antlr.TokenEOF
	Cql3ParserT__0                = 1
	Cql3ParserT__1                = 2
	Cql3ParserT__2                = 3
	Cql3ParserT__3                = 4
	Cql3ParserT__4                = 5
	Cql3ParserT__5                = 6
	Cql3ParserT__6                = 7
	Cql3ParserT__7                = 8
	Cql3ParserT__8                = 9
	Cql3ParserT__9                = 10
	Cql3ParserT__10               = 11
	Cql3ParserT__11               = 12
	Cql3ParserT__12               = 13
	Cql3ParserT__13               = 14
	Cql3ParserT__14               = 15
	Cql3ParserT__15               = 16
	Cql3ParserT__16               = 17
	Cql3ParserT__17               = 18
	Cql3ParserT__18               = 19
	Cql3ParserT__19               = 20
	Cql3ParserT__20               = 21
	Cql3ParserT__21               = 22
	Cql3ParserK_SELECT            = 23
	Cql3ParserK_FROM              = 24
	Cql3ParserK_AS                = 25
	Cql3ParserK_WHERE             = 26
	Cql3ParserK_AND               = 27
	Cql3ParserK_KEY               = 28
	Cql3ParserK_KEYS              = 29
	Cql3ParserK_ENTRIES           = 30
	Cql3ParserK_FULL              = 31
	Cql3ParserK_INSERT            = 32
	Cql3ParserK_UPDATE            = 33
	Cql3ParserK_WITH              = 34
	Cql3ParserK_LIMIT             = 35
	Cql3ParserK_PER               = 36
	Cql3ParserK_PARTITION         = 37
	Cql3ParserK_USING             = 38
	Cql3ParserK_USE               = 39
	Cql3ParserK_DISTINCT          = 40
	Cql3ParserK_COUNT             = 41
	Cql3ParserK_SET               = 42
	Cql3ParserK_BEGIN             = 43
	Cql3ParserK_UNLOGGED          = 44
	Cql3ParserK_BATCH             = 45
	Cql3ParserK_APPLY             = 46
	Cql3ParserK_TRUNCATE          = 47
	Cql3ParserK_DELETE            = 48
	Cql3ParserK_IN                = 49
	Cql3ParserK_CREATE            = 50
	Cql3ParserK_SCHEMA            = 51
	Cql3ParserK_KEYSPACE          = 52
	Cql3ParserK_KEYSPACES         = 53
	Cql3ParserK_COLUMNFAMILY      = 54
	Cql3ParserK_TABLES            = 55
	Cql3ParserK_MATERIALIZED      = 56
	Cql3ParserK_VIEW              = 57
	Cql3ParserK_INDEX             = 58
	Cql3ParserK_CUSTOM            = 59
	Cql3ParserK_ON                = 60
	Cql3ParserK_TO                = 61
	Cql3ParserK_DROP              = 62
	Cql3ParserK_PRIMARY           = 63
	Cql3ParserK_INTO              = 64
	Cql3ParserK_VALUES            = 65
	Cql3ParserK_TIMESTAMP         = 66
	Cql3ParserK_TTL               = 67
	Cql3ParserK_CAST              = 68
	Cql3ParserK_ALTER             = 69
	Cql3ParserK_RENAME            = 70
	Cql3ParserK_ADD               = 71
	Cql3ParserK_TYPE              = 72
	Cql3ParserK_TYPES             = 73
	Cql3ParserK_COMPACT           = 74
	Cql3ParserK_STORAGE           = 75
	Cql3ParserK_ORDER             = 76
	Cql3ParserK_BY                = 77
	Cql3ParserK_ASC               = 78
	Cql3ParserK_DESC              = 79
	Cql3ParserK_ALLOW             = 80
	Cql3ParserK_FILTERING         = 81
	Cql3ParserK_IF                = 82
	Cql3ParserK_IS                = 83
	Cql3ParserK_CONTAINS          = 84
	Cql3ParserK_BETWEEN           = 85
	Cql3ParserK_GROUP             = 86
	Cql3ParserK_CLUSTER           = 87
	Cql3ParserK_INTERNALS         = 88
	Cql3ParserK_ONLY              = 89
	Cql3ParserK_GRANT             = 90
	Cql3ParserK_ALL               = 91
	Cql3ParserK_PERMISSION        = 92
	Cql3ParserK_PERMISSIONS       = 93
	Cql3ParserK_OF                = 94
	Cql3ParserK_REVOKE            = 95
	Cql3ParserK_MODIFY            = 96
	Cql3ParserK_AUTHORIZE         = 97
	Cql3ParserK_DESCRIBE          = 98
	Cql3ParserK_EXECUTE           = 99
	Cql3ParserK_NORECURSIVE       = 100
	Cql3ParserK_MBEAN             = 101
	Cql3ParserK_MBEANS            = 102
	Cql3ParserK_USER              = 103
	Cql3ParserK_USERS             = 104
	Cql3ParserK_ROLE              = 105
	Cql3ParserK_ROLES             = 106
	Cql3ParserK_SUPERUSERS        = 107
	Cql3ParserK_SUPERUSER         = 108
	Cql3ParserK_NOSUPERUSER       = 109
	Cql3ParserK_GENERATED         = 110
	Cql3ParserK_PASSWORD          = 111
	Cql3ParserK_HASHED            = 112
	Cql3ParserK_LOGIN             = 113
	Cql3ParserK_NOLOGIN           = 114
	Cql3ParserK_OPTIONS           = 115
	Cql3ParserK_ACCESS            = 116
	Cql3ParserK_DATACENTERS       = 117
	Cql3ParserK_CIDRS             = 118
	Cql3ParserK_IDENTITY          = 119
	Cql3ParserK_CLUSTERING        = 120
	Cql3ParserK_ASCII             = 121
	Cql3ParserK_BIGINT            = 122
	Cql3ParserK_BLOB              = 123
	Cql3ParserK_BOOLEAN           = 124
	Cql3ParserK_COUNTER           = 125
	Cql3ParserK_DECIMAL           = 126
	Cql3ParserK_DOUBLE            = 127
	Cql3ParserK_DURATION          = 128
	Cql3ParserK_FLOAT             = 129
	Cql3ParserK_INET              = 130
	Cql3ParserK_INT               = 131
	Cql3ParserK_SMALLINT          = 132
	Cql3ParserK_TINYINT           = 133
	Cql3ParserK_TEXT              = 134
	Cql3ParserK_UUID              = 135
	Cql3ParserK_VARCHAR           = 136
	Cql3ParserK_VARINT            = 137
	Cql3ParserK_TIMEUUID          = 138
	Cql3ParserK_TOKEN             = 139
	Cql3ParserK_WRITETIME         = 140
	Cql3ParserK_MAXWRITETIME      = 141
	Cql3ParserK_DATE              = 142
	Cql3ParserK_TIME              = 143
	Cql3ParserK_NULL              = 144
	Cql3ParserK_NOT               = 145
	Cql3ParserK_EXISTS            = 146
	Cql3ParserK_MAP               = 147
	Cql3ParserK_LIST              = 148
	Cql3ParserK_POSITIVE_NAN      = 149
	Cql3ParserK_NEGATIVE_NAN      = 150
	Cql3ParserK_POSITIVE_INFINITY = 151
	Cql3ParserK_NEGATIVE_INFINITY = 152
	Cql3ParserK_TUPLE             = 153
	Cql3ParserK_TRIGGER           = 154
	Cql3ParserK_STATIC            = 155
	Cql3ParserK_FROZEN            = 156
	Cql3ParserK_FUNCTION          = 157
	Cql3ParserK_FUNCTIONS         = 158
	Cql3ParserK_AGGREGATE         = 159
	Cql3ParserK_AGGREGATES        = 160
	Cql3ParserK_SFUNC             = 161
	Cql3ParserK_STYPE             = 162
	Cql3ParserK_FINALFUNC         = 163
	Cql3ParserK_INITCOND          = 164
	Cql3ParserK_RETURNS           = 165
	Cql3ParserK_CALLED            = 166
	Cql3ParserK_INPUT             = 167
	Cql3ParserK_LANGUAGE          = 168
	Cql3ParserK_OR                = 169
	Cql3ParserK_REPLACE           = 170
	Cql3ParserK_JSON              = 171
	Cql3ParserK_DEFAULT           = 172
	Cql3ParserK_UNSET             = 173
	Cql3ParserK_LIKE              = 174
	Cql3ParserK_MASKED            = 175
	Cql3ParserK_UNMASK            = 176
	Cql3ParserK_SELECT_MASKED     = 177
	Cql3ParserK_VECTOR            = 178
	Cql3ParserK_ANN               = 179
	Cql3ParserSTRING_LITERAL      = 180
	Cql3ParserQUOTED_NAME         = 181
	Cql3ParserEMPTY_QUOTED_NAME   = 182
	Cql3ParserINTEGER             = 183
	Cql3ParserQMARK               = 184
	Cql3ParserRANGE               = 185
	Cql3ParserFLOAT               = 186
	Cql3ParserBOOLEAN             = 187
	Cql3ParserDURATION            = 188
	Cql3ParserIDENT               = 189
	Cql3ParserHEXNUMBER           = 190
	Cql3ParserUUID                = 191
	Cql3ParserWS                  = 192
	Cql3ParserCOMMENT             = 193
	Cql3ParserMULTILINE_COMMENT   = 194
)

// Cql3Parser rules.
const (
	Cql3ParserRULE_cqlStatements                  = 0
	Cql3ParserRULE_cqlStatement                   = 1
	Cql3ParserRULE_useStatement                   = 2
	Cql3ParserRULE_selectStatement                = 3
	Cql3ParserRULE_selectClause                   = 4
	Cql3ParserRULE_selectors                      = 5
	Cql3ParserRULE_selector                       = 6
	Cql3ParserRULE_unaliasedSelector              = 7
	Cql3ParserRULE_selectionAddition              = 8
	Cql3ParserRULE_selectionMultiplication        = 9
	Cql3ParserRULE_selectionGroup                 = 10
	Cql3ParserRULE_selectionGroupWithField        = 11
	Cql3ParserRULE_selectorModifier               = 12
	Cql3ParserRULE_collectionSubSelection         = 13
	Cql3ParserRULE_selectionGroupWithoutField     = 14
	Cql3ParserRULE_selectionTypeHint              = 15
	Cql3ParserRULE_selectionList                  = 16
	Cql3ParserRULE_selectionMapOrSet              = 17
	Cql3ParserRULE_selectionMap                   = 18
	Cql3ParserRULE_selectionSet                   = 19
	Cql3ParserRULE_selectionTupleOrNestedSelector = 20
	Cql3ParserRULE_simpleUnaliasedSelector        = 21
	Cql3ParserRULE_selectionFunction              = 22
	Cql3ParserRULE_selectionLiteral               = 23
	Cql3ParserRULE_marker                         = 24
	Cql3ParserRULE_selectionFunctionArgs          = 25
	Cql3ParserRULE_sident                         = 26
	Cql3ParserRULE_whereClause                    = 27
	Cql3ParserRULE_relationOrExpression           = 28
	Cql3ParserRULE_customIndexExpression          = 29
	Cql3ParserRULE_orderByClause                  = 30
	Cql3ParserRULE_groupByClause                  = 31
	Cql3ParserRULE_createKeyspaceStatement        = 32
	Cql3ParserRULE_createTableStatement           = 33
	Cql3ParserRULE_ifNotExists                    = 34
	Cql3ParserRULE_ifExists                       = 35
	Cql3ParserRULE_tableDefinition                = 36
	Cql3ParserRULE_tableColumns                   = 37
	Cql3ParserRULE_columnMask                     = 38
	Cql3ParserRULE_columnMaskArguments            = 39
	Cql3ParserRULE_tablePartitionKey              = 40
	Cql3ParserRULE_tableProperty                  = 41
	Cql3ParserRULE_tableClusteringOrder           = 42
	Cql3ParserRULE_createTypeStatement            = 43
	Cql3ParserRULE_typeColumns                    = 44
	Cql3ParserRULE_createTriggerStatement         = 45
	Cql3ParserRULE_dropTriggerStatement           = 46
	Cql3ParserRULE_alterKeyspaceStatement         = 47
	Cql3ParserRULE_alterMaterializedViewStatement = 48
	Cql3ParserRULE_dropKeyspaceStatement          = 49
	Cql3ParserRULE_dropTableStatement             = 50
	Cql3ParserRULE_dropTypeStatement              = 51
	Cql3ParserRULE_dropIndexStatement             = 52
	Cql3ParserRULE_dropMaterializedViewStatement  = 53
	Cql3ParserRULE_truncateStatement              = 54
	Cql3ParserRULE_grantRoleStatement             = 55
	Cql3ParserRULE_revokeRoleStatement            = 56
	Cql3ParserRULE_createUserStatement            = 57
	Cql3ParserRULE_alterUserStatement             = 58
	Cql3ParserRULE_dropUserStatement              = 59
	Cql3ParserRULE_addIdentityStatement           = 60
	Cql3ParserRULE_dropIdentityStatement          = 61
	Cql3ParserRULE_listUsersStatement             = 62
	Cql3ParserRULE_dropRoleStatement              = 63
	Cql3ParserRULE_listRolesStatement             = 64
	Cql3ParserRULE_listSuperUsersStatement        = 65
	Cql3ParserRULE_userPassword                   = 66
	Cql3ParserRULE_cident                         = 67
	Cql3ParserRULE_ident                          = 68
	Cql3ParserRULE_fident                         = 69
	Cql3ParserRULE_noncol_ident                   = 70
	Cql3ParserRULE_keyspaceName                   = 71
	Cql3ParserRULE_indexName                      = 72
	Cql3ParserRULE_columnFamilyName               = 73
	Cql3ParserRULE_userTypeName                   = 74
	Cql3ParserRULE_userOrRoleName                 = 75
	Cql3ParserRULE_ksName                         = 76
	Cql3ParserRULE_cfName                         = 77
	Cql3ParserRULE_idxName                        = 78
	Cql3ParserRULE_roleName                       = 79
	Cql3ParserRULE_constant                       = 80
	Cql3ParserRULE_fullMapLiteral                 = 81
	Cql3ParserRULE_setOrMapLiteral                = 82
	Cql3ParserRULE_setLiteral                     = 83
	Cql3ParserRULE_mapLiteral                     = 84
	Cql3ParserRULE_collectionLiteral              = 85
	Cql3ParserRULE_listLiteral                    = 86
	Cql3ParserRULE_usertypeLiteral                = 87
	Cql3ParserRULE_tupleLiteral                   = 88
	Cql3ParserRULE_value                          = 89
	Cql3ParserRULE_intValue                       = 90
	Cql3ParserRULE_functionName                   = 91
	Cql3ParserRULE_allowedFunctionName            = 92
	Cql3ParserRULE_function                       = 93
	Cql3ParserRULE_functionArgs                   = 94
	Cql3ParserRULE_term                           = 95
	Cql3ParserRULE_termAddition                   = 96
	Cql3ParserRULE_termMultiplication             = 97
	Cql3ParserRULE_termGroup                      = 98
	Cql3ParserRULE_simpleTerm                     = 99
	Cql3ParserRULE_properties                     = 100
	Cql3ParserRULE_property                       = 101
	Cql3ParserRULE_propertyValue                  = 102
	Cql3ParserRULE_singleColumnBetweenValues      = 103
	Cql3ParserRULE_relationType                   = 104
	Cql3ParserRULE_relation                       = 105
	Cql3ParserRULE_containsOperator               = 106
	Cql3ParserRULE_inOperator                     = 107
	Cql3ParserRULE_inMarker                       = 108
	Cql3ParserRULE_tupleOfIdentifiers             = 109
	Cql3ParserRULE_singleColumnInValues           = 110
	Cql3ParserRULE_terms                          = 111
	Cql3ParserRULE_multiColumnValue               = 112
	Cql3ParserRULE_multiColumnInValues            = 113
	Cql3ParserRULE_tupleOfTupleLiterals           = 114
	Cql3ParserRULE_tupleOfMarkersForTuples        = 115
	Cql3ParserRULE_comparatorType                 = 116
	Cql3ParserRULE_native_type                    = 117
	Cql3ParserRULE_collection_type                = 118
	Cql3ParserRULE_tuple_type                     = 119
	Cql3ParserRULE_vector_type                    = 120
	Cql3ParserRULE_username                       = 121
	Cql3ParserRULE_identity                       = 122
	Cql3ParserRULE_non_type_ident                 = 123
	Cql3ParserRULE_unreserved_keyword             = 124
	Cql3ParserRULE_unreserved_function_keyword    = 125
	Cql3ParserRULE_basic_unreserved_keyword       = 126
)

// ICqlStatementsContext is an interface to support dynamic dispatch.
type ICqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSt returns the st rule contexts.
	GetSt() ICqlStatementContext

	// SetSt sets the st rule contexts.
	SetSt(ICqlStatementContext)

	// Getter signatures
	EOF() antlr.TerminalNode
	AllCqlStatement() []ICqlStatementContext
	CqlStatement(i int) ICqlStatementContext

	// IsCqlStatementsContext differentiates from other interfaces.
	IsCqlStatementsContext()
}

type CqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	st     ICqlStatementContext
}

func NewEmptyCqlStatementsContext() *CqlStatementsContext {
	var p = new(CqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cqlStatements
	return p
}

func InitEmptyCqlStatementsContext(p *CqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cqlStatements
}

func (*CqlStatementsContext) IsCqlStatementsContext() {}

func NewCqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlStatementsContext {
	var p = new(CqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_cqlStatements

	return p
}

func (s *CqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlStatementsContext) GetSt() ICqlStatementContext { return s.st }

func (s *CqlStatementsContext) SetSt(v ICqlStatementContext) { s.st = v }

func (s *CqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(Cql3ParserEOF, 0)
}

func (s *CqlStatementsContext) AllCqlStatement() []ICqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ICqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICqlStatementContext); ok {
			tst[i] = t.(ICqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CqlStatementsContext) CqlStatement(i int) ICqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICqlStatementContext)
}

func (s *CqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CqlStatements() (localctx ICqlStatementsContext) {
	localctx = NewCqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Cql3ParserRULE_cqlStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)

		var _x = p.CqlStatement()

		localctx.(*CqlStatementsContext).st = _x
	}
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(255)
				p.Match(Cql3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(256)

				var _x = p.CqlStatement()

				localctx.(*CqlStatementsContext).st = _x
			}

		}
		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__0 {
		{
			p.SetState(262)
			p.Match(Cql3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(268)
		p.Match(Cql3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICqlStatementContext is an interface to support dynamic dispatch.
type ICqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSt1 returns the st1 rule contexts.
	GetSt1() ISelectStatementContext

	// GetSt6 returns the st6 rule contexts.
	GetSt6() IUseStatementContext

	// GetSt7 returns the st7 rule contexts.
	GetSt7() ITruncateStatementContext

	// GetSt8 returns the st8 rule contexts.
	GetSt8() ICreateKeyspaceStatementContext

	// GetSt9 returns the st9 rule contexts.
	GetSt9() ICreateTableStatementContext

	// GetSt11 returns the st11 rule contexts.
	GetSt11() IDropKeyspaceStatementContext

	// GetSt12 returns the st12 rule contexts.
	GetSt12() IDropTableStatementContext

	// GetSt13 returns the st13 rule contexts.
	GetSt13() IDropIndexStatementContext

	// GetSt15 returns the st15 rule contexts.
	GetSt15() IAlterKeyspaceStatementContext

	// GetSt19 returns the st19 rule contexts.
	GetSt19() ICreateUserStatementContext

	// GetSt20 returns the st20 rule contexts.
	GetSt20() IAlterUserStatementContext

	// GetSt21 returns the st21 rule contexts.
	GetSt21() IDropUserStatementContext

	// GetSt22 returns the st22 rule contexts.
	GetSt22() IListUsersStatementContext

	// GetSt24 returns the st24 rule contexts.
	GetSt24() IDropTriggerStatementContext

	// GetSt25 returns the st25 rule contexts.
	GetSt25() ICreateTypeStatementContext

	// GetSt27 returns the st27 rule contexts.
	GetSt27() IDropTypeStatementContext

	// GetSt34 returns the st34 rule contexts.
	GetSt34() IDropRoleStatementContext

	// GetSt35 returns the st35 rule contexts.
	GetSt35() IListRolesStatementContext

	// GetSt36 returns the st36 rule contexts.
	GetSt36() IGrantRoleStatementContext

	// GetSt37 returns the st37 rule contexts.
	GetSt37() IRevokeRoleStatementContext

	// GetSt39 returns the st39 rule contexts.
	GetSt39() IDropMaterializedViewStatementContext

	// GetSt40 returns the st40 rule contexts.
	GetSt40() IAlterMaterializedViewStatementContext

	// GetSt42 returns the st42 rule contexts.
	GetSt42() IAddIdentityStatementContext

	// GetSt43 returns the st43 rule contexts.
	GetSt43() IDropIdentityStatementContext

	// GetSt44 returns the st44 rule contexts.
	GetSt44() IListSuperUsersStatementContext

	// SetSt1 sets the st1 rule contexts.
	SetSt1(ISelectStatementContext)

	// SetSt6 sets the st6 rule contexts.
	SetSt6(IUseStatementContext)

	// SetSt7 sets the st7 rule contexts.
	SetSt7(ITruncateStatementContext)

	// SetSt8 sets the st8 rule contexts.
	SetSt8(ICreateKeyspaceStatementContext)

	// SetSt9 sets the st9 rule contexts.
	SetSt9(ICreateTableStatementContext)

	// SetSt11 sets the st11 rule contexts.
	SetSt11(IDropKeyspaceStatementContext)

	// SetSt12 sets the st12 rule contexts.
	SetSt12(IDropTableStatementContext)

	// SetSt13 sets the st13 rule contexts.
	SetSt13(IDropIndexStatementContext)

	// SetSt15 sets the st15 rule contexts.
	SetSt15(IAlterKeyspaceStatementContext)

	// SetSt19 sets the st19 rule contexts.
	SetSt19(ICreateUserStatementContext)

	// SetSt20 sets the st20 rule contexts.
	SetSt20(IAlterUserStatementContext)

	// SetSt21 sets the st21 rule contexts.
	SetSt21(IDropUserStatementContext)

	// SetSt22 sets the st22 rule contexts.
	SetSt22(IListUsersStatementContext)

	// SetSt24 sets the st24 rule contexts.
	SetSt24(IDropTriggerStatementContext)

	// SetSt25 sets the st25 rule contexts.
	SetSt25(ICreateTypeStatementContext)

	// SetSt27 sets the st27 rule contexts.
	SetSt27(IDropTypeStatementContext)

	// SetSt34 sets the st34 rule contexts.
	SetSt34(IDropRoleStatementContext)

	// SetSt35 sets the st35 rule contexts.
	SetSt35(IListRolesStatementContext)

	// SetSt36 sets the st36 rule contexts.
	SetSt36(IGrantRoleStatementContext)

	// SetSt37 sets the st37 rule contexts.
	SetSt37(IRevokeRoleStatementContext)

	// SetSt39 sets the st39 rule contexts.
	SetSt39(IDropMaterializedViewStatementContext)

	// SetSt40 sets the st40 rule contexts.
	SetSt40(IAlterMaterializedViewStatementContext)

	// SetSt42 sets the st42 rule contexts.
	SetSt42(IAddIdentityStatementContext)

	// SetSt43 sets the st43 rule contexts.
	SetSt43(IDropIdentityStatementContext)

	// SetSt44 sets the st44 rule contexts.
	SetSt44(IListSuperUsersStatementContext)

	// Getter signatures
	SelectStatement() ISelectStatementContext
	UseStatement() IUseStatementContext
	TruncateStatement() ITruncateStatementContext
	CreateKeyspaceStatement() ICreateKeyspaceStatementContext
	CreateTableStatement() ICreateTableStatementContext
	DropKeyspaceStatement() IDropKeyspaceStatementContext
	DropTableStatement() IDropTableStatementContext
	DropIndexStatement() IDropIndexStatementContext
	AlterKeyspaceStatement() IAlterKeyspaceStatementContext
	CreateUserStatement() ICreateUserStatementContext
	AlterUserStatement() IAlterUserStatementContext
	DropUserStatement() IDropUserStatementContext
	ListUsersStatement() IListUsersStatementContext
	DropTriggerStatement() IDropTriggerStatementContext
	CreateTypeStatement() ICreateTypeStatementContext
	DropTypeStatement() IDropTypeStatementContext
	DropRoleStatement() IDropRoleStatementContext
	ListRolesStatement() IListRolesStatementContext
	GrantRoleStatement() IGrantRoleStatementContext
	RevokeRoleStatement() IRevokeRoleStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext
	AddIdentityStatement() IAddIdentityStatementContext
	DropIdentityStatement() IDropIdentityStatementContext
	ListSuperUsersStatement() IListSuperUsersStatementContext

	// IsCqlStatementContext differentiates from other interfaces.
	IsCqlStatementContext()
}

type CqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	st1    ISelectStatementContext
	st6    IUseStatementContext
	st7    ITruncateStatementContext
	st8    ICreateKeyspaceStatementContext
	st9    ICreateTableStatementContext
	st11   IDropKeyspaceStatementContext
	st12   IDropTableStatementContext
	st13   IDropIndexStatementContext
	st15   IAlterKeyspaceStatementContext
	st19   ICreateUserStatementContext
	st20   IAlterUserStatementContext
	st21   IDropUserStatementContext
	st22   IListUsersStatementContext
	st24   IDropTriggerStatementContext
	st25   ICreateTypeStatementContext
	st27   IDropTypeStatementContext
	st34   IDropRoleStatementContext
	st35   IListRolesStatementContext
	st36   IGrantRoleStatementContext
	st37   IRevokeRoleStatementContext
	st39   IDropMaterializedViewStatementContext
	st40   IAlterMaterializedViewStatementContext
	st42   IAddIdentityStatementContext
	st43   IDropIdentityStatementContext
	st44   IListSuperUsersStatementContext
}

func NewEmptyCqlStatementContext() *CqlStatementContext {
	var p = new(CqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cqlStatement
	return p
}

func InitEmptyCqlStatementContext(p *CqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cqlStatement
}

func (*CqlStatementContext) IsCqlStatementContext() {}

func NewCqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlStatementContext {
	var p = new(CqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_cqlStatement

	return p
}

func (s *CqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlStatementContext) GetSt1() ISelectStatementContext { return s.st1 }

func (s *CqlStatementContext) GetSt6() IUseStatementContext { return s.st6 }

func (s *CqlStatementContext) GetSt7() ITruncateStatementContext { return s.st7 }

func (s *CqlStatementContext) GetSt8() ICreateKeyspaceStatementContext { return s.st8 }

func (s *CqlStatementContext) GetSt9() ICreateTableStatementContext { return s.st9 }

func (s *CqlStatementContext) GetSt11() IDropKeyspaceStatementContext { return s.st11 }

func (s *CqlStatementContext) GetSt12() IDropTableStatementContext { return s.st12 }

func (s *CqlStatementContext) GetSt13() IDropIndexStatementContext { return s.st13 }

func (s *CqlStatementContext) GetSt15() IAlterKeyspaceStatementContext { return s.st15 }

func (s *CqlStatementContext) GetSt19() ICreateUserStatementContext { return s.st19 }

func (s *CqlStatementContext) GetSt20() IAlterUserStatementContext { return s.st20 }

func (s *CqlStatementContext) GetSt21() IDropUserStatementContext { return s.st21 }

func (s *CqlStatementContext) GetSt22() IListUsersStatementContext { return s.st22 }

func (s *CqlStatementContext) GetSt24() IDropTriggerStatementContext { return s.st24 }

func (s *CqlStatementContext) GetSt25() ICreateTypeStatementContext { return s.st25 }

func (s *CqlStatementContext) GetSt27() IDropTypeStatementContext { return s.st27 }

func (s *CqlStatementContext) GetSt34() IDropRoleStatementContext { return s.st34 }

func (s *CqlStatementContext) GetSt35() IListRolesStatementContext { return s.st35 }

func (s *CqlStatementContext) GetSt36() IGrantRoleStatementContext { return s.st36 }

func (s *CqlStatementContext) GetSt37() IRevokeRoleStatementContext { return s.st37 }

func (s *CqlStatementContext) GetSt39() IDropMaterializedViewStatementContext { return s.st39 }

func (s *CqlStatementContext) GetSt40() IAlterMaterializedViewStatementContext { return s.st40 }

func (s *CqlStatementContext) GetSt42() IAddIdentityStatementContext { return s.st42 }

func (s *CqlStatementContext) GetSt43() IDropIdentityStatementContext { return s.st43 }

func (s *CqlStatementContext) GetSt44() IListSuperUsersStatementContext { return s.st44 }

func (s *CqlStatementContext) SetSt1(v ISelectStatementContext) { s.st1 = v }

func (s *CqlStatementContext) SetSt6(v IUseStatementContext) { s.st6 = v }

func (s *CqlStatementContext) SetSt7(v ITruncateStatementContext) { s.st7 = v }

func (s *CqlStatementContext) SetSt8(v ICreateKeyspaceStatementContext) { s.st8 = v }

func (s *CqlStatementContext) SetSt9(v ICreateTableStatementContext) { s.st9 = v }

func (s *CqlStatementContext) SetSt11(v IDropKeyspaceStatementContext) { s.st11 = v }

func (s *CqlStatementContext) SetSt12(v IDropTableStatementContext) { s.st12 = v }

func (s *CqlStatementContext) SetSt13(v IDropIndexStatementContext) { s.st13 = v }

func (s *CqlStatementContext) SetSt15(v IAlterKeyspaceStatementContext) { s.st15 = v }

func (s *CqlStatementContext) SetSt19(v ICreateUserStatementContext) { s.st19 = v }

func (s *CqlStatementContext) SetSt20(v IAlterUserStatementContext) { s.st20 = v }

func (s *CqlStatementContext) SetSt21(v IDropUserStatementContext) { s.st21 = v }

func (s *CqlStatementContext) SetSt22(v IListUsersStatementContext) { s.st22 = v }

func (s *CqlStatementContext) SetSt24(v IDropTriggerStatementContext) { s.st24 = v }

func (s *CqlStatementContext) SetSt25(v ICreateTypeStatementContext) { s.st25 = v }

func (s *CqlStatementContext) SetSt27(v IDropTypeStatementContext) { s.st27 = v }

func (s *CqlStatementContext) SetSt34(v IDropRoleStatementContext) { s.st34 = v }

func (s *CqlStatementContext) SetSt35(v IListRolesStatementContext) { s.st35 = v }

func (s *CqlStatementContext) SetSt36(v IGrantRoleStatementContext) { s.st36 = v }

func (s *CqlStatementContext) SetSt37(v IRevokeRoleStatementContext) { s.st37 = v }

func (s *CqlStatementContext) SetSt39(v IDropMaterializedViewStatementContext) { s.st39 = v }

func (s *CqlStatementContext) SetSt40(v IAlterMaterializedViewStatementContext) { s.st40 = v }

func (s *CqlStatementContext) SetSt42(v IAddIdentityStatementContext) { s.st42 = v }

func (s *CqlStatementContext) SetSt43(v IDropIdentityStatementContext) { s.st43 = v }

func (s *CqlStatementContext) SetSt44(v IListSuperUsersStatementContext) { s.st44 = v }

func (s *CqlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CqlStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *CqlStatementContext) TruncateStatement() ITruncateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateStatementContext)
}

func (s *CqlStatementContext) CreateKeyspaceStatement() ICreateKeyspaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateKeyspaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateKeyspaceStatementContext)
}

func (s *CqlStatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *CqlStatementContext) DropKeyspaceStatement() IDropKeyspaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropKeyspaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropKeyspaceStatementContext)
}

func (s *CqlStatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *CqlStatementContext) DropIndexStatement() IDropIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexStatementContext)
}

func (s *CqlStatementContext) AlterKeyspaceStatement() IAlterKeyspaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterKeyspaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterKeyspaceStatementContext)
}

func (s *CqlStatementContext) CreateUserStatement() ICreateUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserStatementContext)
}

func (s *CqlStatementContext) AlterUserStatement() IAlterUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserStatementContext)
}

func (s *CqlStatementContext) DropUserStatement() IDropUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserStatementContext)
}

func (s *CqlStatementContext) ListUsersStatement() IListUsersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListUsersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListUsersStatementContext)
}

func (s *CqlStatementContext) DropTriggerStatement() IDropTriggerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerStatementContext)
}

func (s *CqlStatementContext) CreateTypeStatement() ICreateTypeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTypeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTypeStatementContext)
}

func (s *CqlStatementContext) DropTypeStatement() IDropTypeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTypeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTypeStatementContext)
}

func (s *CqlStatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *CqlStatementContext) ListRolesStatement() IListRolesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListRolesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListRolesStatementContext)
}

func (s *CqlStatementContext) GrantRoleStatement() IGrantRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleStatementContext)
}

func (s *CqlStatementContext) RevokeRoleStatement() IRevokeRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleStatementContext)
}

func (s *CqlStatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *CqlStatementContext) AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementContext)
}

func (s *CqlStatementContext) AddIdentityStatement() IAddIdentityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddIdentityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddIdentityStatementContext)
}

func (s *CqlStatementContext) DropIdentityStatement() IDropIdentityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIdentityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIdentityStatementContext)
}

func (s *CqlStatementContext) ListSuperUsersStatement() IListSuperUsersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListSuperUsersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListSuperUsersStatementContext)
}

func (s *CqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CqlStatement() (localctx ICqlStatementContext) {
	localctx = NewCqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Cql3ParserRULE_cqlStatement)
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(270)

			var _x = p.SelectStatement()

			localctx.(*CqlStatementContext).st1 = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(271)

			var _x = p.UseStatement()

			localctx.(*CqlStatementContext).st6 = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(272)

			var _x = p.TruncateStatement()

			localctx.(*CqlStatementContext).st7 = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(273)

			var _x = p.CreateKeyspaceStatement()

			localctx.(*CqlStatementContext).st8 = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(274)

			var _x = p.CreateTableStatement()

			localctx.(*CqlStatementContext).st9 = _x
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(275)

			var _x = p.DropKeyspaceStatement()

			localctx.(*CqlStatementContext).st11 = _x
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(276)

			var _x = p.DropTableStatement()

			localctx.(*CqlStatementContext).st12 = _x
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(277)

			var _x = p.DropIndexStatement()

			localctx.(*CqlStatementContext).st13 = _x
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(278)

			var _x = p.AlterKeyspaceStatement()

			localctx.(*CqlStatementContext).st15 = _x
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(279)

			var _x = p.CreateUserStatement()

			localctx.(*CqlStatementContext).st19 = _x
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(280)

			var _x = p.AlterUserStatement()

			localctx.(*CqlStatementContext).st20 = _x
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(281)

			var _x = p.DropUserStatement()

			localctx.(*CqlStatementContext).st21 = _x
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(282)

			var _x = p.ListUsersStatement()

			localctx.(*CqlStatementContext).st22 = _x
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(283)

			var _x = p.DropTriggerStatement()

			localctx.(*CqlStatementContext).st24 = _x
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(284)

			var _x = p.CreateTypeStatement()

			localctx.(*CqlStatementContext).st25 = _x
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(285)

			var _x = p.DropTypeStatement()

			localctx.(*CqlStatementContext).st27 = _x
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(286)

			var _x = p.DropRoleStatement()

			localctx.(*CqlStatementContext).st34 = _x
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(287)

			var _x = p.ListRolesStatement()

			localctx.(*CqlStatementContext).st35 = _x
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(288)

			var _x = p.GrantRoleStatement()

			localctx.(*CqlStatementContext).st36 = _x
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(289)

			var _x = p.RevokeRoleStatement()

			localctx.(*CqlStatementContext).st37 = _x
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(290)

			var _x = p.DropMaterializedViewStatement()

			localctx.(*CqlStatementContext).st39 = _x
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(291)

			var _x = p.AlterMaterializedViewStatement()

			localctx.(*CqlStatementContext).st40 = _x
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(292)

			var _x = p.AddIdentityStatement()

			localctx.(*CqlStatementContext).st42 = _x
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(293)

			var _x = p.DropIdentityStatement()

			localctx.(*CqlStatementContext).st43 = _x
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(294)

			var _x = p.ListSuperUsersStatement()

			localctx.(*CqlStatementContext).st44 = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() IKeyspaceNameContext

	// SetKs sets the ks rule contexts.
	SetKs(IKeyspaceNameContext)

	// Getter signatures
	K_USE() antlr.TerminalNode
	KeyspaceName() IKeyspaceNameContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     IKeyspaceNameContext
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_useStatement
	return p
}

func InitEmptyUseStatementContext(p *UseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_useStatement
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) GetKs() IKeyspaceNameContext { return s.ks }

func (s *UseStatementContext) SetKs(v IKeyspaceNameContext) { s.ks = v }

func (s *UseStatementContext) K_USE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USE, 0)
}

func (s *UseStatementContext) KeyspaceName() IKeyspaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceNameContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Cql3ParserRULE_useStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(Cql3ParserK_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)

		var _x = p.KeyspaceName()

		localctx.(*UseStatementContext).ks = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSclause returns the sclause rule contexts.
	GetSclause() ISelectClauseContext

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// GetWclause returns the wclause rule contexts.
	GetWclause() IWhereClauseContext

	// GetRows returns the rows rule contexts.
	GetRows() IIntValueContext

	// SetSclause sets the sclause rule contexts.
	SetSclause(ISelectClauseContext)

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// SetWclause sets the wclause rule contexts.
	SetWclause(IWhereClauseContext)

	// SetRows sets the rows rule contexts.
	SetRows(IIntValueContext)

	// Getter signatures
	K_SELECT() antlr.TerminalNode
	K_FROM() antlr.TerminalNode
	SelectClause() ISelectClauseContext
	ColumnFamilyName() IColumnFamilyNameContext
	K_JSON() antlr.TerminalNode
	K_WHERE() antlr.TerminalNode
	K_GROUP() antlr.TerminalNode
	AllK_BY() []antlr.TerminalNode
	K_BY(i int) antlr.TerminalNode
	AllGroupByClause() []IGroupByClauseContext
	GroupByClause(i int) IGroupByClauseContext
	K_ORDER() antlr.TerminalNode
	AllOrderByClause() []IOrderByClauseContext
	OrderByClause(i int) IOrderByClauseContext
	K_PER() antlr.TerminalNode
	K_PARTITION() antlr.TerminalNode
	AllK_LIMIT() []antlr.TerminalNode
	K_LIMIT(i int) antlr.TerminalNode
	K_ALLOW() antlr.TerminalNode
	K_FILTERING() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	AllIntValue() []IIntValueContext
	IntValue(i int) IIntValueContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	sclause ISelectClauseContext
	cf      IColumnFamilyNameContext
	wclause IWhereClauseContext
	rows    IIntValueContext
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) GetSclause() ISelectClauseContext { return s.sclause }

func (s *SelectStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *SelectStatementContext) GetWclause() IWhereClauseContext { return s.wclause }

func (s *SelectStatementContext) GetRows() IIntValueContext { return s.rows }

func (s *SelectStatementContext) SetSclause(v ISelectClauseContext) { s.sclause = v }

func (s *SelectStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *SelectStatementContext) SetWclause(v IWhereClauseContext) { s.wclause = v }

func (s *SelectStatementContext) SetRows(v IIntValueContext) { s.rows = v }

func (s *SelectStatementContext) K_SELECT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SELECT, 0)
}

func (s *SelectStatementContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FROM, 0)
}

func (s *SelectStatementContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *SelectStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *SelectStatementContext) K_JSON() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_JSON, 0)
}

func (s *SelectStatementContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WHERE, 0)
}

func (s *SelectStatementContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_GROUP, 0)
}

func (s *SelectStatementContext) AllK_BY() []antlr.TerminalNode {
	return s.GetTokens(Cql3ParserK_BY)
}

func (s *SelectStatementContext) K_BY(i int) antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BY, i)
}

func (s *SelectStatementContext) AllGroupByClause() []IGroupByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			len++
		}
	}

	tst := make([]IGroupByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByClauseContext); ok {
			tst[i] = t.(IGroupByClauseContext)
			i++
		}
	}

	return tst
}

func (s *SelectStatementContext) GroupByClause(i int) IGroupByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStatementContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ORDER, 0)
}

func (s *SelectStatementContext) AllOrderByClause() []IOrderByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			len++
		}
	}

	tst := make([]IOrderByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByClauseContext); ok {
			tst[i] = t.(IOrderByClauseContext)
			i++
		}
	}

	return tst
}

func (s *SelectStatementContext) OrderByClause(i int) IOrderByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStatementContext) K_PER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PER, 0)
}

func (s *SelectStatementContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PARTITION, 0)
}

func (s *SelectStatementContext) AllK_LIMIT() []antlr.TerminalNode {
	return s.GetTokens(Cql3ParserK_LIMIT)
}

func (s *SelectStatementContext) K_LIMIT(i int) antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIMIT, i)
}

func (s *SelectStatementContext) K_ALLOW() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ALLOW, 0)
}

func (s *SelectStatementContext) K_FILTERING() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FILTERING, 0)
}

func (s *SelectStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStatementContext) AllIntValue() []IIntValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntValueContext); ok {
			len++
		}
	}

	tst := make([]IIntValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntValueContext); ok {
			tst[i] = t.(IIntValueContext)
			i++
		}
	}

	return tst
}

func (s *SelectStatementContext) IntValue(i int) IIntValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntValueContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Cql3ParserRULE_selectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(Cql3ParserK_SELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(301)
			p.Match(Cql3ParserK_JSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(304)

		var _x = p.SelectClause()

		localctx.(*SelectStatementContext).sclause = _x
	}
	{
		p.SetState(305)
		p.Match(Cql3ParserK_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(306)

		var _x = p.ColumnFamilyName()

		localctx.(*SelectStatementContext).cf = _x
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_WHERE {
		{
			p.SetState(307)
			p.Match(Cql3ParserK_WHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)

			var _x = p.WhereClause()

			localctx.(*SelectStatementContext).wclause = _x
		}

	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_GROUP {
		{
			p.SetState(311)
			p.Match(Cql3ParserK_GROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(312)
			p.Match(Cql3ParserK_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(313)
			p.GroupByClause()
		}
		p.SetState(318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(314)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(315)
				p.GroupByClause()
			}

			p.SetState(320)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_ORDER {
		{
			p.SetState(323)
			p.Match(Cql3ParserK_ORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(324)
			p.Match(Cql3ParserK_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			p.OrderByClause()
		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(326)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(327)
				p.OrderByClause()
			}

			p.SetState(332)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_PER {
		{
			p.SetState(335)
			p.Match(Cql3ParserK_PER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.Match(Cql3ParserK_PARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(337)
			p.Match(Cql3ParserK_LIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(338)

			var _x = p.IntValue()

			localctx.(*SelectStatementContext).rows = _x
		}

	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_LIMIT {
		{
			p.SetState(341)
			p.Match(Cql3ParserK_LIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)

			var _x = p.IntValue()

			localctx.(*SelectStatementContext).rows = _x
		}

	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_ALLOW {
		{
			p.SetState(345)
			p.Match(Cql3ParserK_ALLOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(346)
			p.Match(Cql3ParserK_FILTERING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s rule contexts.
	GetS() ISelectorsContext

	// SetS sets the s rule contexts.
	SetS(ISelectorsContext)

	// Getter signatures
	K_DISTINCT() antlr.TerminalNode
	Selectors() ISelectorsContext

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s      ISelectorsContext
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) GetS() ISelectorsContext { return s.s }

func (s *SelectClauseContext) SetS(v ISelectorsContext) { s.s = v }

func (s *SelectClauseContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DISTINCT, 0)
}

func (s *SelectClauseContext) Selectors() ISelectorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectorsContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Cql3ParserRULE_selectClause)
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(349)
			p.Match(Cql3ParserK_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(350)

			var _x = p.Selectors()

			localctx.(*SelectClauseContext).s = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)

			var _x = p.Selectors()

			localctx.(*SelectClauseContext).s = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectorsContext is an interface to support dynamic dispatch.
type ISelectorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ISelectorContext

	// GetTN returns the tN rule contexts.
	GetTN() ISelectorContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ISelectorContext)

	// SetTN sets the tN rule contexts.
	SetTN(ISelectorContext)

	// Getter signatures
	AllSelector() []ISelectorContext
	Selector(i int) ISelectorContext

	// IsSelectorsContext differentiates from other interfaces.
	IsSelectorsContext()
}

type SelectorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ISelectorContext
	tN     ISelectorContext
}

func NewEmptySelectorsContext() *SelectorsContext {
	var p = new(SelectorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectors
	return p
}

func InitEmptySelectorsContext(p *SelectorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectors
}

func (*SelectorsContext) IsSelectorsContext() {}

func NewSelectorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorsContext {
	var p = new(SelectorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectors

	return p
}

func (s *SelectorsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorsContext) GetT1() ISelectorContext { return s.t1 }

func (s *SelectorsContext) GetTN() ISelectorContext { return s.tN }

func (s *SelectorsContext) SetT1(v ISelectorContext) { s.t1 = v }

func (s *SelectorsContext) SetTN(v ISelectorContext) { s.tN = v }

func (s *SelectorsContext) AllSelector() []ISelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectorContext); ok {
			len++
		}
	}

	tst := make([]ISelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectorContext); ok {
			tst[i] = t.(ISelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectorsContext) Selector(i int) ISelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *SelectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectors(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Selectors() (localctx ISelectorsContext) {
	localctx = NewSelectorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Cql3ParserRULE_selectors)
	var _la int

	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__4, Cql3ParserT__8, Cql3ParserT__10, Cql3ParserT__12, Cql3ParserT__14, Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_TOKEN, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_NULL, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN, Cql3ParserK_POSITIVE_INFINITY, Cql3ParserK_NEGATIVE_INFINITY, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserSTRING_LITERAL, Cql3ParserQUOTED_NAME, Cql3ParserINTEGER, Cql3ParserQMARK, Cql3ParserFLOAT, Cql3ParserBOOLEAN, Cql3ParserDURATION, Cql3ParserIDENT, Cql3ParserHEXNUMBER, Cql3ParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(354)

			var _x = p.Selector()

			localctx.(*SelectorsContext).t1 = _x
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(355)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(356)

				var _x = p.Selector()

				localctx.(*SelectorsContext).tN = _x
			}

			p.SetState(361)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case Cql3ParserT__2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(362)
			p.Match(Cql3ParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUs returns the us rule contexts.
	GetUs() IUnaliasedSelectorContext

	// GetC returns the c rule contexts.
	GetC() INoncol_identContext

	// SetUs sets the us rule contexts.
	SetUs(IUnaliasedSelectorContext)

	// SetC sets the c rule contexts.
	SetC(INoncol_identContext)

	// Getter signatures
	UnaliasedSelector() IUnaliasedSelectorContext
	K_AS() antlr.TerminalNode
	Noncol_ident() INoncol_identContext

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	us     IUnaliasedSelectorContext
	c      INoncol_identContext
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selector
	return p
}

func InitEmptySelectorContext(p *SelectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selector
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) GetUs() IUnaliasedSelectorContext { return s.us }

func (s *SelectorContext) GetC() INoncol_identContext { return s.c }

func (s *SelectorContext) SetUs(v IUnaliasedSelectorContext) { s.us = v }

func (s *SelectorContext) SetC(v INoncol_identContext) { s.c = v }

func (s *SelectorContext) UnaliasedSelector() IUnaliasedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectorContext) K_AS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AS, 0)
}

func (s *SelectorContext) Noncol_ident() INoncol_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoncol_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoncol_identContext)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Selector() (localctx ISelectorContext) {
	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Cql3ParserRULE_selector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)

		var _x = p.UnaliasedSelector()

		localctx.(*SelectorContext).us = _x
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_AS {
		{
			p.SetState(366)
			p.Match(Cql3ParserK_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(367)

			var _x = p.Noncol_ident()

			localctx.(*SelectorContext).c = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaliasedSelectorContext is an interface to support dynamic dispatch.
type IUnaliasedSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetA returns the a rule contexts.
	GetA() ISelectionAdditionContext

	// SetA sets the a rule contexts.
	SetA(ISelectionAdditionContext)

	// Getter signatures
	SelectionAddition() ISelectionAdditionContext

	// IsUnaliasedSelectorContext differentiates from other interfaces.
	IsUnaliasedSelectorContext()
}

type UnaliasedSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	a      ISelectionAdditionContext
}

func NewEmptyUnaliasedSelectorContext() *UnaliasedSelectorContext {
	var p = new(UnaliasedSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unaliasedSelector
	return p
}

func InitEmptyUnaliasedSelectorContext(p *UnaliasedSelectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unaliasedSelector
}

func (*UnaliasedSelectorContext) IsUnaliasedSelectorContext() {}

func NewUnaliasedSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaliasedSelectorContext {
	var p = new(UnaliasedSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_unaliasedSelector

	return p
}

func (s *UnaliasedSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaliasedSelectorContext) GetA() ISelectionAdditionContext { return s.a }

func (s *UnaliasedSelectorContext) SetA(v ISelectionAdditionContext) { s.a = v }

func (s *UnaliasedSelectorContext) SelectionAddition() ISelectionAdditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionAdditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionAdditionContext)
}

func (s *UnaliasedSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaliasedSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaliasedSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUnaliasedSelector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UnaliasedSelector() (localctx IUnaliasedSelectorContext) {
	localctx = NewUnaliasedSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Cql3ParserRULE_unaliasedSelector)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)

		var _x = p.SelectionAddition()

		localctx.(*UnaliasedSelectorContext).a = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionAdditionContext is an interface to support dynamic dispatch.
type ISelectionAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ISelectionMultiplicationContext

	// GetR returns the r rule contexts.
	GetR() ISelectionMultiplicationContext

	// SetL sets the l rule contexts.
	SetL(ISelectionMultiplicationContext)

	// SetR sets the r rule contexts.
	SetR(ISelectionMultiplicationContext)

	// Getter signatures
	AllSelectionMultiplication() []ISelectionMultiplicationContext
	SelectionMultiplication(i int) ISelectionMultiplicationContext

	// IsSelectionAdditionContext differentiates from other interfaces.
	IsSelectionAdditionContext()
}

type SelectionAdditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      ISelectionMultiplicationContext
	r      ISelectionMultiplicationContext
}

func NewEmptySelectionAdditionContext() *SelectionAdditionContext {
	var p = new(SelectionAdditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionAddition
	return p
}

func InitEmptySelectionAdditionContext(p *SelectionAdditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionAddition
}

func (*SelectionAdditionContext) IsSelectionAdditionContext() {}

func NewSelectionAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionAdditionContext {
	var p = new(SelectionAdditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionAddition

	return p
}

func (s *SelectionAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionAdditionContext) GetL() ISelectionMultiplicationContext { return s.l }

func (s *SelectionAdditionContext) GetR() ISelectionMultiplicationContext { return s.r }

func (s *SelectionAdditionContext) SetL(v ISelectionMultiplicationContext) { s.l = v }

func (s *SelectionAdditionContext) SetR(v ISelectionMultiplicationContext) { s.r = v }

func (s *SelectionAdditionContext) AllSelectionMultiplication() []ISelectionMultiplicationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectionMultiplicationContext); ok {
			len++
		}
	}

	tst := make([]ISelectionMultiplicationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectionMultiplicationContext); ok {
			tst[i] = t.(ISelectionMultiplicationContext)
			i++
		}
	}

	return tst
}

func (s *SelectionAdditionContext) SelectionMultiplication(i int) ISelectionMultiplicationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionMultiplicationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionMultiplicationContext)
}

func (s *SelectionAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionAdditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionAddition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionAddition() (localctx ISelectionAdditionContext) {
	localctx = NewSelectionAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Cql3ParserRULE_selectionAddition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)

		var _x = p.SelectionMultiplication()

		localctx.(*SelectionAdditionContext).l = _x
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__3 || _la == Cql3ParserT__4 {
		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__3:
			{
				p.SetState(373)
				p.Match(Cql3ParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(374)

				var _x = p.SelectionMultiplication()

				localctx.(*SelectionAdditionContext).r = _x
			}

		case Cql3ParserT__4:
			{
				p.SetState(375)
				p.Match(Cql3ParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(376)

				var _x = p.SelectionMultiplication()

				localctx.(*SelectionAdditionContext).r = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionMultiplicationContext is an interface to support dynamic dispatch.
type ISelectionMultiplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ISelectionGroupContext

	// GetR returns the r rule contexts.
	GetR() ISelectionGroupContext

	// SetL sets the l rule contexts.
	SetL(ISelectionGroupContext)

	// SetR sets the r rule contexts.
	SetR(ISelectionGroupContext)

	// Getter signatures
	AllSelectionGroup() []ISelectionGroupContext
	SelectionGroup(i int) ISelectionGroupContext

	// IsSelectionMultiplicationContext differentiates from other interfaces.
	IsSelectionMultiplicationContext()
}

type SelectionMultiplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      ISelectionGroupContext
	r      ISelectionGroupContext
}

func NewEmptySelectionMultiplicationContext() *SelectionMultiplicationContext {
	var p = new(SelectionMultiplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMultiplication
	return p
}

func InitEmptySelectionMultiplicationContext(p *SelectionMultiplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMultiplication
}

func (*SelectionMultiplicationContext) IsSelectionMultiplicationContext() {}

func NewSelectionMultiplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionMultiplicationContext {
	var p = new(SelectionMultiplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionMultiplication

	return p
}

func (s *SelectionMultiplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionMultiplicationContext) GetL() ISelectionGroupContext { return s.l }

func (s *SelectionMultiplicationContext) GetR() ISelectionGroupContext { return s.r }

func (s *SelectionMultiplicationContext) SetL(v ISelectionGroupContext) { s.l = v }

func (s *SelectionMultiplicationContext) SetR(v ISelectionGroupContext) { s.r = v }

func (s *SelectionMultiplicationContext) AllSelectionGroup() []ISelectionGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectionGroupContext); ok {
			len++
		}
	}

	tst := make([]ISelectionGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectionGroupContext); ok {
			tst[i] = t.(ISelectionGroupContext)
			i++
		}
	}

	return tst
}

func (s *SelectionMultiplicationContext) SelectionGroup(i int) ISelectionGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupContext)
}

func (s *SelectionMultiplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionMultiplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionMultiplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionMultiplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionMultiplication() (localctx ISelectionMultiplicationContext) {
	localctx = NewSelectionMultiplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Cql3ParserRULE_selectionMultiplication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)

		var _x = p.SelectionGroup()

		localctx.(*SelectionMultiplicationContext).l = _x
	}
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&200) != 0 {
		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__2:
			{
				p.SetState(383)
				p.Match(Cql3ParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(384)

				var _x = p.SelectionGroup()

				localctx.(*SelectionMultiplicationContext).r = _x
			}

		case Cql3ParserT__5:
			{
				p.SetState(385)
				p.Match(Cql3ParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(386)

				var _x = p.SelectionGroup()

				localctx.(*SelectionMultiplicationContext).r = _x
			}

		case Cql3ParserT__6:
			{
				p.SetState(387)
				p.Match(Cql3ParserT__6)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(388)

				var _x = p.SelectionGroup()

				localctx.(*SelectionMultiplicationContext).r = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionGroupContext is an interface to support dynamic dispatch.
type ISelectionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetF returns the f rule contexts.
	GetF() ISelectionGroupWithFieldContext

	// GetG returns the g rule contexts.
	GetG() ISelectionGroupWithoutFieldContext

	// GetH returns the h rule contexts.
	GetH() ISelectionGroupContext

	// SetF sets the f rule contexts.
	SetF(ISelectionGroupWithFieldContext)

	// SetG sets the g rule contexts.
	SetG(ISelectionGroupWithoutFieldContext)

	// SetH sets the h rule contexts.
	SetH(ISelectionGroupContext)

	// Getter signatures
	SelectionGroupWithField() ISelectionGroupWithFieldContext
	SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext
	SelectionGroup() ISelectionGroupContext

	// IsSelectionGroupContext differentiates from other interfaces.
	IsSelectionGroupContext()
}

type SelectionGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	f      ISelectionGroupWithFieldContext
	g      ISelectionGroupWithoutFieldContext
	h      ISelectionGroupContext
}

func NewEmptySelectionGroupContext() *SelectionGroupContext {
	var p = new(SelectionGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroup
	return p
}

func InitEmptySelectionGroupContext(p *SelectionGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroup
}

func (*SelectionGroupContext) IsSelectionGroupContext() {}

func NewSelectionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionGroupContext {
	var p = new(SelectionGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionGroup

	return p
}

func (s *SelectionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionGroupContext) GetF() ISelectionGroupWithFieldContext { return s.f }

func (s *SelectionGroupContext) GetG() ISelectionGroupWithoutFieldContext { return s.g }

func (s *SelectionGroupContext) GetH() ISelectionGroupContext { return s.h }

func (s *SelectionGroupContext) SetF(v ISelectionGroupWithFieldContext) { s.f = v }

func (s *SelectionGroupContext) SetG(v ISelectionGroupWithoutFieldContext) { s.g = v }

func (s *SelectionGroupContext) SetH(v ISelectionGroupContext) { s.h = v }

func (s *SelectionGroupContext) SelectionGroupWithField() ISelectionGroupWithFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupWithFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupWithFieldContext)
}

func (s *SelectionGroupContext) SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupWithoutFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupWithoutFieldContext)
}

func (s *SelectionGroupContext) SelectionGroup() ISelectionGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupContext)
}

func (s *SelectionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionGroup() (localctx ISelectionGroupContext) {
	localctx = NewSelectionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Cql3ParserRULE_selectionGroup)
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)

			var _x = p.SelectionGroupWithField()

			localctx.(*SelectionGroupContext).f = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(395)

			var _x = p.SelectionGroupWithoutField()

			localctx.(*SelectionGroupContext).g = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(396)
			p.Match(Cql3ParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(397)

			var _x = p.SelectionGroup()

			localctx.(*SelectionGroupContext).h = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionGroupWithFieldContext is an interface to support dynamic dispatch.
type ISelectionGroupWithFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetG returns the g rule contexts.
	GetG() ISelectionGroupWithoutFieldContext

	// GetM returns the m rule contexts.
	GetM() ISelectorModifierContext

	// SetG sets the g rule contexts.
	SetG(ISelectionGroupWithoutFieldContext)

	// SetM sets the m rule contexts.
	SetM(ISelectorModifierContext)

	// Getter signatures
	SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext
	AllSelectorModifier() []ISelectorModifierContext
	SelectorModifier(i int) ISelectorModifierContext

	// IsSelectionGroupWithFieldContext differentiates from other interfaces.
	IsSelectionGroupWithFieldContext()
}

type SelectionGroupWithFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	g      ISelectionGroupWithoutFieldContext
	m      ISelectorModifierContext
}

func NewEmptySelectionGroupWithFieldContext() *SelectionGroupWithFieldContext {
	var p = new(SelectionGroupWithFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithField
	return p
}

func InitEmptySelectionGroupWithFieldContext(p *SelectionGroupWithFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithField
}

func (*SelectionGroupWithFieldContext) IsSelectionGroupWithFieldContext() {}

func NewSelectionGroupWithFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionGroupWithFieldContext {
	var p = new(SelectionGroupWithFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithField

	return p
}

func (s *SelectionGroupWithFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionGroupWithFieldContext) GetG() ISelectionGroupWithoutFieldContext { return s.g }

func (s *SelectionGroupWithFieldContext) GetM() ISelectorModifierContext { return s.m }

func (s *SelectionGroupWithFieldContext) SetG(v ISelectionGroupWithoutFieldContext) { s.g = v }

func (s *SelectionGroupWithFieldContext) SetM(v ISelectorModifierContext) { s.m = v }

func (s *SelectionGroupWithFieldContext) SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupWithoutFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupWithoutFieldContext)
}

func (s *SelectionGroupWithFieldContext) AllSelectorModifier() []ISelectorModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectorModifierContext); ok {
			len++
		}
	}

	tst := make([]ISelectorModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectorModifierContext); ok {
			tst[i] = t.(ISelectorModifierContext)
			i++
		}
	}

	return tst
}

func (s *SelectionGroupWithFieldContext) SelectorModifier(i int) ISelectorModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectorModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectorModifierContext)
}

func (s *SelectionGroupWithFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionGroupWithFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionGroupWithFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionGroupWithField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionGroupWithField() (localctx ISelectionGroupWithFieldContext) {
	localctx = NewSelectionGroupWithFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Cql3ParserRULE_selectionGroupWithField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)

		var _x = p.SelectionGroupWithoutField()

		localctx.(*SelectionGroupWithFieldContext).g = _x
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cql3ParserT__7 || _la == Cql3ParserT__8 {
		{
			p.SetState(401)

			var _x = p.SelectorModifier()

			localctx.(*SelectionGroupWithFieldContext).m = _x
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectorModifierContext is an interface to support dynamic dispatch.
type ISelectorModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFi returns the fi rule contexts.
	GetFi() IFidentContext

	// GetSs returns the ss rule contexts.
	GetSs() ICollectionSubSelectionContext

	// SetFi sets the fi rule contexts.
	SetFi(IFidentContext)

	// SetSs sets the ss rule contexts.
	SetSs(ICollectionSubSelectionContext)

	// Getter signatures
	Fident() IFidentContext
	CollectionSubSelection() ICollectionSubSelectionContext

	// IsSelectorModifierContext differentiates from other interfaces.
	IsSelectorModifierContext()
}

type SelectorModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fi     IFidentContext
	ss     ICollectionSubSelectionContext
}

func NewEmptySelectorModifierContext() *SelectorModifierContext {
	var p = new(SelectorModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectorModifier
	return p
}

func InitEmptySelectorModifierContext(p *SelectorModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectorModifier
}

func (*SelectorModifierContext) IsSelectorModifierContext() {}

func NewSelectorModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorModifierContext {
	var p = new(SelectorModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectorModifier

	return p
}

func (s *SelectorModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorModifierContext) GetFi() IFidentContext { return s.fi }

func (s *SelectorModifierContext) GetSs() ICollectionSubSelectionContext { return s.ss }

func (s *SelectorModifierContext) SetFi(v IFidentContext) { s.fi = v }

func (s *SelectorModifierContext) SetSs(v ICollectionSubSelectionContext) { s.ss = v }

func (s *SelectorModifierContext) Fident() IFidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFidentContext)
}

func (s *SelectorModifierContext) CollectionSubSelection() ICollectionSubSelectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionSubSelectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionSubSelectionContext)
}

func (s *SelectorModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectorModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectorModifier() (localctx ISelectorModifierContext) {
	localctx = NewSelectorModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Cql3ParserRULE_selectorModifier)
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__7:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(406)
			p.Match(Cql3ParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(407)

			var _x = p.Fident()

			localctx.(*SelectorModifierContext).fi = _x
		}

	case Cql3ParserT__8:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(408)
			p.Match(Cql3ParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)

			var _x = p.CollectionSubSelection()

			localctx.(*SelectorModifierContext).ss = _x
		}
		{
			p.SetState(410)
			p.Match(Cql3ParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionSubSelectionContext is an interface to support dynamic dispatch.
type ICollectionSubSelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetT2 returns the t2 rule contexts.
	GetT2() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetT2 sets the t2 rule contexts.
	SetT2(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext
	RANGE() antlr.TerminalNode

	// IsCollectionSubSelectionContext differentiates from other interfaces.
	IsCollectionSubSelectionContext()
}

type CollectionSubSelectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	t2     ITermContext
}

func NewEmptyCollectionSubSelectionContext() *CollectionSubSelectionContext {
	var p = new(CollectionSubSelectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collectionSubSelection
	return p
}

func InitEmptyCollectionSubSelectionContext(p *CollectionSubSelectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collectionSubSelection
}

func (*CollectionSubSelectionContext) IsCollectionSubSelectionContext() {}

func NewCollectionSubSelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionSubSelectionContext {
	var p = new(CollectionSubSelectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_collectionSubSelection

	return p
}

func (s *CollectionSubSelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionSubSelectionContext) GetT1() ITermContext { return s.t1 }

func (s *CollectionSubSelectionContext) GetT2() ITermContext { return s.t2 }

func (s *CollectionSubSelectionContext) SetT1(v ITermContext) { s.t1 = v }

func (s *CollectionSubSelectionContext) SetT2(v ITermContext) { s.t2 = v }

func (s *CollectionSubSelectionContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *CollectionSubSelectionContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *CollectionSubSelectionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserRANGE, 0)
}

func (s *CollectionSubSelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionSubSelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionSubSelectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCollectionSubSelection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CollectionSubSelection() (localctx ICollectionSubSelectionContext) {
	localctx = NewCollectionSubSelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Cql3ParserRULE_collectionSubSelection)
	var _la int

	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)

			var _x = p.Term()

			localctx.(*CollectionSubSelectionContext).t1 = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)

			var _x = p.Term()

			localctx.(*CollectionSubSelectionContext).t1 = _x
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cql3ParserRANGE {
			{
				p.SetState(416)
				p.Match(Cql3ParserRANGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(418)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
				{
					p.SetState(417)

					var _x = p.Term()

					localctx.(*CollectionSubSelectionContext).t2 = _x
				}

			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(422)
			p.Match(Cql3ParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)

			var _x = p.Term()

			localctx.(*CollectionSubSelectionContext).t2 = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionGroupWithoutFieldContext is an interface to support dynamic dispatch.
type ISelectionGroupWithoutFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSn returns the sn rule contexts.
	GetSn() ISimpleUnaliasedSelectorContext

	// GetH returns the h rule contexts.
	GetH() ISelectionTypeHintContext

	// GetT returns the t rule contexts.
	GetT() ISelectionTupleOrNestedSelectorContext

	// GetL returns the l rule contexts.
	GetL() ISelectionListContext

	// GetM returns the m rule contexts.
	GetM() ISelectionMapOrSetContext

	// SetSn sets the sn rule contexts.
	SetSn(ISimpleUnaliasedSelectorContext)

	// SetH sets the h rule contexts.
	SetH(ISelectionTypeHintContext)

	// SetT sets the t rule contexts.
	SetT(ISelectionTupleOrNestedSelectorContext)

	// SetL sets the l rule contexts.
	SetL(ISelectionListContext)

	// SetM sets the m rule contexts.
	SetM(ISelectionMapOrSetContext)

	// Getter signatures
	SimpleUnaliasedSelector() ISimpleUnaliasedSelectorContext
	SelectionTypeHint() ISelectionTypeHintContext
	SelectionTupleOrNestedSelector() ISelectionTupleOrNestedSelectorContext
	SelectionList() ISelectionListContext
	SelectionMapOrSet() ISelectionMapOrSetContext

	// IsSelectionGroupWithoutFieldContext differentiates from other interfaces.
	IsSelectionGroupWithoutFieldContext()
}

type SelectionGroupWithoutFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	sn     ISimpleUnaliasedSelectorContext
	h      ISelectionTypeHintContext
	t      ISelectionTupleOrNestedSelectorContext
	l      ISelectionListContext
	m      ISelectionMapOrSetContext
}

func NewEmptySelectionGroupWithoutFieldContext() *SelectionGroupWithoutFieldContext {
	var p = new(SelectionGroupWithoutFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithoutField
	return p
}

func InitEmptySelectionGroupWithoutFieldContext(p *SelectionGroupWithoutFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithoutField
}

func (*SelectionGroupWithoutFieldContext) IsSelectionGroupWithoutFieldContext() {}

func NewSelectionGroupWithoutFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionGroupWithoutFieldContext {
	var p = new(SelectionGroupWithoutFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionGroupWithoutField

	return p
}

func (s *SelectionGroupWithoutFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionGroupWithoutFieldContext) GetSn() ISimpleUnaliasedSelectorContext { return s.sn }

func (s *SelectionGroupWithoutFieldContext) GetH() ISelectionTypeHintContext { return s.h }

func (s *SelectionGroupWithoutFieldContext) GetT() ISelectionTupleOrNestedSelectorContext { return s.t }

func (s *SelectionGroupWithoutFieldContext) GetL() ISelectionListContext { return s.l }

func (s *SelectionGroupWithoutFieldContext) GetM() ISelectionMapOrSetContext { return s.m }

func (s *SelectionGroupWithoutFieldContext) SetSn(v ISimpleUnaliasedSelectorContext) { s.sn = v }

func (s *SelectionGroupWithoutFieldContext) SetH(v ISelectionTypeHintContext) { s.h = v }

func (s *SelectionGroupWithoutFieldContext) SetT(v ISelectionTupleOrNestedSelectorContext) { s.t = v }

func (s *SelectionGroupWithoutFieldContext) SetL(v ISelectionListContext) { s.l = v }

func (s *SelectionGroupWithoutFieldContext) SetM(v ISelectionMapOrSetContext) { s.m = v }

func (s *SelectionGroupWithoutFieldContext) SimpleUnaliasedSelector() ISimpleUnaliasedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleUnaliasedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleUnaliasedSelectorContext)
}

func (s *SelectionGroupWithoutFieldContext) SelectionTypeHint() ISelectionTypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionTypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionTypeHintContext)
}

func (s *SelectionGroupWithoutFieldContext) SelectionTupleOrNestedSelector() ISelectionTupleOrNestedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionTupleOrNestedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionTupleOrNestedSelectorContext)
}

func (s *SelectionGroupWithoutFieldContext) SelectionList() ISelectionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionListContext)
}

func (s *SelectionGroupWithoutFieldContext) SelectionMapOrSet() ISelectionMapOrSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionMapOrSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionMapOrSetContext)
}

func (s *SelectionGroupWithoutFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionGroupWithoutFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionGroupWithoutFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionGroupWithoutField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionGroupWithoutField() (localctx ISelectionGroupWithoutFieldContext) {
	localctx = NewSelectionGroupWithoutFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Cql3ParserRULE_selectionGroupWithoutField)
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(426)

			var _x = p.SimpleUnaliasedSelector()

			localctx.(*SelectionGroupWithoutFieldContext).sn = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(427)

			var _x = p.SelectionTypeHint()

			localctx.(*SelectionGroupWithoutFieldContext).h = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(428)

			var _x = p.SelectionTupleOrNestedSelector()

			localctx.(*SelectionGroupWithoutFieldContext).t = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(429)

			var _x = p.SelectionList()

			localctx.(*SelectionGroupWithoutFieldContext).l = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(430)

			var _x = p.SelectionMapOrSet()

			localctx.(*SelectionGroupWithoutFieldContext).m = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionTypeHintContext is an interface to support dynamic dispatch.
type ISelectionTypeHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCt returns the ct rule contexts.
	GetCt() IComparatorTypeContext

	// GetA returns the a rule contexts.
	GetA() ISelectionGroupWithoutFieldContext

	// SetCt sets the ct rule contexts.
	SetCt(IComparatorTypeContext)

	// SetA sets the a rule contexts.
	SetA(ISelectionGroupWithoutFieldContext)

	// Getter signatures
	ComparatorType() IComparatorTypeContext
	SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext

	// IsSelectionTypeHintContext differentiates from other interfaces.
	IsSelectionTypeHintContext()
}

type SelectionTypeHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ct     IComparatorTypeContext
	a      ISelectionGroupWithoutFieldContext
}

func NewEmptySelectionTypeHintContext() *SelectionTypeHintContext {
	var p = new(SelectionTypeHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionTypeHint
	return p
}

func InitEmptySelectionTypeHintContext(p *SelectionTypeHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionTypeHint
}

func (*SelectionTypeHintContext) IsSelectionTypeHintContext() {}

func NewSelectionTypeHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionTypeHintContext {
	var p = new(SelectionTypeHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionTypeHint

	return p
}

func (s *SelectionTypeHintContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionTypeHintContext) GetCt() IComparatorTypeContext { return s.ct }

func (s *SelectionTypeHintContext) GetA() ISelectionGroupWithoutFieldContext { return s.a }

func (s *SelectionTypeHintContext) SetCt(v IComparatorTypeContext) { s.ct = v }

func (s *SelectionTypeHintContext) SetA(v ISelectionGroupWithoutFieldContext) { s.a = v }

func (s *SelectionTypeHintContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *SelectionTypeHintContext) SelectionGroupWithoutField() ISelectionGroupWithoutFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionGroupWithoutFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionGroupWithoutFieldContext)
}

func (s *SelectionTypeHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionTypeHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionTypeHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionTypeHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionTypeHint() (localctx ISelectionTypeHintContext) {
	localctx = NewSelectionTypeHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Cql3ParserRULE_selectionTypeHint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(434)

		var _x = p.ComparatorType()

		localctx.(*SelectionTypeHintContext).ct = _x
	}
	{
		p.SetState(435)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(436)

		var _x = p.SelectionGroupWithoutField()

		localctx.(*SelectionTypeHintContext).a = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionListContext is an interface to support dynamic dispatch.
type ISelectionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() IUnaliasedSelectorContext

	// GetTn returns the tn rule contexts.
	GetTn() IUnaliasedSelectorContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IUnaliasedSelectorContext)

	// SetTn sets the tn rule contexts.
	SetTn(IUnaliasedSelectorContext)

	// Getter signatures
	AllUnaliasedSelector() []IUnaliasedSelectorContext
	UnaliasedSelector(i int) IUnaliasedSelectorContext

	// IsSelectionListContext differentiates from other interfaces.
	IsSelectionListContext()
}

type SelectionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IUnaliasedSelectorContext
	tn     IUnaliasedSelectorContext
}

func NewEmptySelectionListContext() *SelectionListContext {
	var p = new(SelectionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionList
	return p
}

func InitEmptySelectionListContext(p *SelectionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionList
}

func (*SelectionListContext) IsSelectionListContext() {}

func NewSelectionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionListContext {
	var p = new(SelectionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionList

	return p
}

func (s *SelectionListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionListContext) GetT1() IUnaliasedSelectorContext { return s.t1 }

func (s *SelectionListContext) GetTn() IUnaliasedSelectorContext { return s.tn }

func (s *SelectionListContext) SetT1(v IUnaliasedSelectorContext) { s.t1 = v }

func (s *SelectionListContext) SetTn(v IUnaliasedSelectorContext) { s.tn = v }

func (s *SelectionListContext) AllUnaliasedSelector() []IUnaliasedSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			len++
		}
	}

	tst := make([]IUnaliasedSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaliasedSelectorContext); ok {
			tst[i] = t.(IUnaliasedSelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectionListContext) UnaliasedSelector(i int) IUnaliasedSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionList() (localctx ISelectionListContext) {
	localctx = NewSelectionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Cql3ParserRULE_selectionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Match(Cql3ParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
		{
			p.SetState(439)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionListContext).t1 = _x
		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(440)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(441)

				var _x = p.UnaliasedSelector()

				localctx.(*SelectionListContext).tn = _x
			}

			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(449)
		p.Match(Cql3ParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionMapOrSetContext is an interface to support dynamic dispatch.
type ISelectionMapOrSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() IUnaliasedSelectorContext

	// GetM returns the m rule contexts.
	GetM() ISelectionMapContext

	// GetSt returns the st rule contexts.
	GetSt() ISelectionSetContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IUnaliasedSelectorContext)

	// SetM sets the m rule contexts.
	SetM(ISelectionMapContext)

	// SetSt sets the st rule contexts.
	SetSt(ISelectionSetContext)

	// Getter signatures
	UnaliasedSelector() IUnaliasedSelectorContext
	SelectionMap() ISelectionMapContext
	SelectionSet() ISelectionSetContext

	// IsSelectionMapOrSetContext differentiates from other interfaces.
	IsSelectionMapOrSetContext()
}

type SelectionMapOrSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IUnaliasedSelectorContext
	m      ISelectionMapContext
	st     ISelectionSetContext
}

func NewEmptySelectionMapOrSetContext() *SelectionMapOrSetContext {
	var p = new(SelectionMapOrSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMapOrSet
	return p
}

func InitEmptySelectionMapOrSetContext(p *SelectionMapOrSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMapOrSet
}

func (*SelectionMapOrSetContext) IsSelectionMapOrSetContext() {}

func NewSelectionMapOrSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionMapOrSetContext {
	var p = new(SelectionMapOrSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionMapOrSet

	return p
}

func (s *SelectionMapOrSetContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionMapOrSetContext) GetT1() IUnaliasedSelectorContext { return s.t1 }

func (s *SelectionMapOrSetContext) GetM() ISelectionMapContext { return s.m }

func (s *SelectionMapOrSetContext) GetSt() ISelectionSetContext { return s.st }

func (s *SelectionMapOrSetContext) SetT1(v IUnaliasedSelectorContext) { s.t1 = v }

func (s *SelectionMapOrSetContext) SetM(v ISelectionMapContext) { s.m = v }

func (s *SelectionMapOrSetContext) SetSt(v ISelectionSetContext) { s.st = v }

func (s *SelectionMapOrSetContext) UnaliasedSelector() IUnaliasedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionMapOrSetContext) SelectionMap() ISelectionMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionMapContext)
}

func (s *SelectionMapOrSetContext) SelectionSet() ISelectionSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionSetContext)
}

func (s *SelectionMapOrSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionMapOrSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionMapOrSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionMapOrSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionMapOrSet() (localctx ISelectionMapOrSetContext) {
	localctx = NewSelectionMapOrSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Cql3ParserRULE_selectionMapOrSet)
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(451)
			p.Match(Cql3ParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(452)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionMapOrSetContext).t1 = _x
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__14:
			{
				p.SetState(453)

				var _x = p.SelectionMap()

				localctx.(*SelectionMapOrSetContext).m = _x
			}

		case Cql3ParserT__1, Cql3ParserT__13:
			{
				p.SetState(454)

				var _x = p.SelectionSet()

				localctx.(*SelectionMapOrSetContext).st = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(457)
			p.Match(Cql3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Match(Cql3ParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(460)
			p.Match(Cql3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionMapContext is an interface to support dynamic dispatch.
type ISelectionMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetV1 returns the v1 rule contexts.
	GetV1() IUnaliasedSelectorContext

	// GetKn returns the kn rule contexts.
	GetKn() IUnaliasedSelectorContext

	// GetVn returns the vn rule contexts.
	GetVn() IUnaliasedSelectorContext

	// SetV1 sets the v1 rule contexts.
	SetV1(IUnaliasedSelectorContext)

	// SetKn sets the kn rule contexts.
	SetKn(IUnaliasedSelectorContext)

	// SetVn sets the vn rule contexts.
	SetVn(IUnaliasedSelectorContext)

	// Getter signatures
	AllUnaliasedSelector() []IUnaliasedSelectorContext
	UnaliasedSelector(i int) IUnaliasedSelectorContext

	// IsSelectionMapContext differentiates from other interfaces.
	IsSelectionMapContext()
}

type SelectionMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	v1     IUnaliasedSelectorContext
	kn     IUnaliasedSelectorContext
	vn     IUnaliasedSelectorContext
}

func NewEmptySelectionMapContext() *SelectionMapContext {
	var p = new(SelectionMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMap
	return p
}

func InitEmptySelectionMapContext(p *SelectionMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionMap
}

func (*SelectionMapContext) IsSelectionMapContext() {}

func NewSelectionMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionMapContext {
	var p = new(SelectionMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionMap

	return p
}

func (s *SelectionMapContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionMapContext) GetV1() IUnaliasedSelectorContext { return s.v1 }

func (s *SelectionMapContext) GetKn() IUnaliasedSelectorContext { return s.kn }

func (s *SelectionMapContext) GetVn() IUnaliasedSelectorContext { return s.vn }

func (s *SelectionMapContext) SetV1(v IUnaliasedSelectorContext) { s.v1 = v }

func (s *SelectionMapContext) SetKn(v IUnaliasedSelectorContext) { s.kn = v }

func (s *SelectionMapContext) SetVn(v IUnaliasedSelectorContext) { s.vn = v }

func (s *SelectionMapContext) AllUnaliasedSelector() []IUnaliasedSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			len++
		}
	}

	tst := make([]IUnaliasedSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaliasedSelectorContext); ok {
			tst[i] = t.(IUnaliasedSelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectionMapContext) UnaliasedSelector(i int) IUnaliasedSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionMap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionMap() (localctx ISelectionMapContext) {
	localctx = NewSelectionMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Cql3ParserRULE_selectionMap)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.Match(Cql3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(464)

		var _x = p.UnaliasedSelector()

		localctx.(*SelectionMapContext).v1 = _x
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(465)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionMapContext).kn = _x
		}
		{
			p.SetState(467)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(468)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionMapContext).vn = _x
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionSetContext is an interface to support dynamic dispatch.
type ISelectionSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTn returns the tn rule contexts.
	GetTn() IUnaliasedSelectorContext

	// SetTn sets the tn rule contexts.
	SetTn(IUnaliasedSelectorContext)

	// Getter signatures
	AllUnaliasedSelector() []IUnaliasedSelectorContext
	UnaliasedSelector(i int) IUnaliasedSelectorContext

	// IsSelectionSetContext differentiates from other interfaces.
	IsSelectionSetContext()
}

type SelectionSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tn     IUnaliasedSelectorContext
}

func NewEmptySelectionSetContext() *SelectionSetContext {
	var p = new(SelectionSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionSet
	return p
}

func InitEmptySelectionSetContext(p *SelectionSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionSet
}

func (*SelectionSetContext) IsSelectionSetContext() {}

func NewSelectionSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionSetContext {
	var p = new(SelectionSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionSet

	return p
}

func (s *SelectionSetContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionSetContext) GetTn() IUnaliasedSelectorContext { return s.tn }

func (s *SelectionSetContext) SetTn(v IUnaliasedSelectorContext) { s.tn = v }

func (s *SelectionSetContext) AllUnaliasedSelector() []IUnaliasedSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			len++
		}
	}

	tst := make([]IUnaliasedSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaliasedSelectorContext); ok {
			tst[i] = t.(IUnaliasedSelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectionSetContext) UnaliasedSelector(i int) IUnaliasedSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionSet() (localctx ISelectionSetContext) {
	localctx = NewSelectionSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Cql3ParserRULE_selectionSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(475)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionSetContext).tn = _x
		}

		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionTupleOrNestedSelectorContext is an interface to support dynamic dispatch.
type ISelectionTupleOrNestedSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() IUnaliasedSelectorContext

	// GetTn returns the tn rule contexts.
	GetTn() IUnaliasedSelectorContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IUnaliasedSelectorContext)

	// SetTn sets the tn rule contexts.
	SetTn(IUnaliasedSelectorContext)

	// Getter signatures
	AllUnaliasedSelector() []IUnaliasedSelectorContext
	UnaliasedSelector(i int) IUnaliasedSelectorContext

	// IsSelectionTupleOrNestedSelectorContext differentiates from other interfaces.
	IsSelectionTupleOrNestedSelectorContext()
}

type SelectionTupleOrNestedSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IUnaliasedSelectorContext
	tn     IUnaliasedSelectorContext
}

func NewEmptySelectionTupleOrNestedSelectorContext() *SelectionTupleOrNestedSelectorContext {
	var p = new(SelectionTupleOrNestedSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionTupleOrNestedSelector
	return p
}

func InitEmptySelectionTupleOrNestedSelectorContext(p *SelectionTupleOrNestedSelectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionTupleOrNestedSelector
}

func (*SelectionTupleOrNestedSelectorContext) IsSelectionTupleOrNestedSelectorContext() {}

func NewSelectionTupleOrNestedSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionTupleOrNestedSelectorContext {
	var p = new(SelectionTupleOrNestedSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionTupleOrNestedSelector

	return p
}

func (s *SelectionTupleOrNestedSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionTupleOrNestedSelectorContext) GetT1() IUnaliasedSelectorContext { return s.t1 }

func (s *SelectionTupleOrNestedSelectorContext) GetTn() IUnaliasedSelectorContext { return s.tn }

func (s *SelectionTupleOrNestedSelectorContext) SetT1(v IUnaliasedSelectorContext) { s.t1 = v }

func (s *SelectionTupleOrNestedSelectorContext) SetTn(v IUnaliasedSelectorContext) { s.tn = v }

func (s *SelectionTupleOrNestedSelectorContext) AllUnaliasedSelector() []IUnaliasedSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			len++
		}
	}

	tst := make([]IUnaliasedSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaliasedSelectorContext); ok {
			tst[i] = t.(IUnaliasedSelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectionTupleOrNestedSelectorContext) UnaliasedSelector(i int) IUnaliasedSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionTupleOrNestedSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionTupleOrNestedSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionTupleOrNestedSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionTupleOrNestedSelector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionTupleOrNestedSelector() (localctx ISelectionTupleOrNestedSelectorContext) {
	localctx = NewSelectionTupleOrNestedSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Cql3ParserRULE_selectionTupleOrNestedSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)

		var _x = p.UnaliasedSelector()

		localctx.(*SelectionTupleOrNestedSelectorContext).t1 = _x
	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(484)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionTupleOrNestedSelectorContext).tn = _x
		}

		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(491)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleUnaliasedSelectorContext is an interface to support dynamic dispatch.
type ISimpleUnaliasedSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() ISidentContext

	// GetL returns the l rule contexts.
	GetL() ISelectionLiteralContext

	// GetF returns the f rule contexts.
	GetF() ISelectionFunctionContext

	// SetC sets the c rule contexts.
	SetC(ISidentContext)

	// SetL sets the l rule contexts.
	SetL(ISelectionLiteralContext)

	// SetF sets the f rule contexts.
	SetF(ISelectionFunctionContext)

	// Getter signatures
	Sident() ISidentContext
	SelectionLiteral() ISelectionLiteralContext
	SelectionFunction() ISelectionFunctionContext

	// IsSimpleUnaliasedSelectorContext differentiates from other interfaces.
	IsSimpleUnaliasedSelectorContext()
}

type SimpleUnaliasedSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      ISidentContext
	l      ISelectionLiteralContext
	f      ISelectionFunctionContext
}

func NewEmptySimpleUnaliasedSelectorContext() *SimpleUnaliasedSelectorContext {
	var p = new(SimpleUnaliasedSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_simpleUnaliasedSelector
	return p
}

func InitEmptySimpleUnaliasedSelectorContext(p *SimpleUnaliasedSelectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_simpleUnaliasedSelector
}

func (*SimpleUnaliasedSelectorContext) IsSimpleUnaliasedSelectorContext() {}

func NewSimpleUnaliasedSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUnaliasedSelectorContext {
	var p = new(SimpleUnaliasedSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_simpleUnaliasedSelector

	return p
}

func (s *SimpleUnaliasedSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUnaliasedSelectorContext) GetC() ISidentContext { return s.c }

func (s *SimpleUnaliasedSelectorContext) GetL() ISelectionLiteralContext { return s.l }

func (s *SimpleUnaliasedSelectorContext) GetF() ISelectionFunctionContext { return s.f }

func (s *SimpleUnaliasedSelectorContext) SetC(v ISidentContext) { s.c = v }

func (s *SimpleUnaliasedSelectorContext) SetL(v ISelectionLiteralContext) { s.l = v }

func (s *SimpleUnaliasedSelectorContext) SetF(v ISelectionFunctionContext) { s.f = v }

func (s *SimpleUnaliasedSelectorContext) Sident() ISidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISidentContext)
}

func (s *SimpleUnaliasedSelectorContext) SelectionLiteral() ISelectionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionLiteralContext)
}

func (s *SimpleUnaliasedSelectorContext) SelectionFunction() ISelectionFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionFunctionContext)
}

func (s *SimpleUnaliasedSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUnaliasedSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUnaliasedSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSimpleUnaliasedSelector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SimpleUnaliasedSelector() (localctx ISimpleUnaliasedSelectorContext) {
	localctx = NewSimpleUnaliasedSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Cql3ParserRULE_simpleUnaliasedSelector)
	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)

			var _x = p.Sident()

			localctx.(*SimpleUnaliasedSelectorContext).c = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(494)

			var _x = p.SelectionLiteral()

			localctx.(*SimpleUnaliasedSelectorContext).l = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(495)

			var _x = p.SelectionFunction()

			localctx.(*SimpleUnaliasedSelectorContext).f = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionFunctionContext is an interface to support dynamic dispatch.
type ISelectionFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() ISidentContext

	// GetM returns the m rule contexts.
	GetM() ISelectorModifierContext

	// GetSn returns the sn rule contexts.
	GetSn() IUnaliasedSelectorContext

	// GetT returns the t rule contexts.
	GetT() INative_typeContext

	// GetF returns the f rule contexts.
	GetF() IFunctionNameContext

	// GetArgs returns the args rule contexts.
	GetArgs() ISelectionFunctionArgsContext

	// SetC sets the c rule contexts.
	SetC(ISidentContext)

	// SetM sets the m rule contexts.
	SetM(ISelectorModifierContext)

	// SetSn sets the sn rule contexts.
	SetSn(IUnaliasedSelectorContext)

	// SetT sets the t rule contexts.
	SetT(INative_typeContext)

	// SetF sets the f rule contexts.
	SetF(IFunctionNameContext)

	// SetArgs sets the args rule contexts.
	SetArgs(ISelectionFunctionArgsContext)

	// Getter signatures
	K_COUNT() antlr.TerminalNode
	K_MAXWRITETIME() antlr.TerminalNode
	Sident() ISidentContext
	AllSelectorModifier() []ISelectorModifierContext
	SelectorModifier(i int) ISelectorModifierContext
	K_WRITETIME() antlr.TerminalNode
	K_TTL() antlr.TerminalNode
	K_CAST() antlr.TerminalNode
	K_AS() antlr.TerminalNode
	UnaliasedSelector() IUnaliasedSelectorContext
	Native_type() INative_typeContext
	FunctionName() IFunctionNameContext
	SelectionFunctionArgs() ISelectionFunctionArgsContext

	// IsSelectionFunctionContext differentiates from other interfaces.
	IsSelectionFunctionContext()
}

type SelectionFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      ISidentContext
	m      ISelectorModifierContext
	sn     IUnaliasedSelectorContext
	t      INative_typeContext
	f      IFunctionNameContext
	args   ISelectionFunctionArgsContext
}

func NewEmptySelectionFunctionContext() *SelectionFunctionContext {
	var p = new(SelectionFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionFunction
	return p
}

func InitEmptySelectionFunctionContext(p *SelectionFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionFunction
}

func (*SelectionFunctionContext) IsSelectionFunctionContext() {}

func NewSelectionFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionFunctionContext {
	var p = new(SelectionFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionFunction

	return p
}

func (s *SelectionFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionFunctionContext) GetC() ISidentContext { return s.c }

func (s *SelectionFunctionContext) GetM() ISelectorModifierContext { return s.m }

func (s *SelectionFunctionContext) GetSn() IUnaliasedSelectorContext { return s.sn }

func (s *SelectionFunctionContext) GetT() INative_typeContext { return s.t }

func (s *SelectionFunctionContext) GetF() IFunctionNameContext { return s.f }

func (s *SelectionFunctionContext) GetArgs() ISelectionFunctionArgsContext { return s.args }

func (s *SelectionFunctionContext) SetC(v ISidentContext) { s.c = v }

func (s *SelectionFunctionContext) SetM(v ISelectorModifierContext) { s.m = v }

func (s *SelectionFunctionContext) SetSn(v IUnaliasedSelectorContext) { s.sn = v }

func (s *SelectionFunctionContext) SetT(v INative_typeContext) { s.t = v }

func (s *SelectionFunctionContext) SetF(v IFunctionNameContext) { s.f = v }

func (s *SelectionFunctionContext) SetArgs(v ISelectionFunctionArgsContext) { s.args = v }

func (s *SelectionFunctionContext) K_COUNT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COUNT, 0)
}

func (s *SelectionFunctionContext) K_MAXWRITETIME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MAXWRITETIME, 0)
}

func (s *SelectionFunctionContext) Sident() ISidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISidentContext)
}

func (s *SelectionFunctionContext) AllSelectorModifier() []ISelectorModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectorModifierContext); ok {
			len++
		}
	}

	tst := make([]ISelectorModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectorModifierContext); ok {
			tst[i] = t.(ISelectorModifierContext)
			i++
		}
	}

	return tst
}

func (s *SelectionFunctionContext) SelectorModifier(i int) ISelectorModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectorModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectorModifierContext)
}

func (s *SelectionFunctionContext) K_WRITETIME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WRITETIME, 0)
}

func (s *SelectionFunctionContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TTL, 0)
}

func (s *SelectionFunctionContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CAST, 0)
}

func (s *SelectionFunctionContext) K_AS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AS, 0)
}

func (s *SelectionFunctionContext) UnaliasedSelector() IUnaliasedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionFunctionContext) Native_type() INative_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INative_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INative_typeContext)
}

func (s *SelectionFunctionContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *SelectionFunctionContext) SelectionFunctionArgs() ISelectionFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionFunctionArgsContext)
}

func (s *SelectionFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionFunction() (localctx ISelectionFunctionContext) {
	localctx = NewSelectionFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Cql3ParserRULE_selectionFunction)
	var _la int

	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(498)
			p.Match(Cql3ParserK_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(500)
			p.Match(Cql3ParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.Match(Cql3ParserK_MAXWRITETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)

			var _x = p.Sident()

			localctx.(*SelectionFunctionContext).c = _x
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__7 || _la == Cql3ParserT__8 {
			{
				p.SetState(505)

				var _x = p.SelectorModifier()

				localctx.(*SelectionFunctionContext).m = _x
			}

			p.SetState(510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(511)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(513)
			p.Match(Cql3ParserK_WRITETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(514)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(515)

			var _x = p.Sident()

			localctx.(*SelectionFunctionContext).c = _x
		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__7 || _la == Cql3ParserT__8 {
			{
				p.SetState(516)

				var _x = p.SelectorModifier()

				localctx.(*SelectionFunctionContext).m = _x
			}

			p.SetState(521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(522)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(524)
			p.Match(Cql3ParserK_TTL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(525)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(526)

			var _x = p.Sident()

			localctx.(*SelectionFunctionContext).c = _x
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__7 || _la == Cql3ParserT__8 {
			{
				p.SetState(527)

				var _x = p.SelectorModifier()

				localctx.(*SelectionFunctionContext).m = _x
			}

			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(533)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(535)
			p.Match(Cql3ParserK_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionFunctionContext).sn = _x
		}
		{
			p.SetState(538)
			p.Match(Cql3ParserK_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(539)

			var _x = p.Native_type()

			localctx.(*SelectionFunctionContext).t = _x
		}
		{
			p.SetState(540)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(542)

			var _x = p.FunctionName()

			localctx.(*SelectionFunctionContext).f = _x
		}
		{
			p.SetState(543)

			var _x = p.SelectionFunctionArgs()

			localctx.(*SelectionFunctionContext).args = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionLiteralContext is an interface to support dynamic dispatch.
type ISelectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() IConstantContext

	// GetM returns the m rule contexts.
	GetM() IMarkerContext

	// SetC sets the c rule contexts.
	SetC(IConstantContext)

	// SetM sets the m rule contexts.
	SetM(IMarkerContext)

	// Getter signatures
	Constant() IConstantContext
	K_NULL() antlr.TerminalNode
	Marker() IMarkerContext

	// IsSelectionLiteralContext differentiates from other interfaces.
	IsSelectionLiteralContext()
}

type SelectionLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      IConstantContext
	m      IMarkerContext
}

func NewEmptySelectionLiteralContext() *SelectionLiteralContext {
	var p = new(SelectionLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionLiteral
	return p
}

func InitEmptySelectionLiteralContext(p *SelectionLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionLiteral
}

func (*SelectionLiteralContext) IsSelectionLiteralContext() {}

func NewSelectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionLiteralContext {
	var p = new(SelectionLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionLiteral

	return p
}

func (s *SelectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionLiteralContext) GetC() IConstantContext { return s.c }

func (s *SelectionLiteralContext) GetM() IMarkerContext { return s.m }

func (s *SelectionLiteralContext) SetC(v IConstantContext) { s.c = v }

func (s *SelectionLiteralContext) SetM(v IMarkerContext) { s.m = v }

func (s *SelectionLiteralContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *SelectionLiteralContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NULL, 0)
}

func (s *SelectionLiteralContext) Marker() IMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *SelectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionLiteral() (localctx ISelectionLiteralContext) {
	localctx = NewSelectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Cql3ParserRULE_selectionLiteral)
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN, Cql3ParserK_POSITIVE_INFINITY, Cql3ParserK_NEGATIVE_INFINITY, Cql3ParserSTRING_LITERAL, Cql3ParserINTEGER, Cql3ParserFLOAT, Cql3ParserBOOLEAN, Cql3ParserDURATION, Cql3ParserHEXNUMBER, Cql3ParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)

			var _x = p.Constant()

			localctx.(*SelectionLiteralContext).c = _x
		}

	case Cql3ParserK_NULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(548)
			p.Match(Cql3ParserK_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserT__14, Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(549)

			var _x = p.Marker()

			localctx.(*SelectionLiteralContext).m = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMarkerContext is an interface to support dynamic dispatch.
type IMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id rule contexts.
	GetId() INoncol_identContext

	// SetId sets the id rule contexts.
	SetId(INoncol_identContext)

	// Getter signatures
	Noncol_ident() INoncol_identContext
	QMARK() antlr.TerminalNode

	// IsMarkerContext differentiates from other interfaces.
	IsMarkerContext()
}

type MarkerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	id     INoncol_identContext
}

func NewEmptyMarkerContext() *MarkerContext {
	var p = new(MarkerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_marker
	return p
}

func InitEmptyMarkerContext(p *MarkerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_marker
}

func (*MarkerContext) IsMarkerContext() {}

func NewMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkerContext {
	var p = new(MarkerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_marker

	return p
}

func (s *MarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkerContext) GetId() INoncol_identContext { return s.id }

func (s *MarkerContext) SetId(v INoncol_identContext) { s.id = v }

func (s *MarkerContext) Noncol_ident() INoncol_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoncol_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoncol_identContext)
}

func (s *MarkerContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *MarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Marker() (localctx IMarkerContext) {
	localctx = NewMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Cql3ParserRULE_marker)
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)

			var _x = p.Noncol_ident()

			localctx.(*MarkerContext).id = _x
		}

	case Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(554)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionFunctionArgsContext is an interface to support dynamic dispatch.
type ISelectionFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS1 returns the s1 rule contexts.
	GetS1() IUnaliasedSelectorContext

	// GetSn returns the sn rule contexts.
	GetSn() IUnaliasedSelectorContext

	// SetS1 sets the s1 rule contexts.
	SetS1(IUnaliasedSelectorContext)

	// SetSn sets the sn rule contexts.
	SetSn(IUnaliasedSelectorContext)

	// Getter signatures
	AllUnaliasedSelector() []IUnaliasedSelectorContext
	UnaliasedSelector(i int) IUnaliasedSelectorContext

	// IsSelectionFunctionArgsContext differentiates from other interfaces.
	IsSelectionFunctionArgsContext()
}

type SelectionFunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s1     IUnaliasedSelectorContext
	sn     IUnaliasedSelectorContext
}

func NewEmptySelectionFunctionArgsContext() *SelectionFunctionArgsContext {
	var p = new(SelectionFunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionFunctionArgs
	return p
}

func InitEmptySelectionFunctionArgsContext(p *SelectionFunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_selectionFunctionArgs
}

func (*SelectionFunctionArgsContext) IsSelectionFunctionArgsContext() {}

func NewSelectionFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionFunctionArgsContext {
	var p = new(SelectionFunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_selectionFunctionArgs

	return p
}

func (s *SelectionFunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionFunctionArgsContext) GetS1() IUnaliasedSelectorContext { return s.s1 }

func (s *SelectionFunctionArgsContext) GetSn() IUnaliasedSelectorContext { return s.sn }

func (s *SelectionFunctionArgsContext) SetS1(v IUnaliasedSelectorContext) { s.s1 = v }

func (s *SelectionFunctionArgsContext) SetSn(v IUnaliasedSelectorContext) { s.sn = v }

func (s *SelectionFunctionArgsContext) AllUnaliasedSelector() []IUnaliasedSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			len++
		}
	}

	tst := make([]IUnaliasedSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaliasedSelectorContext); ok {
			tst[i] = t.(IUnaliasedSelectorContext)
			i++
		}
	}

	return tst
}

func (s *SelectionFunctionArgsContext) UnaliasedSelector(i int) IUnaliasedSelectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *SelectionFunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionFunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionFunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSelectionFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SelectionFunctionArgs() (localctx ISelectionFunctionArgsContext) {
	localctx = NewSelectionFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Cql3ParserRULE_selectionFunctionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
		{
			p.SetState(558)

			var _x = p.UnaliasedSelector()

			localctx.(*SelectionFunctionArgsContext).s1 = _x
		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(559)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(560)

				var _x = p.UnaliasedSelector()

				localctx.(*SelectionFunctionArgsContext).sn = _x
			}

			p.SetState(565)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(568)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISidentContext is an interface to support dynamic dispatch.
type ISidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// GetK returns the k rule contexts.
	GetK() IUnreserved_keywordContext

	// SetK sets the k rule contexts.
	SetK(IUnreserved_keywordContext)

	// Getter signatures
	IDENT() antlr.TerminalNode
	QUOTED_NAME() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsSidentContext differentiates from other interfaces.
	IsSidentContext()
}

type SidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
	k      IUnreserved_keywordContext
}

func NewEmptySidentContext() *SidentContext {
	var p = new(SidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_sident
	return p
}

func InitEmptySidentContext(p *SidentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_sident
}

func (*SidentContext) IsSidentContext() {}

func NewSidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SidentContext {
	var p = new(SidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_sident

	return p
}

func (s *SidentContext) GetParser() antlr.Parser { return s.parser }

func (s *SidentContext) GetT() antlr.Token { return s.t }

func (s *SidentContext) SetT(v antlr.Token) { s.t = v }

func (s *SidentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *SidentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *SidentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *SidentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *SidentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *SidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SidentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSident(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Sident() (localctx ISidentContext) {
	localctx = NewSidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Cql3ParserRULE_sident)
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*SidentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(571)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*SidentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(572)

			var _x = p.Unreserved_keyword()

			localctx.(*SidentContext).k = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelationOrExpression() []IRelationOrExpressionContext
	RelationOrExpression(i int) IRelationOrExpressionContext
	AllK_AND() []antlr.TerminalNode
	K_AND(i int) antlr.TerminalNode

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) AllRelationOrExpression() []IRelationOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRelationOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationOrExpressionContext); ok {
			tst[i] = t.(IRelationOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhereClauseContext) RelationOrExpression(i int) IRelationOrExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationOrExpressionContext)
}

func (s *WhereClauseContext) AllK_AND() []antlr.TerminalNode {
	return s.GetTokens(Cql3ParserK_AND)
}

func (s *WhereClauseContext) K_AND(i int) antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AND, i)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Cql3ParserRULE_whereClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.RelationOrExpression()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserK_AND {
		{
			p.SetState(576)
			p.Match(Cql3ParserK_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.RelationOrExpression()
		}

		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationOrExpressionContext is an interface to support dynamic dispatch.
type IRelationOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation() IRelationContext
	CustomIndexExpression() ICustomIndexExpressionContext

	// IsRelationOrExpressionContext differentiates from other interfaces.
	IsRelationOrExpressionContext()
}

type RelationOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationOrExpressionContext() *RelationOrExpressionContext {
	var p = new(RelationOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relationOrExpression
	return p
}

func InitEmptyRelationOrExpressionContext(p *RelationOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relationOrExpression
}

func (*RelationOrExpressionContext) IsRelationOrExpressionContext() {}

func NewRelationOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationOrExpressionContext {
	var p = new(RelationOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_relationOrExpression

	return p
}

func (s *RelationOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationOrExpressionContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationOrExpressionContext) CustomIndexExpression() ICustomIndexExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomIndexExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomIndexExpressionContext)
}

func (s *RelationOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) RelationOrExpression() (localctx IRelationOrExpressionContext) {
	localctx = NewRelationOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Cql3ParserRULE_relationOrExpression)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__10, Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_TOKEN, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserQUOTED_NAME, Cql3ParserEMPTY_QUOTED_NAME, Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(583)
			p.Relation()
		}

	case Cql3ParserT__15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(584)
			p.CustomIndexExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomIndexExpressionContext is an interface to support dynamic dispatch.
type ICustomIndexExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() ITermContext

	// SetT sets the t rule contexts.
	SetT(ITermContext)

	// Getter signatures
	IdxName() IIdxNameContext
	Term() ITermContext

	// IsCustomIndexExpressionContext differentiates from other interfaces.
	IsCustomIndexExpressionContext()
}

type CustomIndexExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      ITermContext
}

func NewEmptyCustomIndexExpressionContext() *CustomIndexExpressionContext {
	var p = new(CustomIndexExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_customIndexExpression
	return p
}

func InitEmptyCustomIndexExpressionContext(p *CustomIndexExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_customIndexExpression
}

func (*CustomIndexExpressionContext) IsCustomIndexExpressionContext() {}

func NewCustomIndexExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomIndexExpressionContext {
	var p = new(CustomIndexExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_customIndexExpression

	return p
}

func (s *CustomIndexExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomIndexExpressionContext) GetT() ITermContext { return s.t }

func (s *CustomIndexExpressionContext) SetT(v ITermContext) { s.t = v }

func (s *CustomIndexExpressionContext) IdxName() IIdxNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdxNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdxNameContext)
}

func (s *CustomIndexExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *CustomIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomIndexExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCustomIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CustomIndexExpression() (localctx ICustomIndexExpressionContext) {
	localctx = NewCustomIndexExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Cql3ParserRULE_customIndexExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(Cql3ParserT__15)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(588)
		p.IdxName()
	}
	{
		p.SetState(589)
		p.Match(Cql3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(590)

		var _x = p.Term()

		localctx.(*CustomIndexExpressionContext).t = _x
	}
	{
		p.SetState(591)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() ICidentContext

	// GetT returns the t rule contexts.
	GetT() ITermContext

	// SetC sets the c rule contexts.
	SetC(ICidentContext)

	// SetT sets the t rule contexts.
	SetT(ITermContext)

	// Getter signatures
	Cident() ICidentContext
	K_ANN() antlr.TerminalNode
	K_OF() antlr.TerminalNode
	Term() ITermContext
	K_ASC() antlr.TerminalNode
	K_DESC() antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      ICidentContext
	t      ITermContext
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) GetC() ICidentContext { return s.c }

func (s *OrderByClauseContext) GetT() ITermContext { return s.t }

func (s *OrderByClauseContext) SetC(v ICidentContext) { s.c = v }

func (s *OrderByClauseContext) SetT(v ITermContext) { s.t = v }

func (s *OrderByClauseContext) Cident() ICidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICidentContext)
}

func (s *OrderByClauseContext) K_ANN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ANN, 0)
}

func (s *OrderByClauseContext) K_OF() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_OF, 0)
}

func (s *OrderByClauseContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *OrderByClauseContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ASC, 0)
}

func (s *OrderByClauseContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DESC, 0)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Cql3ParserRULE_orderByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)

		var _x = p.Cident()

		localctx.(*OrderByClauseContext).c = _x
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_ANN {
		{
			p.SetState(594)
			p.Match(Cql3ParserK_ANN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.Match(Cql3ParserK_OF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)

			var _x = p.Term()

			localctx.(*OrderByClauseContext).t = _x
		}

	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_ASC || _la == Cql3ParserK_DESC {
		{
			p.SetState(599)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cql3ParserK_ASC || _la == Cql3ParserK_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s rule contexts.
	GetS() IUnaliasedSelectorContext

	// SetS sets the s rule contexts.
	SetS(IUnaliasedSelectorContext)

	// Getter signatures
	UnaliasedSelector() IUnaliasedSelectorContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s      IUnaliasedSelectorContext
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GetS() IUnaliasedSelectorContext { return s.s }

func (s *GroupByClauseContext) SetS(v IUnaliasedSelectorContext) { s.s = v }

func (s *GroupByClauseContext) UnaliasedSelector() IUnaliasedSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaliasedSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaliasedSelectorContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Cql3ParserRULE_groupByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)

		var _x = p.UnaliasedSelector()

		localctx.(*GroupByClauseContext).s = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateKeyspaceStatementContext is an interface to support dynamic dispatch.
type ICreateKeyspaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() IKeyspaceNameContext

	// SetKs sets the ks rule contexts.
	SetKs(IKeyspaceNameContext)

	// Getter signatures
	K_CREATE() antlr.TerminalNode
	K_KEYSPACE() antlr.TerminalNode
	K_WITH() antlr.TerminalNode
	Properties() IPropertiesContext
	KeyspaceName() IKeyspaceNameContext
	IfNotExists() IIfNotExistsContext

	// IsCreateKeyspaceStatementContext differentiates from other interfaces.
	IsCreateKeyspaceStatementContext()
}

type CreateKeyspaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     IKeyspaceNameContext
}

func NewEmptyCreateKeyspaceStatementContext() *CreateKeyspaceStatementContext {
	var p = new(CreateKeyspaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createKeyspaceStatement
	return p
}

func InitEmptyCreateKeyspaceStatementContext(p *CreateKeyspaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createKeyspaceStatement
}

func (*CreateKeyspaceStatementContext) IsCreateKeyspaceStatementContext() {}

func NewCreateKeyspaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateKeyspaceStatementContext {
	var p = new(CreateKeyspaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_createKeyspaceStatement

	return p
}

func (s *CreateKeyspaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateKeyspaceStatementContext) GetKs() IKeyspaceNameContext { return s.ks }

func (s *CreateKeyspaceStatementContext) SetKs(v IKeyspaceNameContext) { s.ks = v }

func (s *CreateKeyspaceStatementContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CREATE, 0)
}

func (s *CreateKeyspaceStatementContext) K_KEYSPACE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEYSPACE, 0)
}

func (s *CreateKeyspaceStatementContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *CreateKeyspaceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateKeyspaceStatementContext) KeyspaceName() IKeyspaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceNameContext)
}

func (s *CreateKeyspaceStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateKeyspaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateKeyspaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateKeyspaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCreateKeyspaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CreateKeyspaceStatement() (localctx ICreateKeyspaceStatementContext) {
	localctx = NewCreateKeyspaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Cql3ParserRULE_createKeyspaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(Cql3ParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(605)
		p.Match(Cql3ParserK_KEYSPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(606)
			p.IfNotExists()
		}

	}
	{
		p.SetState(609)

		var _x = p.KeyspaceName()

		localctx.(*CreateKeyspaceStatementContext).ks = _x
	}
	{
		p.SetState(610)
		p.Match(Cql3ParserK_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(611)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// Getter signatures
	K_CREATE() antlr.TerminalNode
	K_COLUMNFAMILY() antlr.TerminalNode
	TableDefinition() ITableDefinitionContext
	ColumnFamilyName() IColumnFamilyNameContext
	IfNotExists() IIfNotExistsContext

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cf     IColumnFamilyNameContext
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *CreateTableStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *CreateTableStatementContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CREATE, 0)
}

func (s *CreateTableStatementContext) K_COLUMNFAMILY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COLUMNFAMILY, 0)
}

func (s *CreateTableStatementContext) TableDefinition() ITableDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableDefinitionContext)
}

func (s *CreateTableStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *CreateTableStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Cql3ParserRULE_createTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Match(Cql3ParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(614)
		p.Match(Cql3ParserK_COLUMNFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(615)
			p.IfNotExists()
		}

	}
	{
		p.SetState(618)

		var _x = p.ColumnFamilyName()

		localctx.(*CreateTableStatementContext).cf = _x
	}
	{
		p.SetState(619)
		p.TableDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IF() antlr.TerminalNode
	K_NOT() antlr.TerminalNode
	K_EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) K_IF() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IF, 0)
}

func (s *IfNotExistsContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOT, 0)
}

func (s *IfNotExistsContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_EXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Cql3ParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(Cql3ParserK_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Match(Cql3ParserK_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(623)
		p.Match(Cql3ParserK_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IF() antlr.TerminalNode
	K_EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) K_IF() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IF, 0)
}

func (s *IfExistsContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_EXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Cql3ParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(Cql3ParserK_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)
		p.Match(Cql3ParserK_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableDefinitionContext is an interface to support dynamic dispatch.
type ITableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableColumns() []ITableColumnsContext
	TableColumns(i int) ITableColumnsContext
	K_WITH() antlr.TerminalNode
	AllTableProperty() []ITablePropertyContext
	TableProperty(i int) ITablePropertyContext
	AllK_AND() []antlr.TerminalNode
	K_AND(i int) antlr.TerminalNode

	// IsTableDefinitionContext differentiates from other interfaces.
	IsTableDefinitionContext()
}

type TableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableDefinitionContext() *TableDefinitionContext {
	var p = new(TableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableDefinition
	return p
}

func InitEmptyTableDefinitionContext(p *TableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableDefinition
}

func (*TableDefinitionContext) IsTableDefinitionContext() {}

func NewTableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableDefinitionContext {
	var p = new(TableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tableDefinition

	return p
}

func (s *TableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableDefinitionContext) AllTableColumns() []ITableColumnsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableColumnsContext); ok {
			len++
		}
	}

	tst := make([]ITableColumnsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableColumnsContext); ok {
			tst[i] = t.(ITableColumnsContext)
			i++
		}
	}

	return tst
}

func (s *TableDefinitionContext) TableColumns(i int) ITableColumnsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnsContext)
}

func (s *TableDefinitionContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *TableDefinitionContext) AllTableProperty() []ITablePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePropertyContext); ok {
			len++
		}
	}

	tst := make([]ITablePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePropertyContext); ok {
			tst[i] = t.(ITablePropertyContext)
			i++
		}
	}

	return tst
}

func (s *TableDefinitionContext) TableProperty(i int) ITablePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TableDefinitionContext) AllK_AND() []antlr.TerminalNode {
	return s.GetTokens(Cql3ParserK_AND)
}

func (s *TableDefinitionContext) K_AND(i int) antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AND, i)
}

func (s *TableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTableDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TableDefinition() (localctx ITableDefinitionContext) {
	localctx = NewTableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Cql3ParserRULE_tableDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.TableColumns()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(630)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8601871782745473024) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&1159675804520446975) != 0) {
			{
				p.SetState(631)
				p.TableColumns()
			}

		}

		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(639)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_WITH {
		{
			p.SetState(640)
			p.Match(Cql3ParserK_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(641)
			p.TableProperty()
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserK_AND {
			{
				p.SetState(642)
				p.Match(Cql3ParserK_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(643)
				p.TableProperty()
			}

			p.SetState(648)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableColumnsContext is an interface to support dynamic dispatch.
type ITableColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableColumnsContext differentiates from other interfaces.
	IsTableColumnsContext()
}

type TableColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnsContext() *TableColumnsContext {
	var p = new(TableColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableColumns
	return p
}

func InitEmptyTableColumnsContext(p *TableColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableColumns
}

func (*TableColumnsContext) IsTableColumnsContext() {}

func NewTableColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnsContext {
	var p = new(TableColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tableColumns

	return p
}

func (s *TableColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnsContext) CopyAll(ctx *TableColumnsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableColumnDeclarationContext struct {
	TableColumnsContext
	k    IIdentContext
	v    IComparatorTypeContext
	mask IColumnMaskContext
}

func NewTableColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableColumnDeclarationContext {
	var p = new(TableColumnDeclarationContext)

	InitEmptyTableColumnsContext(&p.TableColumnsContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableColumnsContext))

	return p
}

func (s *TableColumnDeclarationContext) GetK() IIdentContext { return s.k }

func (s *TableColumnDeclarationContext) GetV() IComparatorTypeContext { return s.v }

func (s *TableColumnDeclarationContext) GetMask() IColumnMaskContext { return s.mask }

func (s *TableColumnDeclarationContext) SetK(v IIdentContext) { s.k = v }

func (s *TableColumnDeclarationContext) SetV(v IComparatorTypeContext) { s.v = v }

func (s *TableColumnDeclarationContext) SetMask(v IColumnMaskContext) { s.mask = v }

func (s *TableColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnDeclarationContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *TableColumnDeclarationContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *TableColumnDeclarationContext) K_STATIC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_STATIC, 0)
}

func (s *TableColumnDeclarationContext) K_PRIMARY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PRIMARY, 0)
}

func (s *TableColumnDeclarationContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEY, 0)
}

func (s *TableColumnDeclarationContext) ColumnMask() IColumnMaskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnMaskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnMaskContext)
}

func (s *TableColumnDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTableColumnDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableKeyDeclarationContext struct {
	TableColumnsContext
	pk ITablePartitionKeyContext
	c  IIdentContext
}

func NewTableKeyDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableKeyDeclarationContext {
	var p = new(TableKeyDeclarationContext)

	InitEmptyTableColumnsContext(&p.TableColumnsContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableColumnsContext))

	return p
}

func (s *TableKeyDeclarationContext) GetPk() ITablePartitionKeyContext { return s.pk }

func (s *TableKeyDeclarationContext) GetC() IIdentContext { return s.c }

func (s *TableKeyDeclarationContext) SetPk(v ITablePartitionKeyContext) { s.pk = v }

func (s *TableKeyDeclarationContext) SetC(v IIdentContext) { s.c = v }

func (s *TableKeyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableKeyDeclarationContext) K_PRIMARY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PRIMARY, 0)
}

func (s *TableKeyDeclarationContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEY, 0)
}

func (s *TableKeyDeclarationContext) TablePartitionKey() ITablePartitionKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePartitionKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePartitionKeyContext)
}

func (s *TableKeyDeclarationContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *TableKeyDeclarationContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *TableKeyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTableKeyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TableColumns() (localctx ITableColumnsContext) {
	localctx = NewTableColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Cql3ParserRULE_tableColumns)
	var _la int

	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserQUOTED_NAME, Cql3ParserIDENT:
		localctx = NewTableColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(651)

			var _x = p.Ident()

			localctx.(*TableColumnDeclarationContext).k = _x
		}
		{
			p.SetState(652)

			var _x = p.ComparatorType()

			localctx.(*TableColumnDeclarationContext).v = _x
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cql3ParserK_STATIC {
			{
				p.SetState(653)
				p.Match(Cql3ParserK_STATIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cql3ParserK_MASKED {
			{
				p.SetState(656)

				var _x = p.ColumnMask()

				localctx.(*TableColumnDeclarationContext).mask = _x
			}

		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cql3ParserK_PRIMARY {
			{
				p.SetState(659)
				p.Match(Cql3ParserK_PRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(660)
				p.Match(Cql3ParserK_KEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case Cql3ParserK_PRIMARY:
		localctx = NewTableKeyDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(663)
			p.Match(Cql3ParserK_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.Match(Cql3ParserK_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(665)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)

			var _x = p.TablePartitionKey()

			localctx.(*TableKeyDeclarationContext).pk = _x
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(667)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(668)

				var _x = p.Ident()

				localctx.(*TableKeyDeclarationContext).c = _x
			}

			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(674)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnMaskContext is an interface to support dynamic dispatch.
type IColumnMaskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IFunctionNameContext

	// SetName sets the name rule contexts.
	SetName(IFunctionNameContext)

	// Getter signatures
	K_MASKED() antlr.TerminalNode
	K_WITH() antlr.TerminalNode
	ColumnMaskArguments() IColumnMaskArgumentsContext
	FunctionName() IFunctionNameContext
	K_DEFAULT() antlr.TerminalNode

	// IsColumnMaskContext differentiates from other interfaces.
	IsColumnMaskContext()
}

type ColumnMaskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IFunctionNameContext
}

func NewEmptyColumnMaskContext() *ColumnMaskContext {
	var p = new(ColumnMaskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnMask
	return p
}

func InitEmptyColumnMaskContext(p *ColumnMaskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnMask
}

func (*ColumnMaskContext) IsColumnMaskContext() {}

func NewColumnMaskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnMaskContext {
	var p = new(ColumnMaskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_columnMask

	return p
}

func (s *ColumnMaskContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnMaskContext) GetName() IFunctionNameContext { return s.name }

func (s *ColumnMaskContext) SetName(v IFunctionNameContext) { s.name = v }

func (s *ColumnMaskContext) K_MASKED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MASKED, 0)
}

func (s *ColumnMaskContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *ColumnMaskContext) ColumnMaskArguments() IColumnMaskArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnMaskArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnMaskArgumentsContext)
}

func (s *ColumnMaskContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *ColumnMaskContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DEFAULT, 0)
}

func (s *ColumnMaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnMaskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnMaskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitColumnMask(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ColumnMask() (localctx IColumnMaskContext) {
	localctx = NewColumnMaskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Cql3ParserRULE_columnMask)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(678)
			p.Match(Cql3ParserK_MASKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)
			p.Match(Cql3ParserK_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)

			var _x = p.FunctionName()

			localctx.(*ColumnMaskContext).name = _x
		}
		{
			p.SetState(681)
			p.ColumnMaskArguments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(683)
			p.Match(Cql3ParserK_MASKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.Match(Cql3ParserK_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)
			p.Match(Cql3ParserK_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnMaskArgumentsContext is an interface to support dynamic dispatch.
type IColumnMaskArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() ITermContext

	// GetCn returns the cn rule contexts.
	GetCn() ITermContext

	// SetC sets the c rule contexts.
	SetC(ITermContext)

	// SetCn sets the cn rule contexts.
	SetCn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsColumnMaskArgumentsContext differentiates from other interfaces.
	IsColumnMaskArgumentsContext()
}

type ColumnMaskArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      ITermContext
	cn     ITermContext
}

func NewEmptyColumnMaskArgumentsContext() *ColumnMaskArgumentsContext {
	var p = new(ColumnMaskArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnMaskArguments
	return p
}

func InitEmptyColumnMaskArgumentsContext(p *ColumnMaskArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnMaskArguments
}

func (*ColumnMaskArgumentsContext) IsColumnMaskArgumentsContext() {}

func NewColumnMaskArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnMaskArgumentsContext {
	var p = new(ColumnMaskArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_columnMaskArguments

	return p
}

func (s *ColumnMaskArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnMaskArgumentsContext) GetC() ITermContext { return s.c }

func (s *ColumnMaskArgumentsContext) GetCn() ITermContext { return s.cn }

func (s *ColumnMaskArgumentsContext) SetC(v ITermContext) { s.c = v }

func (s *ColumnMaskArgumentsContext) SetCn(v ITermContext) { s.cn = v }

func (s *ColumnMaskArgumentsContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *ColumnMaskArgumentsContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *ColumnMaskArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnMaskArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnMaskArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitColumnMaskArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ColumnMaskArguments() (localctx IColumnMaskArgumentsContext) {
	localctx = NewColumnMaskArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Cql3ParserRULE_columnMaskArguments)
	var _la int

	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(688)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(690)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)

			var _x = p.Term()

			localctx.(*ColumnMaskArgumentsContext).c = _x
		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(692)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(693)

				var _x = p.Term()

				localctx.(*ColumnMaskArgumentsContext).cn = _x
			}

			p.SetState(698)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(699)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePartitionKeyContext is an interface to support dynamic dispatch.
type ITablePartitionKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK1 returns the k1 rule contexts.
	GetK1() IIdentContext

	// GetKn returns the kn rule contexts.
	GetKn() IIdentContext

	// SetK1 sets the k1 rule contexts.
	SetK1(IIdentContext)

	// SetKn sets the kn rule contexts.
	SetKn(IIdentContext)

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext

	// IsTablePartitionKeyContext differentiates from other interfaces.
	IsTablePartitionKeyContext()
}

type TablePartitionKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k1     IIdentContext
	kn     IIdentContext
}

func NewEmptyTablePartitionKeyContext() *TablePartitionKeyContext {
	var p = new(TablePartitionKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tablePartitionKey
	return p
}

func InitEmptyTablePartitionKeyContext(p *TablePartitionKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tablePartitionKey
}

func (*TablePartitionKeyContext) IsTablePartitionKeyContext() {}

func NewTablePartitionKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePartitionKeyContext {
	var p = new(TablePartitionKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tablePartitionKey

	return p
}

func (s *TablePartitionKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePartitionKeyContext) GetK1() IIdentContext { return s.k1 }

func (s *TablePartitionKeyContext) GetKn() IIdentContext { return s.kn }

func (s *TablePartitionKeyContext) SetK1(v IIdentContext) { s.k1 = v }

func (s *TablePartitionKeyContext) SetKn(v IIdentContext) { s.kn = v }

func (s *TablePartitionKeyContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *TablePartitionKeyContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *TablePartitionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePartitionKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePartitionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTablePartitionKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TablePartitionKey() (localctx ITablePartitionKeyContext) {
	localctx = NewTablePartitionKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Cql3ParserRULE_tablePartitionKey)
	var _la int

	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserQUOTED_NAME, Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)

			var _x = p.Ident()

			localctx.(*TablePartitionKeyContext).k1 = _x
		}

	case Cql3ParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(705)

			var _x = p.Ident()

			localctx.(*TablePartitionKeyContext).k1 = _x
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(706)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(707)

				var _x = p.Ident()

				localctx.(*TablePartitionKeyContext).kn = _x
			}

			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(713)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Property() IPropertyContext
	K_COMPACT() antlr.TerminalNode
	K_STORAGE() antlr.TerminalNode
	K_CLUSTERING() antlr.TerminalNode
	K_ORDER() antlr.TerminalNode
	K_BY() antlr.TerminalNode
	AllTableClusteringOrder() []ITableClusteringOrderContext
	TableClusteringOrder(i int) ITableClusteringOrderContext

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableProperty
	return p
}

func InitEmptyTablePropertyContext(p *TablePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableProperty
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *TablePropertyContext) K_COMPACT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COMPACT, 0)
}

func (s *TablePropertyContext) K_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_STORAGE, 0)
}

func (s *TablePropertyContext) K_CLUSTERING() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CLUSTERING, 0)
}

func (s *TablePropertyContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ORDER, 0)
}

func (s *TablePropertyContext) K_BY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BY, 0)
}

func (s *TablePropertyContext) AllTableClusteringOrder() []ITableClusteringOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableClusteringOrderContext); ok {
			len++
		}
	}

	tst := make([]ITableClusteringOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableClusteringOrderContext); ok {
			tst[i] = t.(ITableClusteringOrderContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertyContext) TableClusteringOrder(i int) ITableClusteringOrderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableClusteringOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableClusteringOrderContext)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTableProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Cql3ParserRULE_tableProperty)
	var _la int

	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Property()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(Cql3ParserK_COMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.Match(Cql3ParserK_STORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(720)
			p.Match(Cql3ParserK_CLUSTERING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.Match(Cql3ParserK_ORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.Match(Cql3ParserK_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(723)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.TableClusteringOrder()
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(725)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(726)
				p.TableClusteringOrder()
			}

			p.SetState(731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(732)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableClusteringOrderContext is an interface to support dynamic dispatch.
type ITableClusteringOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IIdentContext

	// SetK sets the k rule contexts.
	SetK(IIdentContext)

	// Getter signatures
	Ident() IIdentContext
	K_ASC() antlr.TerminalNode
	K_DESC() antlr.TerminalNode

	// IsTableClusteringOrderContext differentiates from other interfaces.
	IsTableClusteringOrderContext()
}

type TableClusteringOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IIdentContext
}

func NewEmptyTableClusteringOrderContext() *TableClusteringOrderContext {
	var p = new(TableClusteringOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableClusteringOrder
	return p
}

func InitEmptyTableClusteringOrderContext(p *TableClusteringOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tableClusteringOrder
}

func (*TableClusteringOrderContext) IsTableClusteringOrderContext() {}

func NewTableClusteringOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableClusteringOrderContext {
	var p = new(TableClusteringOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tableClusteringOrder

	return p
}

func (s *TableClusteringOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *TableClusteringOrderContext) GetK() IIdentContext { return s.k }

func (s *TableClusteringOrderContext) SetK(v IIdentContext) { s.k = v }

func (s *TableClusteringOrderContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *TableClusteringOrderContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ASC, 0)
}

func (s *TableClusteringOrderContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DESC, 0)
}

func (s *TableClusteringOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableClusteringOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableClusteringOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTableClusteringOrder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TableClusteringOrder() (localctx ITableClusteringOrderContext) {
	localctx = NewTableClusteringOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Cql3ParserRULE_tableClusteringOrder)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)

		var _x = p.Ident()

		localctx.(*TableClusteringOrderContext).k = _x
	}
	{
		p.SetState(737)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cql3ParserK_ASC || _la == Cql3ParserK_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTypeStatementContext is an interface to support dynamic dispatch.
type ICreateTypeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTn returns the tn rule contexts.
	GetTn() IUserTypeNameContext

	// SetTn sets the tn rule contexts.
	SetTn(IUserTypeNameContext)

	// Getter signatures
	K_CREATE() antlr.TerminalNode
	K_TYPE() antlr.TerminalNode
	AllTypeColumns() []ITypeColumnsContext
	TypeColumns(i int) ITypeColumnsContext
	UserTypeName() IUserTypeNameContext
	IfNotExists() IIfNotExistsContext

	// IsCreateTypeStatementContext differentiates from other interfaces.
	IsCreateTypeStatementContext()
}

type CreateTypeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tn     IUserTypeNameContext
}

func NewEmptyCreateTypeStatementContext() *CreateTypeStatementContext {
	var p = new(CreateTypeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTypeStatement
	return p
}

func InitEmptyCreateTypeStatementContext(p *CreateTypeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTypeStatement
}

func (*CreateTypeStatementContext) IsCreateTypeStatementContext() {}

func NewCreateTypeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTypeStatementContext {
	var p = new(CreateTypeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_createTypeStatement

	return p
}

func (s *CreateTypeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTypeStatementContext) GetTn() IUserTypeNameContext { return s.tn }

func (s *CreateTypeStatementContext) SetTn(v IUserTypeNameContext) { s.tn = v }

func (s *CreateTypeStatementContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CREATE, 0)
}

func (s *CreateTypeStatementContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TYPE, 0)
}

func (s *CreateTypeStatementContext) AllTypeColumns() []ITypeColumnsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeColumnsContext); ok {
			len++
		}
	}

	tst := make([]ITypeColumnsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeColumnsContext); ok {
			tst[i] = t.(ITypeColumnsContext)
			i++
		}
	}

	return tst
}

func (s *CreateTypeStatementContext) TypeColumns(i int) ITypeColumnsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeColumnsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeColumnsContext)
}

func (s *CreateTypeStatementContext) UserTypeName() IUserTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeNameContext)
}

func (s *CreateTypeStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTypeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTypeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTypeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCreateTypeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CreateTypeStatement() (localctx ICreateTypeStatementContext) {
	localctx = NewCreateTypeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Cql3ParserRULE_createTypeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(Cql3ParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(740)
		p.Match(Cql3ParserK_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(741)
			p.IfNotExists()
		}

	}
	{
		p.SetState(744)

		var _x = p.UserTypeName()

		localctx.(*CreateTypeStatementContext).tn = _x
	}
	{
		p.SetState(745)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(746)
		p.TypeColumns()
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(747)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109302784) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&1159675804520446975) != 0) {
			{
				p.SetState(748)
				p.TypeColumns()
			}

		}

		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(756)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeColumnsContext is an interface to support dynamic dispatch.
type ITypeColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IFidentContext

	// GetV returns the v rule contexts.
	GetV() IComparatorTypeContext

	// SetK sets the k rule contexts.
	SetK(IFidentContext)

	// SetV sets the v rule contexts.
	SetV(IComparatorTypeContext)

	// Getter signatures
	Fident() IFidentContext
	ComparatorType() IComparatorTypeContext

	// IsTypeColumnsContext differentiates from other interfaces.
	IsTypeColumnsContext()
}

type TypeColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IFidentContext
	v      IComparatorTypeContext
}

func NewEmptyTypeColumnsContext() *TypeColumnsContext {
	var p = new(TypeColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_typeColumns
	return p
}

func InitEmptyTypeColumnsContext(p *TypeColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_typeColumns
}

func (*TypeColumnsContext) IsTypeColumnsContext() {}

func NewTypeColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeColumnsContext {
	var p = new(TypeColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_typeColumns

	return p
}

func (s *TypeColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeColumnsContext) GetK() IFidentContext { return s.k }

func (s *TypeColumnsContext) GetV() IComparatorTypeContext { return s.v }

func (s *TypeColumnsContext) SetK(v IFidentContext) { s.k = v }

func (s *TypeColumnsContext) SetV(v IComparatorTypeContext) { s.v = v }

func (s *TypeColumnsContext) Fident() IFidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFidentContext)
}

func (s *TypeColumnsContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *TypeColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTypeColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TypeColumns() (localctx ITypeColumnsContext) {
	localctx = NewTypeColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Cql3ParserRULE_typeColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)

		var _x = p.Fident()

		localctx.(*TypeColumnsContext).k = _x
	}
	{
		p.SetState(759)

		var _x = p.ComparatorType()

		localctx.(*TypeColumnsContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerStatementContext is an interface to support dynamic dispatch.
type ICreateTriggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCls returns the cls token.
	GetCls() antlr.Token

	// SetCls sets the cls token.
	SetCls(antlr.Token)

	// GetName returns the name rule contexts.
	GetName() IIdentContext

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// SetName sets the name rule contexts.
	SetName(IIdentContext)

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// Getter signatures
	K_CREATE() antlr.TerminalNode
	K_TRIGGER() antlr.TerminalNode
	K_ON() antlr.TerminalNode
	K_USING() antlr.TerminalNode
	ColumnFamilyName() IColumnFamilyNameContext
	STRING_LITERAL() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	Ident() IIdentContext

	// IsCreateTriggerStatementContext differentiates from other interfaces.
	IsCreateTriggerStatementContext()
}

type CreateTriggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentContext
	cf     IColumnFamilyNameContext
	cls    antlr.Token
}

func NewEmptyCreateTriggerStatementContext() *CreateTriggerStatementContext {
	var p = new(CreateTriggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTriggerStatement
	return p
}

func InitEmptyCreateTriggerStatementContext(p *CreateTriggerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createTriggerStatement
}

func (*CreateTriggerStatementContext) IsCreateTriggerStatementContext() {}

func NewCreateTriggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerStatementContext {
	var p = new(CreateTriggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_createTriggerStatement

	return p
}

func (s *CreateTriggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerStatementContext) GetCls() antlr.Token { return s.cls }

func (s *CreateTriggerStatementContext) SetCls(v antlr.Token) { s.cls = v }

func (s *CreateTriggerStatementContext) GetName() IIdentContext { return s.name }

func (s *CreateTriggerStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *CreateTriggerStatementContext) SetName(v IIdentContext) { s.name = v }

func (s *CreateTriggerStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *CreateTriggerStatementContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CREATE, 0)
}

func (s *CreateTriggerStatementContext) K_TRIGGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TRIGGER, 0)
}

func (s *CreateTriggerStatementContext) K_ON() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ON, 0)
}

func (s *CreateTriggerStatementContext) K_USING() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USING, 0)
}

func (s *CreateTriggerStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *CreateTriggerStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *CreateTriggerStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTriggerStatementContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *CreateTriggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCreateTriggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CreateTriggerStatement() (localctx ICreateTriggerStatementContext) {
	localctx = NewCreateTriggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Cql3ParserRULE_createTriggerStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(Cql3ParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(762)
		p.Match(Cql3ParserK_TRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(763)
			p.IfNotExists()
		}

	}

	{
		p.SetState(766)

		var _x = p.Ident()

		localctx.(*CreateTriggerStatementContext).name = _x
	}

	{
		p.SetState(767)
		p.Match(Cql3ParserK_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)

		var _x = p.ColumnFamilyName()

		localctx.(*CreateTriggerStatementContext).cf = _x
	}
	{
		p.SetState(769)
		p.Match(Cql3ParserK_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)

		var _m = p.Match(Cql3ParserSTRING_LITERAL)

		localctx.(*CreateTriggerStatementContext).cls = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerStatementContext is an interface to support dynamic dispatch.
type IDropTriggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentContext

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// SetName sets the name rule contexts.
	SetName(IIdentContext)

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_TRIGGER() antlr.TerminalNode
	K_ON() antlr.TerminalNode
	ColumnFamilyName() IColumnFamilyNameContext
	IfExists() IIfExistsContext
	Ident() IIdentContext

	// IsDropTriggerStatementContext differentiates from other interfaces.
	IsDropTriggerStatementContext()
}

type DropTriggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentContext
	cf     IColumnFamilyNameContext
}

func NewEmptyDropTriggerStatementContext() *DropTriggerStatementContext {
	var p = new(DropTriggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTriggerStatement
	return p
}

func InitEmptyDropTriggerStatementContext(p *DropTriggerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTriggerStatement
}

func (*DropTriggerStatementContext) IsDropTriggerStatementContext() {}

func NewDropTriggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerStatementContext {
	var p = new(DropTriggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropTriggerStatement

	return p
}

func (s *DropTriggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerStatementContext) GetName() IIdentContext { return s.name }

func (s *DropTriggerStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *DropTriggerStatementContext) SetName(v IIdentContext) { s.name = v }

func (s *DropTriggerStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *DropTriggerStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropTriggerStatementContext) K_TRIGGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TRIGGER, 0)
}

func (s *DropTriggerStatementContext) K_ON() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ON, 0)
}

func (s *DropTriggerStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *DropTriggerStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerStatementContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *DropTriggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropTriggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropTriggerStatement() (localctx IDropTriggerStatementContext) {
	localctx = NewDropTriggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Cql3ParserRULE_dropTriggerStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Match(Cql3ParserK_TRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(774)
			p.IfExists()
		}

	}

	{
		p.SetState(777)

		var _x = p.Ident()

		localctx.(*DropTriggerStatementContext).name = _x
	}

	{
		p.SetState(778)
		p.Match(Cql3ParserK_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(779)

		var _x = p.ColumnFamilyName()

		localctx.(*DropTriggerStatementContext).cf = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterKeyspaceStatementContext is an interface to support dynamic dispatch.
type IAlterKeyspaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() IKeyspaceNameContext

	// SetKs sets the ks rule contexts.
	SetKs(IKeyspaceNameContext)

	// Getter signatures
	K_ALTER() antlr.TerminalNode
	K_KEYSPACE() antlr.TerminalNode
	K_WITH() antlr.TerminalNode
	Properties() IPropertiesContext
	KeyspaceName() IKeyspaceNameContext
	IfExists() IIfExistsContext

	// IsAlterKeyspaceStatementContext differentiates from other interfaces.
	IsAlterKeyspaceStatementContext()
}

type AlterKeyspaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     IKeyspaceNameContext
}

func NewEmptyAlterKeyspaceStatementContext() *AlterKeyspaceStatementContext {
	var p = new(AlterKeyspaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterKeyspaceStatement
	return p
}

func InitEmptyAlterKeyspaceStatementContext(p *AlterKeyspaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterKeyspaceStatement
}

func (*AlterKeyspaceStatementContext) IsAlterKeyspaceStatementContext() {}

func NewAlterKeyspaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterKeyspaceStatementContext {
	var p = new(AlterKeyspaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_alterKeyspaceStatement

	return p
}

func (s *AlterKeyspaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterKeyspaceStatementContext) GetKs() IKeyspaceNameContext { return s.ks }

func (s *AlterKeyspaceStatementContext) SetKs(v IKeyspaceNameContext) { s.ks = v }

func (s *AlterKeyspaceStatementContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ALTER, 0)
}

func (s *AlterKeyspaceStatementContext) K_KEYSPACE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEYSPACE, 0)
}

func (s *AlterKeyspaceStatementContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *AlterKeyspaceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterKeyspaceStatementContext) KeyspaceName() IKeyspaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceNameContext)
}

func (s *AlterKeyspaceStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterKeyspaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterKeyspaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterKeyspaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAlterKeyspaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) AlterKeyspaceStatement() (localctx IAlterKeyspaceStatementContext) {
	localctx = NewAlterKeyspaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Cql3ParserRULE_alterKeyspaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(Cql3ParserK_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(782)
		p.Match(Cql3ParserK_KEYSPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(783)
			p.IfExists()
		}

	}
	{
		p.SetState(786)

		var _x = p.KeyspaceName()

		localctx.(*AlterKeyspaceStatementContext).ks = _x
	}
	{
		p.SetState(787)
		p.Match(Cql3ParserK_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(788)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IColumnFamilyNameContext

	// SetName sets the name rule contexts.
	SetName(IColumnFamilyNameContext)

	// Getter signatures
	K_ALTER() antlr.TerminalNode
	K_MATERIALIZED() antlr.TerminalNode
	K_VIEW() antlr.TerminalNode
	K_WITH() antlr.TerminalNode
	Properties() IPropertiesContext
	ColumnFamilyName() IColumnFamilyNameContext
	IfExists() IIfExistsContext

	// IsAlterMaterializedViewStatementContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementContext()
}

type AlterMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IColumnFamilyNameContext
}

func NewEmptyAlterMaterializedViewStatementContext() *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterMaterializedViewStatement
	return p
}

func InitEmptyAlterMaterializedViewStatementContext(p *AlterMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterMaterializedViewStatement
}

func (*AlterMaterializedViewStatementContext) IsAlterMaterializedViewStatementContext() {}

func NewAlterMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_alterMaterializedViewStatement

	return p
}

func (s *AlterMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementContext) GetName() IColumnFamilyNameContext { return s.name }

func (s *AlterMaterializedViewStatementContext) SetName(v IColumnFamilyNameContext) { s.name = v }

func (s *AlterMaterializedViewStatementContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ALTER, 0)
}

func (s *AlterMaterializedViewStatementContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MATERIALIZED, 0)
}

func (s *AlterMaterializedViewStatementContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VIEW, 0)
}

func (s *AlterMaterializedViewStatementContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *AlterMaterializedViewStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterMaterializedViewStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *AlterMaterializedViewStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAlterMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) AlterMaterializedViewStatement() (localctx IAlterMaterializedViewStatementContext) {
	localctx = NewAlterMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Cql3ParserRULE_alterMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Match(Cql3ParserK_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)
		p.Match(Cql3ParserK_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(792)
		p.Match(Cql3ParserK_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(793)
			p.IfExists()
		}

	}
	{
		p.SetState(796)

		var _x = p.ColumnFamilyName()

		localctx.(*AlterMaterializedViewStatementContext).name = _x
	}
	{
		p.SetState(797)
		p.Match(Cql3ParserK_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(798)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropKeyspaceStatementContext is an interface to support dynamic dispatch.
type IDropKeyspaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() IKeyspaceNameContext

	// SetKs sets the ks rule contexts.
	SetKs(IKeyspaceNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_KEYSPACE() antlr.TerminalNode
	KeyspaceName() IKeyspaceNameContext
	IfExists() IIfExistsContext

	// IsDropKeyspaceStatementContext differentiates from other interfaces.
	IsDropKeyspaceStatementContext()
}

type DropKeyspaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     IKeyspaceNameContext
}

func NewEmptyDropKeyspaceStatementContext() *DropKeyspaceStatementContext {
	var p = new(DropKeyspaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropKeyspaceStatement
	return p
}

func InitEmptyDropKeyspaceStatementContext(p *DropKeyspaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropKeyspaceStatement
}

func (*DropKeyspaceStatementContext) IsDropKeyspaceStatementContext() {}

func NewDropKeyspaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropKeyspaceStatementContext {
	var p = new(DropKeyspaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropKeyspaceStatement

	return p
}

func (s *DropKeyspaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropKeyspaceStatementContext) GetKs() IKeyspaceNameContext { return s.ks }

func (s *DropKeyspaceStatementContext) SetKs(v IKeyspaceNameContext) { s.ks = v }

func (s *DropKeyspaceStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropKeyspaceStatementContext) K_KEYSPACE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEYSPACE, 0)
}

func (s *DropKeyspaceStatementContext) KeyspaceName() IKeyspaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceNameContext)
}

func (s *DropKeyspaceStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropKeyspaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropKeyspaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropKeyspaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropKeyspaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropKeyspaceStatement() (localctx IDropKeyspaceStatementContext) {
	localctx = NewDropKeyspaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Cql3ParserRULE_dropKeyspaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(801)
		p.Match(Cql3ParserK_KEYSPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(802)
			p.IfExists()
		}

	}
	{
		p.SetState(805)

		var _x = p.KeyspaceName()

		localctx.(*DropKeyspaceStatementContext).ks = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IColumnFamilyNameContext

	// SetName sets the name rule contexts.
	SetName(IColumnFamilyNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_COLUMNFAMILY() antlr.TerminalNode
	ColumnFamilyName() IColumnFamilyNameContext
	IfExists() IIfExistsContext

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IColumnFamilyNameContext
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) GetName() IColumnFamilyNameContext { return s.name }

func (s *DropTableStatementContext) SetName(v IColumnFamilyNameContext) { s.name = v }

func (s *DropTableStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropTableStatementContext) K_COLUMNFAMILY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COLUMNFAMILY, 0)
}

func (s *DropTableStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *DropTableStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Cql3ParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(808)
		p.Match(Cql3ParserK_COLUMNFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(809)
			p.IfExists()
		}

	}
	{
		p.SetState(812)

		var _x = p.ColumnFamilyName()

		localctx.(*DropTableStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTypeStatementContext is an interface to support dynamic dispatch.
type IDropTypeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IUserTypeNameContext

	// SetName sets the name rule contexts.
	SetName(IUserTypeNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_TYPE() antlr.TerminalNode
	UserTypeName() IUserTypeNameContext
	IfExists() IIfExistsContext

	// IsDropTypeStatementContext differentiates from other interfaces.
	IsDropTypeStatementContext()
}

type DropTypeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IUserTypeNameContext
}

func NewEmptyDropTypeStatementContext() *DropTypeStatementContext {
	var p = new(DropTypeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTypeStatement
	return p
}

func InitEmptyDropTypeStatementContext(p *DropTypeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropTypeStatement
}

func (*DropTypeStatementContext) IsDropTypeStatementContext() {}

func NewDropTypeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTypeStatementContext {
	var p = new(DropTypeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropTypeStatement

	return p
}

func (s *DropTypeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTypeStatementContext) GetName() IUserTypeNameContext { return s.name }

func (s *DropTypeStatementContext) SetName(v IUserTypeNameContext) { s.name = v }

func (s *DropTypeStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropTypeStatementContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TYPE, 0)
}

func (s *DropTypeStatementContext) UserTypeName() IUserTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeNameContext)
}

func (s *DropTypeStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTypeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTypeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropTypeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropTypeStatement() (localctx IDropTypeStatementContext) {
	localctx = NewDropTypeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Cql3ParserRULE_dropTypeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(815)
		p.Match(Cql3ParserK_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(816)
			p.IfExists()
		}

	}
	{
		p.SetState(819)

		var _x = p.UserTypeName()

		localctx.(*DropTypeStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexStatementContext is an interface to support dynamic dispatch.
type IDropIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndex returns the index rule contexts.
	GetIndex() IIndexNameContext

	// SetIndex sets the index rule contexts.
	SetIndex(IIndexNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_INDEX() antlr.TerminalNode
	IndexName() IIndexNameContext
	IfExists() IIfExistsContext

	// IsDropIndexStatementContext differentiates from other interfaces.
	IsDropIndexStatementContext()
}

type DropIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	index  IIndexNameContext
}

func NewEmptyDropIndexStatementContext() *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropIndexStatement
	return p
}

func InitEmptyDropIndexStatementContext(p *DropIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropIndexStatement
}

func (*DropIndexStatementContext) IsDropIndexStatementContext() {}

func NewDropIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropIndexStatement

	return p
}

func (s *DropIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexStatementContext) GetIndex() IIndexNameContext { return s.index }

func (s *DropIndexStatementContext) SetIndex(v IIndexNameContext) { s.index = v }

func (s *DropIndexStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropIndexStatementContext) K_INDEX() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INDEX, 0)
}

func (s *DropIndexStatementContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DropIndexStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropIndexStatement() (localctx IDropIndexStatementContext) {
	localctx = NewDropIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Cql3ParserRULE_dropIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(822)
		p.Match(Cql3ParserK_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(823)
			p.IfExists()
		}

	}
	{
		p.SetState(826)

		var _x = p.IndexName()

		localctx.(*DropIndexStatementContext).index = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_MATERIALIZED() antlr.TerminalNode
	K_VIEW() antlr.TerminalNode
	ColumnFamilyName() IColumnFamilyNameContext
	IfExists() IIfExistsContext

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cf     IColumnFamilyNameContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *DropMaterializedViewStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *DropMaterializedViewStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropMaterializedViewStatementContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VIEW, 0)
}

func (s *DropMaterializedViewStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *DropMaterializedViewStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Cql3ParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(829)
		p.Match(Cql3ParserK_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(830)
		p.Match(Cql3ParserK_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(831)
			p.IfExists()
		}

	}
	{
		p.SetState(834)

		var _x = p.ColumnFamilyName()

		localctx.(*DropMaterializedViewStatementContext).cf = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateStatementContext is an interface to support dynamic dispatch.
type ITruncateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCf returns the cf rule contexts.
	GetCf() IColumnFamilyNameContext

	// SetCf sets the cf rule contexts.
	SetCf(IColumnFamilyNameContext)

	// Getter signatures
	K_TRUNCATE() antlr.TerminalNode
	ColumnFamilyName() IColumnFamilyNameContext
	K_COLUMNFAMILY() antlr.TerminalNode

	// IsTruncateStatementContext differentiates from other interfaces.
	IsTruncateStatementContext()
}

type TruncateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cf     IColumnFamilyNameContext
}

func NewEmptyTruncateStatementContext() *TruncateStatementContext {
	var p = new(TruncateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_truncateStatement
	return p
}

func InitEmptyTruncateStatementContext(p *TruncateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_truncateStatement
}

func (*TruncateStatementContext) IsTruncateStatementContext() {}

func NewTruncateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateStatementContext {
	var p = new(TruncateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_truncateStatement

	return p
}

func (s *TruncateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateStatementContext) GetCf() IColumnFamilyNameContext { return s.cf }

func (s *TruncateStatementContext) SetCf(v IColumnFamilyNameContext) { s.cf = v }

func (s *TruncateStatementContext) K_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TRUNCATE, 0)
}

func (s *TruncateStatementContext) ColumnFamilyName() IColumnFamilyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFamilyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFamilyNameContext)
}

func (s *TruncateStatementContext) K_COLUMNFAMILY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COLUMNFAMILY, 0)
}

func (s *TruncateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTruncateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TruncateStatement() (localctx ITruncateStatementContext) {
	localctx = NewTruncateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Cql3ParserRULE_truncateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		p.Match(Cql3ParserK_TRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_COLUMNFAMILY {
		{
			p.SetState(837)
			p.Match(Cql3ParserK_COLUMNFAMILY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(840)

		var _x = p.ColumnFamilyName()

		localctx.(*TruncateStatementContext).cf = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRoleStatementContext is an interface to support dynamic dispatch.
type IGrantRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRole returns the role rule contexts.
	GetRole() IUserOrRoleNameContext

	// GetGrantee returns the grantee rule contexts.
	GetGrantee() IUserOrRoleNameContext

	// SetRole sets the role rule contexts.
	SetRole(IUserOrRoleNameContext)

	// SetGrantee sets the grantee rule contexts.
	SetGrantee(IUserOrRoleNameContext)

	// Getter signatures
	K_GRANT() antlr.TerminalNode
	K_TO() antlr.TerminalNode
	AllUserOrRoleName() []IUserOrRoleNameContext
	UserOrRoleName(i int) IUserOrRoleNameContext

	// IsGrantRoleStatementContext differentiates from other interfaces.
	IsGrantRoleStatementContext()
}

type GrantRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	role    IUserOrRoleNameContext
	grantee IUserOrRoleNameContext
}

func NewEmptyGrantRoleStatementContext() *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_grantRoleStatement
	return p
}

func InitEmptyGrantRoleStatementContext(p *GrantRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_grantRoleStatement
}

func (*GrantRoleStatementContext) IsGrantRoleStatementContext() {}

func NewGrantRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_grantRoleStatement

	return p
}

func (s *GrantRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleStatementContext) GetRole() IUserOrRoleNameContext { return s.role }

func (s *GrantRoleStatementContext) GetGrantee() IUserOrRoleNameContext { return s.grantee }

func (s *GrantRoleStatementContext) SetRole(v IUserOrRoleNameContext) { s.role = v }

func (s *GrantRoleStatementContext) SetGrantee(v IUserOrRoleNameContext) { s.grantee = v }

func (s *GrantRoleStatementContext) K_GRANT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_GRANT, 0)
}

func (s *GrantRoleStatementContext) K_TO() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TO, 0)
}

func (s *GrantRoleStatementContext) AllUserOrRoleName() []IUserOrRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserOrRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IUserOrRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserOrRoleNameContext); ok {
			tst[i] = t.(IUserOrRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantRoleStatementContext) UserOrRoleName(i int) IUserOrRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserOrRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserOrRoleNameContext)
}

func (s *GrantRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitGrantRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) GrantRoleStatement() (localctx IGrantRoleStatementContext) {
	localctx = NewGrantRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Cql3ParserRULE_grantRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(Cql3ParserK_GRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(843)

		var _x = p.UserOrRoleName()

		localctx.(*GrantRoleStatementContext).role = _x
	}
	{
		p.SetState(844)
		p.Match(Cql3ParserK_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)

		var _x = p.UserOrRoleName()

		localctx.(*GrantRoleStatementContext).grantee = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeRoleStatementContext is an interface to support dynamic dispatch.
type IRevokeRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRole returns the role rule contexts.
	GetRole() IUserOrRoleNameContext

	// GetRevokee returns the revokee rule contexts.
	GetRevokee() IUserOrRoleNameContext

	// SetRole sets the role rule contexts.
	SetRole(IUserOrRoleNameContext)

	// SetRevokee sets the revokee rule contexts.
	SetRevokee(IUserOrRoleNameContext)

	// Getter signatures
	K_REVOKE() antlr.TerminalNode
	K_FROM() antlr.TerminalNode
	AllUserOrRoleName() []IUserOrRoleNameContext
	UserOrRoleName(i int) IUserOrRoleNameContext

	// IsRevokeRoleStatementContext differentiates from other interfaces.
	IsRevokeRoleStatementContext()
}

type RevokeRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	role    IUserOrRoleNameContext
	revokee IUserOrRoleNameContext
}

func NewEmptyRevokeRoleStatementContext() *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_revokeRoleStatement
	return p
}

func InitEmptyRevokeRoleStatementContext(p *RevokeRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_revokeRoleStatement
}

func (*RevokeRoleStatementContext) IsRevokeRoleStatementContext() {}

func NewRevokeRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_revokeRoleStatement

	return p
}

func (s *RevokeRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleStatementContext) GetRole() IUserOrRoleNameContext { return s.role }

func (s *RevokeRoleStatementContext) GetRevokee() IUserOrRoleNameContext { return s.revokee }

func (s *RevokeRoleStatementContext) SetRole(v IUserOrRoleNameContext) { s.role = v }

func (s *RevokeRoleStatementContext) SetRevokee(v IUserOrRoleNameContext) { s.revokee = v }

func (s *RevokeRoleStatementContext) K_REVOKE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_REVOKE, 0)
}

func (s *RevokeRoleStatementContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FROM, 0)
}

func (s *RevokeRoleStatementContext) AllUserOrRoleName() []IUserOrRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserOrRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IUserOrRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserOrRoleNameContext); ok {
			tst[i] = t.(IUserOrRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *RevokeRoleStatementContext) UserOrRoleName(i int) IUserOrRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserOrRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserOrRoleNameContext)
}

func (s *RevokeRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRevokeRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) RevokeRoleStatement() (localctx IRevokeRoleStatementContext) {
	localctx = NewRevokeRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Cql3ParserRULE_revokeRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Match(Cql3ParserK_REVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(848)

		var _x = p.UserOrRoleName()

		localctx.(*RevokeRoleStatementContext).role = _x
	}
	{
		p.SetState(849)
		p.Match(Cql3ParserK_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(850)

		var _x = p.UserOrRoleName()

		localctx.(*RevokeRoleStatementContext).revokee = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserStatementContext is an interface to support dynamic dispatch.
type ICreateUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IUsernameContext

	// SetU sets the u rule contexts.
	SetU(IUsernameContext)

	// Getter signatures
	K_CREATE() antlr.TerminalNode
	K_USER() antlr.TerminalNode
	Username() IUsernameContext
	IfNotExists() IIfNotExistsContext
	K_WITH() antlr.TerminalNode
	UserPassword() IUserPasswordContext
	K_SUPERUSER() antlr.TerminalNode
	K_NOSUPERUSER() antlr.TerminalNode

	// IsCreateUserStatementContext differentiates from other interfaces.
	IsCreateUserStatementContext()
}

type CreateUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IUsernameContext
}

func NewEmptyCreateUserStatementContext() *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createUserStatement
	return p
}

func InitEmptyCreateUserStatementContext(p *CreateUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_createUserStatement
}

func (*CreateUserStatementContext) IsCreateUserStatementContext() {}

func NewCreateUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_createUserStatement

	return p
}

func (s *CreateUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserStatementContext) GetU() IUsernameContext { return s.u }

func (s *CreateUserStatementContext) SetU(v IUsernameContext) { s.u = v }

func (s *CreateUserStatementContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CREATE, 0)
}

func (s *CreateUserStatementContext) K_USER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USER, 0)
}

func (s *CreateUserStatementContext) Username() IUsernameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsernameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsernameContext)
}

func (s *CreateUserStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserStatementContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *CreateUserStatementContext) UserPassword() IUserPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordContext)
}

func (s *CreateUserStatementContext) K_SUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SUPERUSER, 0)
}

func (s *CreateUserStatementContext) K_NOSUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOSUPERUSER, 0)
}

func (s *CreateUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCreateUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CreateUserStatement() (localctx ICreateUserStatementContext) {
	localctx = NewCreateUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Cql3ParserRULE_createUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(Cql3ParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(853)
		p.Match(Cql3ParserK_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(854)
			p.IfNotExists()
		}

	}
	{
		p.SetState(857)

		var _x = p.Username()

		localctx.(*CreateUserStatementContext).u = _x
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_WITH {
		{
			p.SetState(858)
			p.Match(Cql3ParserK_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(859)
			p.UserPassword()
		}

	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_SUPERUSER || _la == Cql3ParserK_NOSUPERUSER {
		{
			p.SetState(862)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cql3ParserK_SUPERUSER || _la == Cql3ParserK_NOSUPERUSER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserStatementContext is an interface to support dynamic dispatch.
type IAlterUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IUsernameContext

	// SetU sets the u rule contexts.
	SetU(IUsernameContext)

	// Getter signatures
	K_ALTER() antlr.TerminalNode
	K_USER() antlr.TerminalNode
	Username() IUsernameContext
	IfExists() IIfExistsContext
	K_WITH() antlr.TerminalNode
	UserPassword() IUserPasswordContext
	K_SUPERUSER() antlr.TerminalNode
	K_NOSUPERUSER() antlr.TerminalNode

	// IsAlterUserStatementContext differentiates from other interfaces.
	IsAlterUserStatementContext()
}

type AlterUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IUsernameContext
}

func NewEmptyAlterUserStatementContext() *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterUserStatement
	return p
}

func InitEmptyAlterUserStatementContext(p *AlterUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_alterUserStatement
}

func (*AlterUserStatementContext) IsAlterUserStatementContext() {}

func NewAlterUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_alterUserStatement

	return p
}

func (s *AlterUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserStatementContext) GetU() IUsernameContext { return s.u }

func (s *AlterUserStatementContext) SetU(v IUsernameContext) { s.u = v }

func (s *AlterUserStatementContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ALTER, 0)
}

func (s *AlterUserStatementContext) K_USER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USER, 0)
}

func (s *AlterUserStatementContext) Username() IUsernameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsernameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsernameContext)
}

func (s *AlterUserStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserStatementContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WITH, 0)
}

func (s *AlterUserStatementContext) UserPassword() IUserPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordContext)
}

func (s *AlterUserStatementContext) K_SUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SUPERUSER, 0)
}

func (s *AlterUserStatementContext) K_NOSUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOSUPERUSER, 0)
}

func (s *AlterUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAlterUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) AlterUserStatement() (localctx IAlterUserStatementContext) {
	localctx = NewAlterUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Cql3ParserRULE_alterUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(Cql3ParserK_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(866)
		p.Match(Cql3ParserK_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(867)
			p.IfExists()
		}

	}
	{
		p.SetState(870)

		var _x = p.Username()

		localctx.(*AlterUserStatementContext).u = _x
	}
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_WITH {
		{
			p.SetState(871)
			p.Match(Cql3ParserK_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.UserPassword()
		}

	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_SUPERUSER || _la == Cql3ParserK_NOSUPERUSER {
		{
			p.SetState(875)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cql3ParserK_SUPERUSER || _la == Cql3ParserK_NOSUPERUSER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserStatementContext is an interface to support dynamic dispatch.
type IDropUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IUsernameContext

	// SetU sets the u rule contexts.
	SetU(IUsernameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_USER() antlr.TerminalNode
	Username() IUsernameContext
	IfExists() IIfExistsContext

	// IsDropUserStatementContext differentiates from other interfaces.
	IsDropUserStatementContext()
}

type DropUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IUsernameContext
}

func NewEmptyDropUserStatementContext() *DropUserStatementContext {
	var p = new(DropUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropUserStatement
	return p
}

func InitEmptyDropUserStatementContext(p *DropUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropUserStatement
}

func (*DropUserStatementContext) IsDropUserStatementContext() {}

func NewDropUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserStatementContext {
	var p = new(DropUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropUserStatement

	return p
}

func (s *DropUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserStatementContext) GetU() IUsernameContext { return s.u }

func (s *DropUserStatementContext) SetU(v IUsernameContext) { s.u = v }

func (s *DropUserStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropUserStatementContext) K_USER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USER, 0)
}

func (s *DropUserStatementContext) Username() IUsernameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsernameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsernameContext)
}

func (s *DropUserStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropUserStatement() (localctx IDropUserStatementContext) {
	localctx = NewDropUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Cql3ParserRULE_dropUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(879)
		p.Match(Cql3ParserK_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(880)
			p.IfExists()
		}

	}
	{
		p.SetState(883)

		var _x = p.Username()

		localctx.(*DropUserStatementContext).u = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddIdentityStatementContext is an interface to support dynamic dispatch.
type IAddIdentityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IIdentityContext

	// GetR returns the r rule contexts.
	GetR() IIdentityContext

	// SetU sets the u rule contexts.
	SetU(IIdentityContext)

	// SetR sets the r rule contexts.
	SetR(IIdentityContext)

	// Getter signatures
	K_ADD() antlr.TerminalNode
	K_IDENTITY() antlr.TerminalNode
	K_TO() antlr.TerminalNode
	K_ROLE() antlr.TerminalNode
	AllIdentity() []IIdentityContext
	Identity(i int) IIdentityContext
	IfNotExists() IIfNotExistsContext

	// IsAddIdentityStatementContext differentiates from other interfaces.
	IsAddIdentityStatementContext()
}

type AddIdentityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IIdentityContext
	r      IIdentityContext
}

func NewEmptyAddIdentityStatementContext() *AddIdentityStatementContext {
	var p = new(AddIdentityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_addIdentityStatement
	return p
}

func InitEmptyAddIdentityStatementContext(p *AddIdentityStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_addIdentityStatement
}

func (*AddIdentityStatementContext) IsAddIdentityStatementContext() {}

func NewAddIdentityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddIdentityStatementContext {
	var p = new(AddIdentityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_addIdentityStatement

	return p
}

func (s *AddIdentityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddIdentityStatementContext) GetU() IIdentityContext { return s.u }

func (s *AddIdentityStatementContext) GetR() IIdentityContext { return s.r }

func (s *AddIdentityStatementContext) SetU(v IIdentityContext) { s.u = v }

func (s *AddIdentityStatementContext) SetR(v IIdentityContext) { s.r = v }

func (s *AddIdentityStatementContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ADD, 0)
}

func (s *AddIdentityStatementContext) K_IDENTITY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IDENTITY, 0)
}

func (s *AddIdentityStatementContext) K_TO() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TO, 0)
}

func (s *AddIdentityStatementContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ROLE, 0)
}

func (s *AddIdentityStatementContext) AllIdentity() []IIdentityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentityContext); ok {
			len++
		}
	}

	tst := make([]IIdentityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentityContext); ok {
			tst[i] = t.(IIdentityContext)
			i++
		}
	}

	return tst
}

func (s *AddIdentityStatementContext) Identity(i int) IIdentityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityContext)
}

func (s *AddIdentityStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AddIdentityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddIdentityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddIdentityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAddIdentityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) AddIdentityStatement() (localctx IAddIdentityStatementContext) {
	localctx = NewAddIdentityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Cql3ParserRULE_addIdentityStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Match(Cql3ParserK_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(886)
		p.Match(Cql3ParserK_IDENTITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(887)
			p.IfNotExists()
		}

	}
	{
		p.SetState(890)

		var _x = p.Identity()

		localctx.(*AddIdentityStatementContext).u = _x
	}
	{
		p.SetState(891)
		p.Match(Cql3ParserK_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(892)
		p.Match(Cql3ParserK_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(893)

		var _x = p.Identity()

		localctx.(*AddIdentityStatementContext).r = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIdentityStatementContext is an interface to support dynamic dispatch.
type IDropIdentityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IIdentityContext

	// SetU sets the u rule contexts.
	SetU(IIdentityContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_IDENTITY() antlr.TerminalNode
	Identity() IIdentityContext
	IfExists() IIfExistsContext

	// IsDropIdentityStatementContext differentiates from other interfaces.
	IsDropIdentityStatementContext()
}

type DropIdentityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IIdentityContext
}

func NewEmptyDropIdentityStatementContext() *DropIdentityStatementContext {
	var p = new(DropIdentityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropIdentityStatement
	return p
}

func InitEmptyDropIdentityStatementContext(p *DropIdentityStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropIdentityStatement
}

func (*DropIdentityStatementContext) IsDropIdentityStatementContext() {}

func NewDropIdentityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIdentityStatementContext {
	var p = new(DropIdentityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropIdentityStatement

	return p
}

func (s *DropIdentityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIdentityStatementContext) GetU() IIdentityContext { return s.u }

func (s *DropIdentityStatementContext) SetU(v IIdentityContext) { s.u = v }

func (s *DropIdentityStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropIdentityStatementContext) K_IDENTITY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IDENTITY, 0)
}

func (s *DropIdentityStatementContext) Identity() IIdentityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityContext)
}

func (s *DropIdentityStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropIdentityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIdentityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIdentityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropIdentityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropIdentityStatement() (localctx IDropIdentityStatementContext) {
	localctx = NewDropIdentityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Cql3ParserRULE_dropIdentityStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(896)
		p.Match(Cql3ParserK_IDENTITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(897)
			p.IfExists()
		}

	}
	{
		p.SetState(900)

		var _x = p.Identity()

		localctx.(*DropIdentityStatementContext).u = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListUsersStatementContext is an interface to support dynamic dispatch.
type IListUsersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIST() antlr.TerminalNode
	K_USERS() antlr.TerminalNode

	// IsListUsersStatementContext differentiates from other interfaces.
	IsListUsersStatementContext()
}

type ListUsersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListUsersStatementContext() *ListUsersStatementContext {
	var p = new(ListUsersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listUsersStatement
	return p
}

func InitEmptyListUsersStatementContext(p *ListUsersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listUsersStatement
}

func (*ListUsersStatementContext) IsListUsersStatementContext() {}

func NewListUsersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListUsersStatementContext {
	var p = new(ListUsersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_listUsersStatement

	return p
}

func (s *ListUsersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ListUsersStatementContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIST, 0)
}

func (s *ListUsersStatementContext) K_USERS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USERS, 0)
}

func (s *ListUsersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListUsersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListUsersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitListUsersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ListUsersStatement() (localctx IListUsersStatementContext) {
	localctx = NewListUsersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Cql3ParserRULE_listUsersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(Cql3ParserK_LIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(903)
		p.Match(Cql3ParserK_USERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IUserOrRoleNameContext

	// SetName sets the name rule contexts.
	SetName(IUserOrRoleNameContext)

	// Getter signatures
	K_DROP() antlr.TerminalNode
	K_ROLE() antlr.TerminalNode
	UserOrRoleName() IUserOrRoleNameContext
	IfExists() IIfExistsContext

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IUserOrRoleNameContext
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) GetName() IUserOrRoleNameContext { return s.name }

func (s *DropRoleStatementContext) SetName(v IUserOrRoleNameContext) { s.name = v }

func (s *DropRoleStatementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DROP, 0)
}

func (s *DropRoleStatementContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ROLE, 0)
}

func (s *DropRoleStatementContext) UserOrRoleName() IUserOrRoleNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserOrRoleNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserOrRoleNameContext)
}

func (s *DropRoleStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitDropRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Cql3ParserRULE_dropRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Match(Cql3ParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(906)
		p.Match(Cql3ParserK_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_IF {
		{
			p.SetState(907)
			p.IfExists()
		}

	}
	{
		p.SetState(910)

		var _x = p.UserOrRoleName()

		localctx.(*DropRoleStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListRolesStatementContext is an interface to support dynamic dispatch.
type IListRolesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIST() antlr.TerminalNode
	K_ROLES() antlr.TerminalNode
	K_OF() antlr.TerminalNode
	RoleName() IRoleNameContext
	K_NORECURSIVE() antlr.TerminalNode

	// IsListRolesStatementContext differentiates from other interfaces.
	IsListRolesStatementContext()
}

type ListRolesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListRolesStatementContext() *ListRolesStatementContext {
	var p = new(ListRolesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listRolesStatement
	return p
}

func InitEmptyListRolesStatementContext(p *ListRolesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listRolesStatement
}

func (*ListRolesStatementContext) IsListRolesStatementContext() {}

func NewListRolesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListRolesStatementContext {
	var p = new(ListRolesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_listRolesStatement

	return p
}

func (s *ListRolesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ListRolesStatementContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIST, 0)
}

func (s *ListRolesStatementContext) K_ROLES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ROLES, 0)
}

func (s *ListRolesStatementContext) K_OF() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_OF, 0)
}

func (s *ListRolesStatementContext) RoleName() IRoleNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *ListRolesStatementContext) K_NORECURSIVE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NORECURSIVE, 0)
}

func (s *ListRolesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListRolesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListRolesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitListRolesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ListRolesStatement() (localctx IListRolesStatementContext) {
	localctx = NewListRolesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Cql3ParserRULE_listRolesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Match(Cql3ParserK_LIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(913)
		p.Match(Cql3ParserK_ROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_OF {
		{
			p.SetState(914)
			p.Match(Cql3ParserK_OF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)
			p.RoleName()
		}

	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Cql3ParserK_NORECURSIVE {
		{
			p.SetState(918)
			p.Match(Cql3ParserK_NORECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListSuperUsersStatementContext is an interface to support dynamic dispatch.
type IListSuperUsersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIST() antlr.TerminalNode
	K_SUPERUSERS() antlr.TerminalNode

	// IsListSuperUsersStatementContext differentiates from other interfaces.
	IsListSuperUsersStatementContext()
}

type ListSuperUsersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListSuperUsersStatementContext() *ListSuperUsersStatementContext {
	var p = new(ListSuperUsersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listSuperUsersStatement
	return p
}

func InitEmptyListSuperUsersStatementContext(p *ListSuperUsersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listSuperUsersStatement
}

func (*ListSuperUsersStatementContext) IsListSuperUsersStatementContext() {}

func NewListSuperUsersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListSuperUsersStatementContext {
	var p = new(ListSuperUsersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_listSuperUsersStatement

	return p
}

func (s *ListSuperUsersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ListSuperUsersStatementContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIST, 0)
}

func (s *ListSuperUsersStatementContext) K_SUPERUSERS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SUPERUSERS, 0)
}

func (s *ListSuperUsersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListSuperUsersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListSuperUsersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitListSuperUsersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ListSuperUsersStatement() (localctx IListSuperUsersStatementContext) {
	localctx = NewListSuperUsersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Cql3ParserRULE_listSuperUsersStatement)

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Match(Cql3ParserK_LIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(922)
		p.Match(Cql3ParserK_SUPERUSERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPasswordContext is an interface to support dynamic dispatch.
type IUserPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetV returns the v token.
	GetV() antlr.Token

	// SetV sets the v token.
	SetV(antlr.Token)

	// Getter signatures
	K_PASSWORD() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	K_HASHED() antlr.TerminalNode
	K_GENERATED() antlr.TerminalNode

	// IsUserPasswordContext differentiates from other interfaces.
	IsUserPasswordContext()
}

type UserPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	v      antlr.Token
}

func NewEmptyUserPasswordContext() *UserPasswordContext {
	var p = new(UserPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userPassword
	return p
}

func InitEmptyUserPasswordContext(p *UserPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userPassword
}

func (*UserPasswordContext) IsUserPasswordContext() {}

func NewUserPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordContext {
	var p = new(UserPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_userPassword

	return p
}

func (s *UserPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordContext) GetV() antlr.Token { return s.v }

func (s *UserPasswordContext) SetV(v antlr.Token) { s.v = v }

func (s *UserPasswordContext) K_PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PASSWORD, 0)
}

func (s *UserPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *UserPasswordContext) K_HASHED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_HASHED, 0)
}

func (s *UserPasswordContext) K_GENERATED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_GENERATED, 0)
}

func (s *UserPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUserPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UserPassword() (localctx IUserPasswordContext) {
	localctx = NewUserPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Cql3ParserRULE_userPassword)
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_PASSWORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(924)
			p.Match(Cql3ParserK_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(925)

			var _m = p.Match(Cql3ParserSTRING_LITERAL)

			localctx.(*UserPasswordContext).v = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_HASHED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(926)
			p.Match(Cql3ParserK_HASHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(927)
			p.Match(Cql3ParserK_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(928)

			var _m = p.Match(Cql3ParserSTRING_LITERAL)

			localctx.(*UserPasswordContext).v = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_GENERATED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(929)
			p.Match(Cql3ParserK_GENERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.Match(Cql3ParserK_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICidentContext is an interface to support dynamic dispatch.
type ICidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() IIdentContext

	// SetT sets the t rule contexts.
	SetT(IIdentContext)

	// Getter signatures
	EMPTY_QUOTED_NAME() antlr.TerminalNode
	Ident() IIdentContext

	// IsCidentContext differentiates from other interfaces.
	IsCidentContext()
}

type CidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      IIdentContext
}

func NewEmptyCidentContext() *CidentContext {
	var p = new(CidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cident
	return p
}

func InitEmptyCidentContext(p *CidentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cident
}

func (*CidentContext) IsCidentContext() {}

func NewCidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CidentContext {
	var p = new(CidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_cident

	return p
}

func (s *CidentContext) GetParser() antlr.Parser { return s.parser }

func (s *CidentContext) GetT() IIdentContext { return s.t }

func (s *CidentContext) SetT(v IIdentContext) { s.t = v }

func (s *CidentContext) EMPTY_QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserEMPTY_QUOTED_NAME, 0)
}

func (s *CidentContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *CidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CidentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCident(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Cident() (localctx ICidentContext) {
	localctx = NewCidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Cql3ParserRULE_cident)
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserEMPTY_QUOTED_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(933)
			p.Match(Cql3ParserEMPTY_QUOTED_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserQUOTED_NAME, Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(934)

			var _x = p.Ident()

			localctx.(*CidentContext).t = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ident
	return p
}

func InitEmptyIdentContext(p *IdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ident
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) CopyAll(ctx *IdentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IdentQuotedIdentContext struct {
	IdentContext
	t antlr.Token
}

func NewIdentQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentQuotedIdentContext {
	var p = new(IdentQuotedIdentContext)

	InitEmptyIdentContext(&p.IdentContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentContext))

	return p
}

func (s *IdentQuotedIdentContext) GetT() antlr.Token { return s.t }

func (s *IdentQuotedIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *IdentQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *IdentQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIdentQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentIdentContext struct {
	IdentContext
	t antlr.Token
	k IUnreserved_keywordContext
}

func NewIdentIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentIdentContext {
	var p = new(IdentIdentContext)

	InitEmptyIdentContext(&p.IdentContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentContext))

	return p
}

func (s *IdentIdentContext) GetT() antlr.Token { return s.t }

func (s *IdentIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *IdentIdentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *IdentIdentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *IdentIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *IdentIdentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *IdentIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIdentIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Ident() (localctx IIdentContext) {
	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Cql3ParserRULE_ident)
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewIdentIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(937)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*IdentIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewIdentQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(938)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*IdentQuotedIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewIdentIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(939)

			var _x = p.Unreserved_keyword()

			localctx.(*IdentIdentContext).k = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFidentContext is an interface to support dynamic dispatch.
type IFidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFidentContext differentiates from other interfaces.
	IsFidentContext()
}

type FidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFidentContext() *FidentContext {
	var p = new(FidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_fident
	return p
}

func InitEmptyFidentContext(p *FidentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_fident
}

func (*FidentContext) IsFidentContext() {}

func NewFidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FidentContext {
	var p = new(FidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_fident

	return p
}

func (s *FidentContext) GetParser() antlr.Parser { return s.parser }

func (s *FidentContext) CopyAll(ctx *FidentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FIdentQuotedIdentContext struct {
	FidentContext
	t antlr.Token
}

func NewFIdentQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FIdentQuotedIdentContext {
	var p = new(FIdentQuotedIdentContext)

	InitEmptyFidentContext(&p.FidentContext)
	p.parser = parser
	p.CopyAll(ctx.(*FidentContext))

	return p
}

func (s *FIdentQuotedIdentContext) GetT() antlr.Token { return s.t }

func (s *FIdentQuotedIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *FIdentQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FIdentQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *FIdentQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFIdentQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type FIdentIdentContext struct {
	FidentContext
	t antlr.Token
	k IUnreserved_keywordContext
}

func NewFIdentIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FIdentIdentContext {
	var p = new(FIdentIdentContext)

	InitEmptyFidentContext(&p.FidentContext)
	p.parser = parser
	p.CopyAll(ctx.(*FidentContext))

	return p
}

func (s *FIdentIdentContext) GetT() antlr.Token { return s.t }

func (s *FIdentIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *FIdentIdentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *FIdentIdentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *FIdentIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FIdentIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *FIdentIdentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *FIdentIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFIdentIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Fident() (localctx IFidentContext) {
	localctx = NewFidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Cql3ParserRULE_fident)
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewFIdentIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*FIdentIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewFIdentQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(943)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*FIdentQuotedIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewFIdentIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)

			var _x = p.Unreserved_keyword()

			localctx.(*FIdentIdentContext).k = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoncol_identContext is an interface to support dynamic dispatch.
type INoncol_identContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNoncol_identContext differentiates from other interfaces.
	IsNoncol_identContext()
}

type Noncol_identContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoncol_identContext() *Noncol_identContext {
	var p = new(Noncol_identContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_noncol_ident
	return p
}

func InitEmptyNoncol_identContext(p *Noncol_identContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_noncol_ident
}

func (*Noncol_identContext) IsNoncol_identContext() {}

func NewNoncol_identContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Noncol_identContext {
	var p = new(Noncol_identContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_noncol_ident

	return p
}

func (s *Noncol_identContext) GetParser() antlr.Parser { return s.parser }

func (s *Noncol_identContext) CopyAll(ctx *Noncol_identContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Noncol_identContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Noncol_identContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NonColIdentContext struct {
	Noncol_identContext
	i antlr.Token
	k IUnreserved_keywordContext
}

func NewNonColIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonColIdentContext {
	var p = new(NonColIdentContext)

	InitEmptyNoncol_identContext(&p.Noncol_identContext)
	p.parser = parser
	p.CopyAll(ctx.(*Noncol_identContext))

	return p
}

func (s *NonColIdentContext) GetI() antlr.Token { return s.i }

func (s *NonColIdentContext) SetI(v antlr.Token) { s.i = v }

func (s *NonColIdentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *NonColIdentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *NonColIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonColIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *NonColIdentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *NonColIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitNonColIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type NonColQuotedContext struct {
	Noncol_identContext
	t antlr.Token
}

func NewNonColQuotedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonColQuotedContext {
	var p = new(NonColQuotedContext)

	InitEmptyNoncol_identContext(&p.Noncol_identContext)
	p.parser = parser
	p.CopyAll(ctx.(*Noncol_identContext))

	return p
}

func (s *NonColQuotedContext) GetT() antlr.Token { return s.t }

func (s *NonColQuotedContext) SetT(v antlr.Token) { s.t = v }

func (s *NonColQuotedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonColQuotedContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *NonColQuotedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitNonColQuoted(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Noncol_ident() (localctx INoncol_identContext) {
	localctx = NewNoncol_identContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Cql3ParserRULE_noncol_ident)
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewNonColIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(947)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*NonColIdentContext).i = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewNonColQuotedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(948)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*NonColQuotedContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewNonColIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(949)

			var _x = p.Unreserved_keyword()

			localctx.(*NonColIdentContext).k = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyspaceNameContext is an interface to support dynamic dispatch.
type IKeyspaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KsName() IKsNameContext

	// IsKeyspaceNameContext differentiates from other interfaces.
	IsKeyspaceNameContext()
}

type KeyspaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyspaceNameContext() *KeyspaceNameContext {
	var p = new(KeyspaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_keyspaceName
	return p
}

func InitEmptyKeyspaceNameContext(p *KeyspaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_keyspaceName
}

func (*KeyspaceNameContext) IsKeyspaceNameContext() {}

func NewKeyspaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyspaceNameContext {
	var p = new(KeyspaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_keyspaceName

	return p
}

func (s *KeyspaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyspaceNameContext) KsName() IKsNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKsNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKsNameContext)
}

func (s *KeyspaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyspaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyspaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitKeyspaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) KeyspaceName() (localctx IKeyspaceNameContext) {
	localctx = NewKeyspaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Cql3ParserRULE_keyspaceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.KsName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdxName() IIdxNameContext
	KsName() IKsNameContext

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) IdxName() IIdxNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdxNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdxNameContext)
}

func (s *IndexNameContext) KsName() IKsNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKsNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKsNameContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Cql3ParserRULE_indexName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(957)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(954)
			p.KsName()
		}
		{
			p.SetState(955)
			p.Match(Cql3ParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(959)
		p.IdxName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnFamilyNameContext is an interface to support dynamic dispatch.
type IColumnFamilyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CfName() ICfNameContext
	KsName() IKsNameContext

	// IsColumnFamilyNameContext differentiates from other interfaces.
	IsColumnFamilyNameContext()
}

type ColumnFamilyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnFamilyNameContext() *ColumnFamilyNameContext {
	var p = new(ColumnFamilyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnFamilyName
	return p
}

func InitEmptyColumnFamilyNameContext(p *ColumnFamilyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_columnFamilyName
}

func (*ColumnFamilyNameContext) IsColumnFamilyNameContext() {}

func NewColumnFamilyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnFamilyNameContext {
	var p = new(ColumnFamilyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_columnFamilyName

	return p
}

func (s *ColumnFamilyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnFamilyNameContext) CfName() ICfNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfNameContext)
}

func (s *ColumnFamilyNameContext) KsName() IKsNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKsNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKsNameContext)
}

func (s *ColumnFamilyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnFamilyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnFamilyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitColumnFamilyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ColumnFamilyName() (localctx IColumnFamilyNameContext) {
	localctx = NewColumnFamilyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Cql3ParserRULE_columnFamilyName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(964)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(961)
			p.KsName()
		}
		{
			p.SetState(962)
			p.Match(Cql3ParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(966)
		p.CfName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserTypeNameContext is an interface to support dynamic dispatch.
type IUserTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() INoncol_identContext

	// GetUt returns the ut rule contexts.
	GetUt() INon_type_identContext

	// SetKs sets the ks rule contexts.
	SetKs(INoncol_identContext)

	// SetUt sets the ut rule contexts.
	SetUt(INon_type_identContext)

	// Getter signatures
	Non_type_ident() INon_type_identContext
	Noncol_ident() INoncol_identContext

	// IsUserTypeNameContext differentiates from other interfaces.
	IsUserTypeNameContext()
}

type UserTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     INoncol_identContext
	ut     INon_type_identContext
}

func NewEmptyUserTypeNameContext() *UserTypeNameContext {
	var p = new(UserTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userTypeName
	return p
}

func InitEmptyUserTypeNameContext(p *UserTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userTypeName
}

func (*UserTypeNameContext) IsUserTypeNameContext() {}

func NewUserTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserTypeNameContext {
	var p = new(UserTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_userTypeName

	return p
}

func (s *UserTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserTypeNameContext) GetKs() INoncol_identContext { return s.ks }

func (s *UserTypeNameContext) GetUt() INon_type_identContext { return s.ut }

func (s *UserTypeNameContext) SetKs(v INoncol_identContext) { s.ks = v }

func (s *UserTypeNameContext) SetUt(v INon_type_identContext) { s.ut = v }

func (s *UserTypeNameContext) Non_type_ident() INon_type_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INon_type_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INon_type_identContext)
}

func (s *UserTypeNameContext) Noncol_ident() INoncol_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoncol_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoncol_identContext)
}

func (s *UserTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserTypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUserTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UserTypeName() (localctx IUserTypeNameContext) {
	localctx = NewUserTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Cql3ParserRULE_userTypeName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(971)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(968)

			var _x = p.Noncol_ident()

			localctx.(*UserTypeNameContext).ks = _x
		}
		{
			p.SetState(969)
			p.Match(Cql3ParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(973)

		var _x = p.Non_type_ident()

		localctx.(*UserTypeNameContext).ut = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserOrRoleNameContext is an interface to support dynamic dispatch.
type IUserOrRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleName() IRoleNameContext

	// IsUserOrRoleNameContext differentiates from other interfaces.
	IsUserOrRoleNameContext()
}

type UserOrRoleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserOrRoleNameContext() *UserOrRoleNameContext {
	var p = new(UserOrRoleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userOrRoleName
	return p
}

func InitEmptyUserOrRoleNameContext(p *UserOrRoleNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_userOrRoleName
}

func (*UserOrRoleNameContext) IsUserOrRoleNameContext() {}

func NewUserOrRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserOrRoleNameContext {
	var p = new(UserOrRoleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_userOrRoleName

	return p
}

func (s *UserOrRoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserOrRoleNameContext) RoleName() IRoleNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *UserOrRoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserOrRoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserOrRoleNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUserOrRoleName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UserOrRoleName() (localctx IUserOrRoleNameContext) {
	localctx = NewUserOrRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Cql3ParserRULE_userOrRoleName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.RoleName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKsNameContext is an interface to support dynamic dispatch.
type IKsNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKsNameContext differentiates from other interfaces.
	IsKsNameContext()
}

type KsNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKsNameContext() *KsNameContext {
	var p = new(KsNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ksName
	return p
}

func InitEmptyKsNameContext(p *KsNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_ksName
}

func (*KsNameContext) IsKsNameContext() {}

func NewKsNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KsNameContext {
	var p = new(KsNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_ksName

	return p
}

func (s *KsNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KsNameContext) CopyAll(ctx *KsNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KsNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KsNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KsNameIdentContext struct {
	KsNameContext
	t antlr.Token
	k IUnreserved_keywordContext
}

func NewKsNameIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KsNameIdentContext {
	var p = new(KsNameIdentContext)

	InitEmptyKsNameContext(&p.KsNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*KsNameContext))

	return p
}

func (s *KsNameIdentContext) GetT() antlr.Token { return s.t }

func (s *KsNameIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *KsNameIdentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *KsNameIdentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *KsNameIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KsNameIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *KsNameIdentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *KsNameIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitKsNameIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type KsNameQuotedIdentContext struct {
	KsNameContext
	t antlr.Token
}

func NewKsNameQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KsNameQuotedIdentContext {
	var p = new(KsNameQuotedIdentContext)

	InitEmptyKsNameContext(&p.KsNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*KsNameContext))

	return p
}

func (s *KsNameQuotedIdentContext) GetT() antlr.Token { return s.t }

func (s *KsNameQuotedIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *KsNameQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KsNameQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *KsNameQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitKsNameQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type KsNameInvalidBindContext struct {
	KsNameContext
}

func NewKsNameInvalidBindContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KsNameInvalidBindContext {
	var p = new(KsNameInvalidBindContext)

	InitEmptyKsNameContext(&p.KsNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*KsNameContext))

	return p
}

func (s *KsNameInvalidBindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KsNameInvalidBindContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *KsNameInvalidBindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitKsNameInvalidBind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) KsName() (localctx IKsNameContext) {
	localctx = NewKsNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Cql3ParserRULE_ksName)
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewKsNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*KsNameIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewKsNameQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*KsNameQuotedIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewKsNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(979)

			var _x = p.Unreserved_keyword()

			localctx.(*KsNameIdentContext).k = _x
		}

	case Cql3ParserQMARK:
		localctx = NewKsNameInvalidBindContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(980)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICfNameContext is an interface to support dynamic dispatch.
type ICfNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCfNameContext differentiates from other interfaces.
	IsCfNameContext()
}

type CfNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCfNameContext() *CfNameContext {
	var p = new(CfNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cfName
	return p
}

func InitEmptyCfNameContext(p *CfNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_cfName
}

func (*CfNameContext) IsCfNameContext() {}

func NewCfNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CfNameContext {
	var p = new(CfNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_cfName

	return p
}

func (s *CfNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CfNameContext) CopyAll(ctx *CfNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CfNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CfNameIdentContext struct {
	CfNameContext
	t antlr.Token
	k IUnreserved_keywordContext
}

func NewCfNameIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CfNameIdentContext {
	var p = new(CfNameIdentContext)

	InitEmptyCfNameContext(&p.CfNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*CfNameContext))

	return p
}

func (s *CfNameIdentContext) GetT() antlr.Token { return s.t }

func (s *CfNameIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *CfNameIdentContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *CfNameIdentContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *CfNameIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfNameIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *CfNameIdentContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *CfNameIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCfNameIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type CfNameQuotedIdentContext struct {
	CfNameContext
	t antlr.Token
}

func NewCfNameQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CfNameQuotedIdentContext {
	var p = new(CfNameQuotedIdentContext)

	InitEmptyCfNameContext(&p.CfNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*CfNameContext))

	return p
}

func (s *CfNameQuotedIdentContext) GetT() antlr.Token { return s.t }

func (s *CfNameQuotedIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *CfNameQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfNameQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *CfNameQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCfNameQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type CfNameInvalidBindContext struct {
	CfNameContext
}

func NewCfNameInvalidBindContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CfNameInvalidBindContext {
	var p = new(CfNameInvalidBindContext)

	InitEmptyCfNameContext(&p.CfNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*CfNameContext))

	return p
}

func (s *CfNameInvalidBindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfNameInvalidBindContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *CfNameInvalidBindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCfNameInvalidBind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CfName() (localctx ICfNameContext) {
	localctx = NewCfNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Cql3ParserRULE_cfName)
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewCfNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(983)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*CfNameIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewCfNameQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(984)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*CfNameQuotedIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewCfNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(985)

			var _x = p.Unreserved_keyword()

			localctx.(*CfNameIdentContext).k = _x
		}

	case Cql3ParserQMARK:
		localctx = NewCfNameInvalidBindContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(986)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdxNameContext is an interface to support dynamic dispatch.
type IIdxNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// GetK returns the k rule contexts.
	GetK() IUnreserved_keywordContext

	// SetK sets the k rule contexts.
	SetK(IUnreserved_keywordContext)

	// Getter signatures
	IDENT() antlr.TerminalNode
	QUOTED_NAME() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext
	QMARK() antlr.TerminalNode

	// IsIdxNameContext differentiates from other interfaces.
	IsIdxNameContext()
}

type IdxNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
	k      IUnreserved_keywordContext
}

func NewEmptyIdxNameContext() *IdxNameContext {
	var p = new(IdxNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_idxName
	return p
}

func InitEmptyIdxNameContext(p *IdxNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_idxName
}

func (*IdxNameContext) IsIdxNameContext() {}

func NewIdxNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdxNameContext {
	var p = new(IdxNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_idxName

	return p
}

func (s *IdxNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdxNameContext) GetT() antlr.Token { return s.t }

func (s *IdxNameContext) SetT(v antlr.Token) { s.t = v }

func (s *IdxNameContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *IdxNameContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *IdxNameContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *IdxNameContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *IdxNameContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *IdxNameContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *IdxNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdxNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdxNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIdxName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) IdxName() (localctx IIdxNameContext) {
	localctx = NewIdxNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Cql3ParserRULE_idxName)
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(989)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*IdxNameContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(990)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*IdxNameContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(991)

			var _x = p.Unreserved_keyword()

			localctx.(*IdxNameContext).k = _x
		}

	case Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(992)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleNameContext is an interface to support dynamic dispatch.
type IRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// GetS returns the s token.
	GetS() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// SetS sets the s token.
	SetS(antlr.Token)

	// GetK returns the k rule contexts.
	GetK() IUnreserved_keywordContext

	// SetK sets the k rule contexts.
	SetK(IUnreserved_keywordContext)

	// Getter signatures
	IDENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	QUOTED_NAME() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext
	QMARK() antlr.TerminalNode

	// IsRoleNameContext differentiates from other interfaces.
	IsRoleNameContext()
}

type RoleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
	s      antlr.Token
	k      IUnreserved_keywordContext
}

func NewEmptyRoleNameContext() *RoleNameContext {
	var p = new(RoleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_roleName
	return p
}

func InitEmptyRoleNameContext(p *RoleNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_roleName
}

func (*RoleNameContext) IsRoleNameContext() {}

func NewRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleNameContext {
	var p = new(RoleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_roleName

	return p
}

func (s *RoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleNameContext) GetT() antlr.Token { return s.t }

func (s *RoleNameContext) GetS() antlr.Token { return s.s }

func (s *RoleNameContext) SetT(v antlr.Token) { s.t = v }

func (s *RoleNameContext) SetS(v antlr.Token) { s.s = v }

func (s *RoleNameContext) GetK() IUnreserved_keywordContext { return s.k }

func (s *RoleNameContext) SetK(v IUnreserved_keywordContext) { s.k = v }

func (s *RoleNameContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *RoleNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *RoleNameContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *RoleNameContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *RoleNameContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *RoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRoleName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) RoleName() (localctx IRoleNameContext) {
	localctx = NewRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Cql3ParserRULE_roleName)
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(995)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*RoleNameContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(996)

			var _m = p.Match(Cql3ParserSTRING_LITERAL)

			localctx.(*RoleNameContext).s = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(997)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*RoleNameContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(998)

			var _x = p.Unreserved_keyword()

			localctx.(*RoleNameContext).k = _x
		}

	case Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(999)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	DURATION() antlr.TerminalNode
	UUID() antlr.TerminalNode
	HEXNUMBER() antlr.TerminalNode
	K_POSITIVE_INFINITY() antlr.TerminalNode
	K_NEGATIVE_INFINITY() antlr.TerminalNode
	K_POSITIVE_NAN() antlr.TerminalNode
	K_NEGATIVE_NAN() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetT() antlr.Token { return s.t }

func (s *ConstantContext) SetT(v antlr.Token) { s.t = v }

func (s *ConstantContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *ConstantContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserINTEGER, 0)
}

func (s *ConstantContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserFLOAT, 0)
}

func (s *ConstantContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserBOOLEAN, 0)
}

func (s *ConstantContext) DURATION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserDURATION, 0)
}

func (s *ConstantContext) UUID() antlr.TerminalNode {
	return s.GetToken(Cql3ParserUUID, 0)
}

func (s *ConstantContext) HEXNUMBER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserHEXNUMBER, 0)
}

func (s *ConstantContext) K_POSITIVE_INFINITY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_POSITIVE_INFINITY, 0)
}

func (s *ConstantContext) K_NEGATIVE_INFINITY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NEGATIVE_INFINITY, 0)
}

func (s *ConstantContext) K_POSITIVE_NAN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_POSITIVE_NAN, 0)
}

func (s *ConstantContext) K_NEGATIVE_NAN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NEGATIVE_NAN, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Cql3ParserRULE_constant)
	var _la int

	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1002)

			var _m = p.Match(Cql3ParserSTRING_LITERAL)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserINTEGER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1003)

			var _m = p.Match(Cql3ParserINTEGER)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserFLOAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1004)

			var _m = p.Match(Cql3ParserFLOAT)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserBOOLEAN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1005)

			var _m = p.Match(Cql3ParserBOOLEAN)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserDURATION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1006)

			var _m = p.Match(Cql3ParserDURATION)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserUUID:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1007)

			var _m = p.Match(Cql3ParserUUID)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserHEXNUMBER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1008)

			var _m = p.Match(Cql3ParserHEXNUMBER)

			localctx.(*ConstantContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN, Cql3ParserK_POSITIVE_INFINITY, Cql3ParserK_NEGATIVE_INFINITY:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN:
			{
				p.SetState(1009)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cql3ParserK_POSITIVE_NAN || _la == Cql3ParserK_NEGATIVE_NAN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case Cql3ParserK_POSITIVE_INFINITY:
			{
				p.SetState(1010)
				p.Match(Cql3ParserK_POSITIVE_INFINITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cql3ParserK_NEGATIVE_INFINITY:
			{
				p.SetState(1011)
				p.Match(Cql3ParserK_NEGATIVE_INFINITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullMapLiteralContext is an interface to support dynamic dispatch.
type IFullMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK1 returns the k1 rule contexts.
	GetK1() ITermContext

	// GetV1 returns the v1 rule contexts.
	GetV1() ITermContext

	// GetKn returns the kn rule contexts.
	GetKn() ITermContext

	// GetVn returns the vn rule contexts.
	GetVn() ITermContext

	// SetK1 sets the k1 rule contexts.
	SetK1(ITermContext)

	// SetV1 sets the v1 rule contexts.
	SetV1(ITermContext)

	// SetKn sets the kn rule contexts.
	SetKn(ITermContext)

	// SetVn sets the vn rule contexts.
	SetVn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsFullMapLiteralContext differentiates from other interfaces.
	IsFullMapLiteralContext()
}

type FullMapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k1     ITermContext
	v1     ITermContext
	kn     ITermContext
	vn     ITermContext
}

func NewEmptyFullMapLiteralContext() *FullMapLiteralContext {
	var p = new(FullMapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_fullMapLiteral
	return p
}

func InitEmptyFullMapLiteralContext(p *FullMapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_fullMapLiteral
}

func (*FullMapLiteralContext) IsFullMapLiteralContext() {}

func NewFullMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullMapLiteralContext {
	var p = new(FullMapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_fullMapLiteral

	return p
}

func (s *FullMapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FullMapLiteralContext) GetK1() ITermContext { return s.k1 }

func (s *FullMapLiteralContext) GetV1() ITermContext { return s.v1 }

func (s *FullMapLiteralContext) GetKn() ITermContext { return s.kn }

func (s *FullMapLiteralContext) GetVn() ITermContext { return s.vn }

func (s *FullMapLiteralContext) SetK1(v ITermContext) { s.k1 = v }

func (s *FullMapLiteralContext) SetV1(v ITermContext) { s.v1 = v }

func (s *FullMapLiteralContext) SetKn(v ITermContext) { s.kn = v }

func (s *FullMapLiteralContext) SetVn(v ITermContext) { s.vn = v }

func (s *FullMapLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *FullMapLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *FullMapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullMapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullMapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFullMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) FullMapLiteral() (localctx IFullMapLiteralContext) {
	localctx = NewFullMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Cql3ParserRULE_fullMapLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1016)
		p.Match(Cql3ParserT__12)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
		{
			p.SetState(1017)

			var _x = p.Term()

			localctx.(*FullMapLiteralContext).k1 = _x
		}
		{
			p.SetState(1018)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1019)

			var _x = p.Term()

			localctx.(*FullMapLiteralContext).v1 = _x
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(1020)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1021)

				var _x = p.Term()

				localctx.(*FullMapLiteralContext).kn = _x
			}
			{
				p.SetState(1022)
				p.Match(Cql3ParserT__14)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1023)

				var _x = p.Term()

				localctx.(*FullMapLiteralContext).vn = _x
			}

			p.SetState(1029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1032)
		p.Match(Cql3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetOrMapLiteralContext is an interface to support dynamic dispatch.
type ISetOrMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m rule contexts.
	GetM() IMapLiteralContext

	// GetS returns the s rule contexts.
	GetS() ISetLiteralContext

	// SetM sets the m rule contexts.
	SetM(IMapLiteralContext)

	// SetS sets the s rule contexts.
	SetS(ISetLiteralContext)

	// Getter signatures
	MapLiteral() IMapLiteralContext
	SetLiteral() ISetLiteralContext

	// IsSetOrMapLiteralContext differentiates from other interfaces.
	IsSetOrMapLiteralContext()
}

type SetOrMapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	m      IMapLiteralContext
	s      ISetLiteralContext
}

func NewEmptySetOrMapLiteralContext() *SetOrMapLiteralContext {
	var p = new(SetOrMapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_setOrMapLiteral
	return p
}

func InitEmptySetOrMapLiteralContext(p *SetOrMapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_setOrMapLiteral
}

func (*SetOrMapLiteralContext) IsSetOrMapLiteralContext() {}

func NewSetOrMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOrMapLiteralContext {
	var p = new(SetOrMapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_setOrMapLiteral

	return p
}

func (s *SetOrMapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOrMapLiteralContext) GetM() IMapLiteralContext { return s.m }

func (s *SetOrMapLiteralContext) GetS() ISetLiteralContext { return s.s }

func (s *SetOrMapLiteralContext) SetM(v IMapLiteralContext) { s.m = v }

func (s *SetOrMapLiteralContext) SetS(v ISetLiteralContext) { s.s = v }

func (s *SetOrMapLiteralContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *SetOrMapLiteralContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *SetOrMapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOrMapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOrMapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSetOrMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SetOrMapLiteral() (localctx ISetOrMapLiteralContext) {
	localctx = NewSetOrMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Cql3ParserRULE_setOrMapLiteral)
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)

			var _x = p.MapLiteral()

			localctx.(*SetOrMapLiteralContext).m = _x
		}

	case Cql3ParserT__1, Cql3ParserT__13:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1035)

			var _x = p.SetLiteral()

			localctx.(*SetOrMapLiteralContext).s = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTn returns the tn rule contexts.
	GetTn() ITermContext

	// SetTn sets the tn rule contexts.
	SetTn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tn     ITermContext
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) GetTn() ITermContext { return s.tn }

func (s *SetLiteralContext) SetTn(v ITermContext) { s.tn = v }

func (s *SetLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Cql3ParserRULE_setLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1038)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1039)

			var _x = p.Term()

			localctx.(*SetLiteralContext).tn = _x
		}

		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetV returns the v rule contexts.
	GetV() ITermContext

	// GetKn returns the kn rule contexts.
	GetKn() ITermContext

	// GetVn returns the vn rule contexts.
	GetVn() ITermContext

	// SetV sets the v rule contexts.
	SetV(ITermContext)

	// SetKn sets the kn rule contexts.
	SetKn(ITermContext)

	// SetVn sets the vn rule contexts.
	SetVn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	v      ITermContext
	kn     ITermContext
	vn     ITermContext
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) GetV() ITermContext { return s.v }

func (s *MapLiteralContext) GetKn() ITermContext { return s.kn }

func (s *MapLiteralContext) GetVn() ITermContext { return s.vn }

func (s *MapLiteralContext) SetV(v ITermContext) { s.v = v }

func (s *MapLiteralContext) SetKn(v ITermContext) { s.kn = v }

func (s *MapLiteralContext) SetVn(v ITermContext) { s.vn = v }

func (s *MapLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Cql3ParserRULE_mapLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(Cql3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1046)

		var _x = p.Term()

		localctx.(*MapLiteralContext).v = _x
	}
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1047)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)

			var _x = p.Term()

			localctx.(*MapLiteralContext).kn = _x
		}
		{
			p.SetState(1049)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1050)

			var _x = p.Term()

			localctx.(*MapLiteralContext).vn = _x
		}

		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionLiteralContext is an interface to support dynamic dispatch.
type ICollectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListLiteralContext

	// GetT returns the t rule contexts.
	GetT() ITermContext

	// GetV returns the v rule contexts.
	GetV() ISetOrMapLiteralContext

	// SetL sets the l rule contexts.
	SetL(IListLiteralContext)

	// SetT sets the t rule contexts.
	SetT(ITermContext)

	// SetV sets the v rule contexts.
	SetV(ISetOrMapLiteralContext)

	// Getter signatures
	ListLiteral() IListLiteralContext
	Term() ITermContext
	SetOrMapLiteral() ISetOrMapLiteralContext

	// IsCollectionLiteralContext differentiates from other interfaces.
	IsCollectionLiteralContext()
}

type CollectionLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      IListLiteralContext
	t      ITermContext
	v      ISetOrMapLiteralContext
}

func NewEmptyCollectionLiteralContext() *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collectionLiteral
	return p
}

func InitEmptyCollectionLiteralContext(p *CollectionLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collectionLiteral
}

func (*CollectionLiteralContext) IsCollectionLiteralContext() {}

func NewCollectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_collectionLiteral

	return p
}

func (s *CollectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionLiteralContext) GetL() IListLiteralContext { return s.l }

func (s *CollectionLiteralContext) GetT() ITermContext { return s.t }

func (s *CollectionLiteralContext) GetV() ISetOrMapLiteralContext { return s.v }

func (s *CollectionLiteralContext) SetL(v IListLiteralContext) { s.l = v }

func (s *CollectionLiteralContext) SetT(v ITermContext) { s.t = v }

func (s *CollectionLiteralContext) SetV(v ISetOrMapLiteralContext) { s.v = v }

func (s *CollectionLiteralContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *CollectionLiteralContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *CollectionLiteralContext) SetOrMapLiteral() ISetOrMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOrMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOrMapLiteralContext)
}

func (s *CollectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCollectionLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) CollectionLiteral() (localctx ICollectionLiteralContext) {
	localctx = NewCollectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Cql3ParserRULE_collectionLiteral)
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)

			var _x = p.ListLiteral()

			localctx.(*CollectionLiteralContext).l = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1058)
			p.Match(Cql3ParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)

			var _x = p.Term()

			localctx.(*CollectionLiteralContext).t = _x
		}
		{
			p.SetState(1060)

			var _x = p.SetOrMapLiteral()

			localctx.(*CollectionLiteralContext).v = _x
		}
		{
			p.SetState(1061)
			p.Match(Cql3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1063)
			p.Match(Cql3ParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1064)
			p.Match(Cql3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetTn returns the tn rule contexts.
	GetTn() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetTn sets the tn rule contexts.
	SetTn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	tn     ITermContext
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listLiteral
	return p
}

func InitEmptyListLiteralContext(p *ListLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_listLiteral
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) GetT1() ITermContext { return s.t1 }

func (s *ListLiteralContext) GetTn() ITermContext { return s.tn }

func (s *ListLiteralContext) SetT1(v ITermContext) { s.t1 = v }

func (s *ListLiteralContext) SetTn(v ITermContext) { s.tn = v }

func (s *ListLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *ListLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitListLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ListLiteral() (localctx IListLiteralContext) {
	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Cql3ParserRULE_listLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(Cql3ParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
		{
			p.SetState(1068)

			var _x = p.Term()

			localctx.(*ListLiteralContext).t1 = _x
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(1069)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1070)

				var _x = p.Term()

				localctx.(*ListLiteralContext).tn = _x
			}

			p.SetState(1075)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1078)
		p.Match(Cql3ParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsertypeLiteralContext is an interface to support dynamic dispatch.
type IUsertypeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK1 returns the k1 rule contexts.
	GetK1() IFidentContext

	// GetV1 returns the v1 rule contexts.
	GetV1() ITermContext

	// GetKn returns the kn rule contexts.
	GetKn() IFidentContext

	// GetVn returns the vn rule contexts.
	GetVn() ITermContext

	// SetK1 sets the k1 rule contexts.
	SetK1(IFidentContext)

	// SetV1 sets the v1 rule contexts.
	SetV1(ITermContext)

	// SetKn sets the kn rule contexts.
	SetKn(IFidentContext)

	// SetVn sets the vn rule contexts.
	SetVn(ITermContext)

	// Getter signatures
	AllFident() []IFidentContext
	Fident(i int) IFidentContext
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsUsertypeLiteralContext differentiates from other interfaces.
	IsUsertypeLiteralContext()
}

type UsertypeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k1     IFidentContext
	v1     ITermContext
	kn     IFidentContext
	vn     ITermContext
}

func NewEmptyUsertypeLiteralContext() *UsertypeLiteralContext {
	var p = new(UsertypeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_usertypeLiteral
	return p
}

func InitEmptyUsertypeLiteralContext(p *UsertypeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_usertypeLiteral
}

func (*UsertypeLiteralContext) IsUsertypeLiteralContext() {}

func NewUsertypeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsertypeLiteralContext {
	var p = new(UsertypeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_usertypeLiteral

	return p
}

func (s *UsertypeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *UsertypeLiteralContext) GetK1() IFidentContext { return s.k1 }

func (s *UsertypeLiteralContext) GetV1() ITermContext { return s.v1 }

func (s *UsertypeLiteralContext) GetKn() IFidentContext { return s.kn }

func (s *UsertypeLiteralContext) GetVn() ITermContext { return s.vn }

func (s *UsertypeLiteralContext) SetK1(v IFidentContext) { s.k1 = v }

func (s *UsertypeLiteralContext) SetV1(v ITermContext) { s.v1 = v }

func (s *UsertypeLiteralContext) SetKn(v IFidentContext) { s.kn = v }

func (s *UsertypeLiteralContext) SetVn(v ITermContext) { s.vn = v }

func (s *UsertypeLiteralContext) AllFident() []IFidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFidentContext); ok {
			len++
		}
	}

	tst := make([]IFidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFidentContext); ok {
			tst[i] = t.(IFidentContext)
			i++
		}
	}

	return tst
}

func (s *UsertypeLiteralContext) Fident(i int) IFidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFidentContext)
}

func (s *UsertypeLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *UsertypeLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *UsertypeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsertypeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsertypeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUsertypeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) UsertypeLiteral() (localctx IUsertypeLiteralContext) {
	localctx = NewUsertypeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Cql3ParserRULE_usertypeLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Match(Cql3ParserT__12)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1081)

		var _x = p.Fident()

		localctx.(*UsertypeLiteralContext).k1 = _x
	}
	{
		p.SetState(1082)
		p.Match(Cql3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1083)

		var _x = p.Term()

		localctx.(*UsertypeLiteralContext).v1 = _x
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1084)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1085)

			var _x = p.Fident()

			localctx.(*UsertypeLiteralContext).kn = _x
		}
		{
			p.SetState(1086)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)

			var _x = p.Term()

			localctx.(*UsertypeLiteralContext).vn = _x
		}

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1094)
		p.Match(Cql3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleLiteralContext is an interface to support dynamic dispatch.
type ITupleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetTn returns the tn rule contexts.
	GetTn() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetTn sets the tn rule contexts.
	SetTn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsTupleLiteralContext differentiates from other interfaces.
	IsTupleLiteralContext()
}

type TupleLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	tn     ITermContext
}

func NewEmptyTupleLiteralContext() *TupleLiteralContext {
	var p = new(TupleLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleLiteral
	return p
}

func InitEmptyTupleLiteralContext(p *TupleLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleLiteral
}

func (*TupleLiteralContext) IsTupleLiteralContext() {}

func NewTupleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleLiteralContext {
	var p = new(TupleLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tupleLiteral

	return p
}

func (s *TupleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleLiteralContext) GetT1() ITermContext { return s.t1 }

func (s *TupleLiteralContext) GetTn() ITermContext { return s.tn }

func (s *TupleLiteralContext) SetT1(v ITermContext) { s.t1 = v }

func (s *TupleLiteralContext) SetTn(v ITermContext) { s.tn = v }

func (s *TupleLiteralContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *TupleLiteralContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TupleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTupleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TupleLiteral() (localctx ITupleLiteralContext) {
	localctx = NewTupleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Cql3ParserRULE_tupleLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1096)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1097)

		var _x = p.Term()

		localctx.(*TupleLiteralContext).t1 = _x
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1098)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)

			var _x = p.Term()

			localctx.(*TupleLiteralContext).tn = _x
		}

		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1105)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() IConstantContext

	// GetL returns the l rule contexts.
	GetL() ICollectionLiteralContext

	// GetU returns the u rule contexts.
	GetU() IUsertypeLiteralContext

	// GetT returns the t rule contexts.
	GetT() ITupleLiteralContext

	// GetM returns the m rule contexts.
	GetM() IMarkerContext

	// SetC sets the c rule contexts.
	SetC(IConstantContext)

	// SetL sets the l rule contexts.
	SetL(ICollectionLiteralContext)

	// SetU sets the u rule contexts.
	SetU(IUsertypeLiteralContext)

	// SetT sets the t rule contexts.
	SetT(ITupleLiteralContext)

	// SetM sets the m rule contexts.
	SetM(IMarkerContext)

	// Getter signatures
	Constant() IConstantContext
	CollectionLiteral() ICollectionLiteralContext
	UsertypeLiteral() IUsertypeLiteralContext
	TupleLiteral() ITupleLiteralContext
	K_NULL() antlr.TerminalNode
	Marker() IMarkerContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      IConstantContext
	l      ICollectionLiteralContext
	u      IUsertypeLiteralContext
	t      ITupleLiteralContext
	m      IMarkerContext
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) GetC() IConstantContext { return s.c }

func (s *ValueContext) GetL() ICollectionLiteralContext { return s.l }

func (s *ValueContext) GetU() IUsertypeLiteralContext { return s.u }

func (s *ValueContext) GetT() ITupleLiteralContext { return s.t }

func (s *ValueContext) GetM() IMarkerContext { return s.m }

func (s *ValueContext) SetC(v IConstantContext) { s.c = v }

func (s *ValueContext) SetL(v ICollectionLiteralContext) { s.l = v }

func (s *ValueContext) SetU(v IUsertypeLiteralContext) { s.u = v }

func (s *ValueContext) SetT(v ITupleLiteralContext) { s.t = v }

func (s *ValueContext) SetM(v IMarkerContext) { s.m = v }

func (s *ValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ValueContext) CollectionLiteral() ICollectionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionLiteralContext)
}

func (s *ValueContext) UsertypeLiteral() IUsertypeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsertypeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsertypeLiteralContext)
}

func (s *ValueContext) TupleLiteral() ITupleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralContext)
}

func (s *ValueContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NULL, 0)
}

func (s *ValueContext) Marker() IMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Cql3ParserRULE_value)
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)

			var _x = p.Constant()

			localctx.(*ValueContext).c = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)

			var _x = p.CollectionLiteral()

			localctx.(*ValueContext).l = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1109)

			var _x = p.UsertypeLiteral()

			localctx.(*ValueContext).u = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1110)

			var _x = p.TupleLiteral()

			localctx.(*ValueContext).t = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1111)
			p.Match(Cql3ParserK_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1112)

			var _x = p.Marker()

			localctx.(*ValueContext).m = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntValueContext is an interface to support dynamic dispatch.
type IIntValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// GetM returns the m rule contexts.
	GetM() IMarkerContext

	// SetM sets the m rule contexts.
	SetM(IMarkerContext)

	// Getter signatures
	INTEGER() antlr.TerminalNode
	Marker() IMarkerContext

	// IsIntValueContext differentiates from other interfaces.
	IsIntValueContext()
}

type IntValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
	m      IMarkerContext
}

func NewEmptyIntValueContext() *IntValueContext {
	var p = new(IntValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_intValue
	return p
}

func InitEmptyIntValueContext(p *IntValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_intValue
}

func (*IntValueContext) IsIntValueContext() {}

func NewIntValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntValueContext {
	var p = new(IntValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_intValue

	return p
}

func (s *IntValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntValueContext) GetT() antlr.Token { return s.t }

func (s *IntValueContext) SetT(v antlr.Token) { s.t = v }

func (s *IntValueContext) GetM() IMarkerContext { return s.m }

func (s *IntValueContext) SetM(v IMarkerContext) { s.m = v }

func (s *IntValueContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserINTEGER, 0)
}

func (s *IntValueContext) Marker() IMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *IntValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIntValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) IntValue() (localctx IIntValueContext) {
	localctx = NewIntValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Cql3ParserRULE_intValue)
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1115)

			var _m = p.Match(Cql3ParserINTEGER)

			localctx.(*IntValueContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserT__14, Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1116)

			var _x = p.Marker()

			localctx.(*IntValueContext).m = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKs returns the ks rule contexts.
	GetKs() IKeyspaceNameContext

	// GetF returns the f rule contexts.
	GetF() IAllowedFunctionNameContext

	// SetKs sets the ks rule contexts.
	SetKs(IKeyspaceNameContext)

	// SetF sets the f rule contexts.
	SetF(IAllowedFunctionNameContext)

	// Getter signatures
	AllowedFunctionName() IAllowedFunctionNameContext
	KeyspaceName() IKeyspaceNameContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	ks     IKeyspaceNameContext
	f      IAllowedFunctionNameContext
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) GetKs() IKeyspaceNameContext { return s.ks }

func (s *FunctionNameContext) GetF() IAllowedFunctionNameContext { return s.f }

func (s *FunctionNameContext) SetKs(v IKeyspaceNameContext) { s.ks = v }

func (s *FunctionNameContext) SetF(v IAllowedFunctionNameContext) { s.f = v }

func (s *FunctionNameContext) AllowedFunctionName() IAllowedFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllowedFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllowedFunctionNameContext)
}

func (s *FunctionNameContext) KeyspaceName() IKeyspaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceNameContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Cql3ParserRULE_functionName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1119)

			var _x = p.KeyspaceName()

			localctx.(*FunctionNameContext).ks = _x
		}
		{
			p.SetState(1120)
			p.Match(Cql3ParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1124)

		var _x = p.AllowedFunctionName()

		localctx.(*FunctionNameContext).f = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllowedFunctionNameContext is an interface to support dynamic dispatch.
type IAllowedFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAllowedFunctionNameContext differentiates from other interfaces.
	IsAllowedFunctionNameContext()
}

type AllowedFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllowedFunctionNameContext() *AllowedFunctionNameContext {
	var p = new(AllowedFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_allowedFunctionName
	return p
}

func InitEmptyAllowedFunctionNameContext(p *AllowedFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_allowedFunctionName
}

func (*AllowedFunctionNameContext) IsAllowedFunctionNameContext() {}

func NewAllowedFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllowedFunctionNameContext {
	var p = new(AllowedFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_allowedFunctionName

	return p
}

func (s *AllowedFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AllowedFunctionNameContext) CopyAll(ctx *AllowedFunctionNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AllowedFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowedFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AllowedFunctionNameIdentContext struct {
	AllowedFunctionNameContext
	f antlr.Token
	u IUnreserved_function_keywordContext
}

func NewAllowedFunctionNameIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllowedFunctionNameIdentContext {
	var p = new(AllowedFunctionNameIdentContext)

	InitEmptyAllowedFunctionNameContext(&p.AllowedFunctionNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*AllowedFunctionNameContext))

	return p
}

func (s *AllowedFunctionNameIdentContext) GetF() antlr.Token { return s.f }

func (s *AllowedFunctionNameIdentContext) SetF(v antlr.Token) { s.f = v }

func (s *AllowedFunctionNameIdentContext) GetU() IUnreserved_function_keywordContext { return s.u }

func (s *AllowedFunctionNameIdentContext) SetU(v IUnreserved_function_keywordContext) { s.u = v }

func (s *AllowedFunctionNameIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowedFunctionNameIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *AllowedFunctionNameIdentContext) Unreserved_function_keyword() IUnreserved_function_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_function_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_function_keywordContext)
}

func (s *AllowedFunctionNameIdentContext) K_TOKEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TOKEN, 0)
}

func (s *AllowedFunctionNameIdentContext) K_COUNT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COUNT, 0)
}

func (s *AllowedFunctionNameIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAllowedFunctionNameIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type AllowedFunctionNameQuotedIdentContext struct {
	AllowedFunctionNameContext
	f antlr.Token
}

func NewAllowedFunctionNameQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllowedFunctionNameQuotedIdentContext {
	var p = new(AllowedFunctionNameQuotedIdentContext)

	InitEmptyAllowedFunctionNameContext(&p.AllowedFunctionNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*AllowedFunctionNameContext))

	return p
}

func (s *AllowedFunctionNameQuotedIdentContext) GetF() antlr.Token { return s.f }

func (s *AllowedFunctionNameQuotedIdentContext) SetF(v antlr.Token) { s.f = v }

func (s *AllowedFunctionNameQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowedFunctionNameQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *AllowedFunctionNameQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitAllowedFunctionNameQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) AllowedFunctionName() (localctx IAllowedFunctionNameContext) {
	localctx = NewAllowedFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Cql3ParserRULE_allowedFunctionName)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserIDENT:
		localctx = NewAllowedFunctionNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1126)

			var _m = p.Match(Cql3ParserIDENT)

			localctx.(*AllowedFunctionNameIdentContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewAllowedFunctionNameQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1127)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*AllowedFunctionNameQuotedIdentContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewAllowedFunctionNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1128)

			var _x = p.Unreserved_function_keyword()

			localctx.(*AllowedFunctionNameIdentContext).u = _x
		}

	case Cql3ParserK_TOKEN:
		localctx = NewAllowedFunctionNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1129)
			p.Match(Cql3ParserK_TOKEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_COUNT:
		localctx = NewAllowedFunctionNameIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1130)
			p.Match(Cql3ParserK_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetF returns the f rule contexts.
	GetF() IFunctionNameContext

	// GetArgs returns the args rule contexts.
	GetArgs() IFunctionArgsContext

	// SetF sets the f rule contexts.
	SetF(IFunctionNameContext)

	// SetArgs sets the args rule contexts.
	SetArgs(IFunctionArgsContext)

	// Getter signatures
	FunctionName() IFunctionNameContext
	FunctionArgs() IFunctionArgsContext

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	f      IFunctionNameContext
	args   IFunctionArgsContext
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_function
	return p
}

func InitEmptyFunctionContext(p *FunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_function
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) GetF() IFunctionNameContext { return s.f }

func (s *FunctionContext) GetArgs() IFunctionArgsContext { return s.args }

func (s *FunctionContext) SetF(v IFunctionNameContext) { s.f = v }

func (s *FunctionContext) SetArgs(v IFunctionArgsContext) { s.args = v }

func (s *FunctionContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Function() (localctx IFunctionContext) {
	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Cql3ParserRULE_function)
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1133)

			var _x = p.FunctionName()

			localctx.(*FunctionContext).f = _x
		}
		{
			p.SetState(1134)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1137)

			var _x = p.FunctionName()

			localctx.(*FunctionContext).f = _x
		}
		{
			p.SetState(1138)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1139)

			var _x = p.FunctionArgs()

			localctx.(*FunctionContext).args = _x
		}
		{
			p.SetState(1140)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetTn returns the tn rule contexts.
	GetTn() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetTn sets the tn rule contexts.
	SetTn(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	tn     ITermContext
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) GetT1() ITermContext { return s.t1 }

func (s *FunctionArgsContext) GetTn() ITermContext { return s.tn }

func (s *FunctionArgsContext) SetT1(v ITermContext) { s.t1 = v }

func (s *FunctionArgsContext) SetTn(v ITermContext) { s.tn = v }

func (s *FunctionArgsContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Cql3ParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)

		var _x = p.Term()

		localctx.(*FunctionArgsContext).t1 = _x
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1145)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1146)

			var _x = p.Term()

			localctx.(*FunctionArgsContext).tn = _x
		}

		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() ITermAdditionContext

	// SetT sets the t rule contexts.
	SetT(ITermAdditionContext)

	// Getter signatures
	TermAddition() ITermAdditionContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      ITermAdditionContext
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) GetT() ITermAdditionContext { return s.t }

func (s *TermContext) SetT(v ITermAdditionContext) { s.t = v }

func (s *TermContext) TermAddition() ITermAdditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermAdditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermAdditionContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Cql3ParserRULE_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)

		var _x = p.TermAddition()

		localctx.(*TermContext).t = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermAdditionContext is an interface to support dynamic dispatch.
type ITermAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ITermMultiplicationContext

	// GetR returns the r rule contexts.
	GetR() ITermMultiplicationContext

	// SetL sets the l rule contexts.
	SetL(ITermMultiplicationContext)

	// SetR sets the r rule contexts.
	SetR(ITermMultiplicationContext)

	// Getter signatures
	AllTermMultiplication() []ITermMultiplicationContext
	TermMultiplication(i int) ITermMultiplicationContext

	// IsTermAdditionContext differentiates from other interfaces.
	IsTermAdditionContext()
}

type TermAdditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      ITermMultiplicationContext
	r      ITermMultiplicationContext
}

func NewEmptyTermAdditionContext() *TermAdditionContext {
	var p = new(TermAdditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termAddition
	return p
}

func InitEmptyTermAdditionContext(p *TermAdditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termAddition
}

func (*TermAdditionContext) IsTermAdditionContext() {}

func NewTermAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermAdditionContext {
	var p = new(TermAdditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_termAddition

	return p
}

func (s *TermAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *TermAdditionContext) GetL() ITermMultiplicationContext { return s.l }

func (s *TermAdditionContext) GetR() ITermMultiplicationContext { return s.r }

func (s *TermAdditionContext) SetL(v ITermMultiplicationContext) { s.l = v }

func (s *TermAdditionContext) SetR(v ITermMultiplicationContext) { s.r = v }

func (s *TermAdditionContext) AllTermMultiplication() []ITermMultiplicationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermMultiplicationContext); ok {
			len++
		}
	}

	tst := make([]ITermMultiplicationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermMultiplicationContext); ok {
			tst[i] = t.(ITermMultiplicationContext)
			i++
		}
	}

	return tst
}

func (s *TermAdditionContext) TermMultiplication(i int) ITermMultiplicationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermMultiplicationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermMultiplicationContext)
}

func (s *TermAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermAdditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTermAddition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TermAddition() (localctx ITermAdditionContext) {
	localctx = NewTermAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Cql3ParserRULE_termAddition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)

		var _x = p.TermMultiplication()

		localctx.(*TermAdditionContext).l = _x
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__3 || _la == Cql3ParserT__4 {
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__3:
			{
				p.SetState(1155)
				p.Match(Cql3ParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1156)

				var _x = p.TermMultiplication()

				localctx.(*TermAdditionContext).r = _x
			}

		case Cql3ParserT__4:
			{
				p.SetState(1157)
				p.Match(Cql3ParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1158)

				var _x = p.TermMultiplication()

				localctx.(*TermAdditionContext).r = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermMultiplicationContext is an interface to support dynamic dispatch.
type ITermMultiplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ITermGroupContext

	// GetR returns the r rule contexts.
	GetR() ITermGroupContext

	// SetL sets the l rule contexts.
	SetL(ITermGroupContext)

	// SetR sets the r rule contexts.
	SetR(ITermGroupContext)

	// Getter signatures
	AllTermGroup() []ITermGroupContext
	TermGroup(i int) ITermGroupContext

	// IsTermMultiplicationContext differentiates from other interfaces.
	IsTermMultiplicationContext()
}

type TermMultiplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      ITermGroupContext
	r      ITermGroupContext
}

func NewEmptyTermMultiplicationContext() *TermMultiplicationContext {
	var p = new(TermMultiplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termMultiplication
	return p
}

func InitEmptyTermMultiplicationContext(p *TermMultiplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termMultiplication
}

func (*TermMultiplicationContext) IsTermMultiplicationContext() {}

func NewTermMultiplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermMultiplicationContext {
	var p = new(TermMultiplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_termMultiplication

	return p
}

func (s *TermMultiplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *TermMultiplicationContext) GetL() ITermGroupContext { return s.l }

func (s *TermMultiplicationContext) GetR() ITermGroupContext { return s.r }

func (s *TermMultiplicationContext) SetL(v ITermGroupContext) { s.l = v }

func (s *TermMultiplicationContext) SetR(v ITermGroupContext) { s.r = v }

func (s *TermMultiplicationContext) AllTermGroup() []ITermGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermGroupContext); ok {
			len++
		}
	}

	tst := make([]ITermGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermGroupContext); ok {
			tst[i] = t.(ITermGroupContext)
			i++
		}
	}

	return tst
}

func (s *TermMultiplicationContext) TermGroup(i int) ITermGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermGroupContext)
}

func (s *TermMultiplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermMultiplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermMultiplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTermMultiplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TermMultiplication() (localctx ITermMultiplicationContext) {
	localctx = NewTermMultiplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Cql3ParserRULE_termMultiplication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)

		var _x = p.TermGroup()

		localctx.(*TermMultiplicationContext).l = _x
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&200) != 0 {
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__2:
			{
				p.SetState(1165)
				p.Match(Cql3ParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1166)

				var _x = p.TermGroup()

				localctx.(*TermMultiplicationContext).r = _x
			}

		case Cql3ParserT__5:
			{
				p.SetState(1167)
				p.Match(Cql3ParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1168)

				var _x = p.TermGroup()

				localctx.(*TermMultiplicationContext).r = _x
			}

		case Cql3ParserT__6:
			{
				p.SetState(1169)
				p.Match(Cql3ParserT__6)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1170)

				var _x = p.TermGroup()

				localctx.(*TermMultiplicationContext).r = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermGroupContext is an interface to support dynamic dispatch.
type ITermGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() ISimpleTermContext

	// SetT sets the t rule contexts.
	SetT(ISimpleTermContext)

	// Getter signatures
	SimpleTerm() ISimpleTermContext

	// IsTermGroupContext differentiates from other interfaces.
	IsTermGroupContext()
}

type TermGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      ISimpleTermContext
}

func NewEmptyTermGroupContext() *TermGroupContext {
	var p = new(TermGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termGroup
	return p
}

func InitEmptyTermGroupContext(p *TermGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_termGroup
}

func (*TermGroupContext) IsTermGroupContext() {}

func NewTermGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermGroupContext {
	var p = new(TermGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_termGroup

	return p
}

func (s *TermGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *TermGroupContext) GetT() ISimpleTermContext { return s.t }

func (s *TermGroupContext) SetT(v ISimpleTermContext) { s.t = v }

func (s *TermGroupContext) SimpleTerm() ISimpleTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTermContext)
}

func (s *TermGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTermGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TermGroup() (localctx ITermGroupContext) {
	localctx = NewTermGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Cql3ParserRULE_termGroup)
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__8, Cql3ParserT__10, Cql3ParserT__12, Cql3ParserT__14, Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_TOKEN, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_NULL, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN, Cql3ParserK_POSITIVE_INFINITY, Cql3ParserK_NEGATIVE_INFINITY, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN, Cql3ParserSTRING_LITERAL, Cql3ParserQUOTED_NAME, Cql3ParserINTEGER, Cql3ParserQMARK, Cql3ParserFLOAT, Cql3ParserBOOLEAN, Cql3ParserDURATION, Cql3ParserIDENT, Cql3ParserHEXNUMBER, Cql3ParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1176)

			var _x = p.SimpleTerm()

			localctx.(*TermGroupContext).t = _x
		}

	case Cql3ParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1177)
			p.Match(Cql3ParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1178)

			var _x = p.SimpleTerm()

			localctx.(*TermGroupContext).t = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTermContext is an interface to support dynamic dispatch.
type ISimpleTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetV returns the v rule contexts.
	GetV() IValueContext

	// GetF returns the f rule contexts.
	GetF() IFunctionContext

	// GetC returns the c rule contexts.
	GetC() IComparatorTypeContext

	// GetT returns the t rule contexts.
	GetT() ISimpleTermContext

	// GetN returns the n rule contexts.
	GetN() INative_typeContext

	// SetV sets the v rule contexts.
	SetV(IValueContext)

	// SetF sets the f rule contexts.
	SetF(IFunctionContext)

	// SetC sets the c rule contexts.
	SetC(IComparatorTypeContext)

	// SetT sets the t rule contexts.
	SetT(ISimpleTermContext)

	// SetN sets the n rule contexts.
	SetN(INative_typeContext)

	// Getter signatures
	Value() IValueContext
	Function() IFunctionContext
	ComparatorType() IComparatorTypeContext
	SimpleTerm() ISimpleTermContext
	K_CAST() antlr.TerminalNode
	K_AS() antlr.TerminalNode
	Native_type() INative_typeContext

	// IsSimpleTermContext differentiates from other interfaces.
	IsSimpleTermContext()
}

type SimpleTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	v      IValueContext
	f      IFunctionContext
	c      IComparatorTypeContext
	t      ISimpleTermContext
	n      INative_typeContext
}

func NewEmptySimpleTermContext() *SimpleTermContext {
	var p = new(SimpleTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_simpleTerm
	return p
}

func InitEmptySimpleTermContext(p *SimpleTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_simpleTerm
}

func (*SimpleTermContext) IsSimpleTermContext() {}

func NewSimpleTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTermContext {
	var p = new(SimpleTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_simpleTerm

	return p
}

func (s *SimpleTermContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTermContext) GetV() IValueContext { return s.v }

func (s *SimpleTermContext) GetF() IFunctionContext { return s.f }

func (s *SimpleTermContext) GetC() IComparatorTypeContext { return s.c }

func (s *SimpleTermContext) GetT() ISimpleTermContext { return s.t }

func (s *SimpleTermContext) GetN() INative_typeContext { return s.n }

func (s *SimpleTermContext) SetV(v IValueContext) { s.v = v }

func (s *SimpleTermContext) SetF(v IFunctionContext) { s.f = v }

func (s *SimpleTermContext) SetC(v IComparatorTypeContext) { s.c = v }

func (s *SimpleTermContext) SetT(v ISimpleTermContext) { s.t = v }

func (s *SimpleTermContext) SetN(v INative_typeContext) { s.n = v }

func (s *SimpleTermContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *SimpleTermContext) Function() IFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *SimpleTermContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *SimpleTermContext) SimpleTerm() ISimpleTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTermContext)
}

func (s *SimpleTermContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CAST, 0)
}

func (s *SimpleTermContext) K_AS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AS, 0)
}

func (s *SimpleTermContext) Native_type() INative_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INative_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INative_typeContext)
}

func (s *SimpleTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSimpleTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SimpleTerm() (localctx ISimpleTermContext) {
	localctx = NewSimpleTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Cql3ParserRULE_simpleTerm)
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1181)

			var _x = p.Value()

			localctx.(*SimpleTermContext).v = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1182)

			var _x = p.Function()

			localctx.(*SimpleTermContext).f = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1183)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1184)

			var _x = p.ComparatorType()

			localctx.(*SimpleTermContext).c = _x
		}
		{
			p.SetState(1185)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1186)

			var _x = p.SimpleTerm()

			localctx.(*SimpleTermContext).t = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1188)
			p.Match(Cql3ParserK_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1189)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1190)

			var _x = p.SimpleTerm()

			localctx.(*SimpleTermContext).t = _x
		}
		{
			p.SetState(1191)
			p.Match(Cql3ParserK_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1192)

			var _x = p.Native_type()

			localctx.(*SimpleTermContext).n = _x
		}
		{
			p.SetState(1193)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	AllK_AND() []antlr.TerminalNode
	K_AND(i int) antlr.TerminalNode

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) AllK_AND() []antlr.TerminalNode {
	return s.GetTokens(Cql3ParserK_AND)
}

func (s *PropertiesContext) K_AND(i int) antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AND, i)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Cql3ParserRULE_properties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1197)
		p.Property()
	}
	p.SetState(1202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserK_AND {
		{
			p.SetState(1198)
			p.Match(Cql3ParserK_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1199)
			p.Property()
		}

		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() INoncol_identContext

	// GetSimple returns the simple rule contexts.
	GetSimple() IPropertyValueContext

	// GetMap_ returns the map_ rule contexts.
	GetMap_() IFullMapLiteralContext

	// SetK sets the k rule contexts.
	SetK(INoncol_identContext)

	// SetSimple sets the simple rule contexts.
	SetSimple(IPropertyValueContext)

	// SetMap_ sets the map_ rule contexts.
	SetMap_(IFullMapLiteralContext)

	// Getter signatures
	Noncol_ident() INoncol_identContext
	PropertyValue() IPropertyValueContext
	FullMapLiteral() IFullMapLiteralContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      INoncol_identContext
	simple IPropertyValueContext
	map_   IFullMapLiteralContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetK() INoncol_identContext { return s.k }

func (s *PropertyContext) GetSimple() IPropertyValueContext { return s.simple }

func (s *PropertyContext) GetMap_() IFullMapLiteralContext { return s.map_ }

func (s *PropertyContext) SetK(v INoncol_identContext) { s.k = v }

func (s *PropertyContext) SetSimple(v IPropertyValueContext) { s.simple = v }

func (s *PropertyContext) SetMap_(v IFullMapLiteralContext) { s.map_ = v }

func (s *PropertyContext) Noncol_ident() INoncol_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoncol_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoncol_identContext)
}

func (s *PropertyContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyContext) FullMapLiteral() IFullMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullMapLiteralContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Cql3ParserRULE_property)
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1205)

			var _x = p.Noncol_ident()

			localctx.(*PropertyContext).k = _x
		}
		{
			p.SetState(1206)
			p.Match(Cql3ParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1207)

			var _x = p.PropertyValue()

			localctx.(*PropertyContext).simple = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1209)

			var _x = p.Noncol_ident()

			localctx.(*PropertyContext).k = _x
		}
		{
			p.SetState(1210)
			p.Match(Cql3ParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1211)

			var _x = p.FullMapLiteral()

			localctx.(*PropertyContext).map_ = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() IConstantContext

	// GetU returns the u rule contexts.
	GetU() IUnreserved_keywordContext

	// SetC sets the c rule contexts.
	SetC(IConstantContext)

	// SetU sets the u rule contexts.
	SetU(IUnreserved_keywordContext)

	// Getter signatures
	Constant() IConstantContext
	Unreserved_keyword() IUnreserved_keywordContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	c      IConstantContext
	u      IUnreserved_keywordContext
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) GetC() IConstantContext { return s.c }

func (s *PropertyValueContext) GetU() IUnreserved_keywordContext { return s.u }

func (s *PropertyValueContext) SetC(v IConstantContext) { s.c = v }

func (s *PropertyValueContext) SetU(v IUnreserved_keywordContext) { s.u = v }

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitPropertyValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Cql3ParserRULE_propertyValue)
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_POSITIVE_NAN, Cql3ParserK_NEGATIVE_NAN, Cql3ParserK_POSITIVE_INFINITY, Cql3ParserK_NEGATIVE_INFINITY, Cql3ParserSTRING_LITERAL, Cql3ParserINTEGER, Cql3ParserFLOAT, Cql3ParserBOOLEAN, Cql3ParserDURATION, Cql3ParserHEXNUMBER, Cql3ParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1215)

			var _x = p.Constant()

			localctx.(*PropertyValueContext).c = _x
		}

	case Cql3ParserK_AS, Cql3ParserK_KEY, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_JSON, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)

			var _x = p.Unreserved_keyword()

			localctx.(*PropertyValueContext).u = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleColumnBetweenValuesContext is an interface to support dynamic dispatch.
type ISingleColumnBetweenValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetT2 returns the t2 rule contexts.
	GetT2() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetT2 sets the t2 rule contexts.
	SetT2(ITermContext)

	// Getter signatures
	K_AND() antlr.TerminalNode
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsSingleColumnBetweenValuesContext differentiates from other interfaces.
	IsSingleColumnBetweenValuesContext()
}

type SingleColumnBetweenValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	t2     ITermContext
}

func NewEmptySingleColumnBetweenValuesContext() *SingleColumnBetweenValuesContext {
	var p = new(SingleColumnBetweenValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_singleColumnBetweenValues
	return p
}

func InitEmptySingleColumnBetweenValuesContext(p *SingleColumnBetweenValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_singleColumnBetweenValues
}

func (*SingleColumnBetweenValuesContext) IsSingleColumnBetweenValuesContext() {}

func NewSingleColumnBetweenValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleColumnBetweenValuesContext {
	var p = new(SingleColumnBetweenValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_singleColumnBetweenValues

	return p
}

func (s *SingleColumnBetweenValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleColumnBetweenValuesContext) GetT1() ITermContext { return s.t1 }

func (s *SingleColumnBetweenValuesContext) GetT2() ITermContext { return s.t2 }

func (s *SingleColumnBetweenValuesContext) SetT1(v ITermContext) { s.t1 = v }

func (s *SingleColumnBetweenValuesContext) SetT2(v ITermContext) { s.t2 = v }

func (s *SingleColumnBetweenValuesContext) K_AND() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AND, 0)
}

func (s *SingleColumnBetweenValuesContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *SingleColumnBetweenValuesContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SingleColumnBetweenValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleColumnBetweenValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleColumnBetweenValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSingleColumnBetweenValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SingleColumnBetweenValues() (localctx ISingleColumnBetweenValuesContext) {
	localctx = NewSingleColumnBetweenValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Cql3ParserRULE_singleColumnBetweenValues)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1219)

		var _x = p.Term()

		localctx.(*SingleColumnBetweenValuesContext).t1 = _x
	}
	{
		p.SetState(1220)
		p.Match(Cql3ParserK_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)

		var _x = p.Term()

		localctx.(*SingleColumnBetweenValuesContext).t2 = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationTypeContext is an interface to support dynamic dispatch.
type IRelationTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationTypeContext differentiates from other interfaces.
	IsRelationTypeContext()
}

type RelationTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationTypeContext() *RelationTypeContext {
	var p = new(RelationTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relationType
	return p
}

func InitEmptyRelationTypeContext(p *RelationTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relationType
}

func (*RelationTypeContext) IsRelationTypeContext() {}

func NewRelationTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationTypeContext {
	var p = new(RelationTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_relationType

	return p
}

func (s *RelationTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *RelationTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) RelationType() (localctx IRelationTypeContext) {
	localctx = NewRelationTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Cql3ParserRULE_relationType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8257536) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationColumnContext struct {
	RelationContext
	name               ICidentContext
	type_              IRelationTypeContext
	t                  ITermContext
	betweenValues      ISingleColumnBetweenValuesContext
	rtInOperator       IInOperatorContext
	inValue            ISingleColumnInValuesContext
	rtContainsOperator IContainsOperatorContext
}

func NewRelationColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationColumnContext {
	var p = new(RelationColumnContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationColumnContext) GetName() ICidentContext { return s.name }

func (s *RelationColumnContext) GetType_() IRelationTypeContext { return s.type_ }

func (s *RelationColumnContext) GetT() ITermContext { return s.t }

func (s *RelationColumnContext) GetBetweenValues() ISingleColumnBetweenValuesContext {
	return s.betweenValues
}

func (s *RelationColumnContext) GetRtInOperator() IInOperatorContext { return s.rtInOperator }

func (s *RelationColumnContext) GetInValue() ISingleColumnInValuesContext { return s.inValue }

func (s *RelationColumnContext) GetRtContainsOperator() IContainsOperatorContext {
	return s.rtContainsOperator
}

func (s *RelationColumnContext) SetName(v ICidentContext) { s.name = v }

func (s *RelationColumnContext) SetType_(v IRelationTypeContext) { s.type_ = v }

func (s *RelationColumnContext) SetT(v ITermContext) { s.t = v }

func (s *RelationColumnContext) SetBetweenValues(v ISingleColumnBetweenValuesContext) {
	s.betweenValues = v
}

func (s *RelationColumnContext) SetRtInOperator(v IInOperatorContext) { s.rtInOperator = v }

func (s *RelationColumnContext) SetInValue(v ISingleColumnInValuesContext) { s.inValue = v }

func (s *RelationColumnContext) SetRtContainsOperator(v IContainsOperatorContext) {
	s.rtContainsOperator = v
}

func (s *RelationColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationColumnContext) Cident() ICidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICidentContext)
}

func (s *RelationColumnContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BETWEEN, 0)
}

func (s *RelationColumnContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIKE, 0)
}

func (s *RelationColumnContext) K_IS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IS, 0)
}

func (s *RelationColumnContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOT, 0)
}

func (s *RelationColumnContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NULL, 0)
}

func (s *RelationColumnContext) RelationType() IRelationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationTypeContext)
}

func (s *RelationColumnContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *RelationColumnContext) SingleColumnBetweenValues() ISingleColumnBetweenValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleColumnBetweenValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleColumnBetweenValuesContext)
}

func (s *RelationColumnContext) InOperator() IInOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RelationColumnContext) SingleColumnInValues() ISingleColumnInValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleColumnInValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleColumnInValuesContext)
}

func (s *RelationColumnContext) ContainsOperator() IContainsOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainsOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainsOperatorContext)
}

func (s *RelationColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationCollectionContext struct {
	RelationContext
	name  ICidentContext
	key   ITermContext
	type_ IRelationTypeContext
	t     ITermContext
}

func NewRelationCollectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationCollectionContext {
	var p = new(RelationCollectionContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationCollectionContext) GetName() ICidentContext { return s.name }

func (s *RelationCollectionContext) GetKey() ITermContext { return s.key }

func (s *RelationCollectionContext) GetType_() IRelationTypeContext { return s.type_ }

func (s *RelationCollectionContext) GetT() ITermContext { return s.t }

func (s *RelationCollectionContext) SetName(v ICidentContext) { s.name = v }

func (s *RelationCollectionContext) SetKey(v ITermContext) { s.key = v }

func (s *RelationCollectionContext) SetType_(v IRelationTypeContext) { s.type_ = v }

func (s *RelationCollectionContext) SetT(v ITermContext) { s.t = v }

func (s *RelationCollectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCollectionContext) Cident() ICidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICidentContext)
}

func (s *RelationCollectionContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *RelationCollectionContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *RelationCollectionContext) RelationType() IRelationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationTypeContext)
}

func (s *RelationCollectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationCollection(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationRecursiveContext struct {
	RelationContext
}

func NewRelationRecursiveContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationRecursiveContext {
	var p = new(RelationRecursiveContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationRecursiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationRecursiveContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationRecursiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationRecursive(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationTupleContext struct {
	RelationContext
	ids      ITupleOfIdentifiersContext
	rt       IInOperatorContext
	minValue IMultiColumnInValuesContext
	type_    IRelationTypeContext
	v        IMultiColumnValueContext
	t1       IMultiColumnValueContext
	t2       IMultiColumnValueContext
}

func NewRelationTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationTupleContext {
	var p = new(RelationTupleContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationTupleContext) GetIds() ITupleOfIdentifiersContext { return s.ids }

func (s *RelationTupleContext) GetRt() IInOperatorContext { return s.rt }

func (s *RelationTupleContext) GetMinValue() IMultiColumnInValuesContext { return s.minValue }

func (s *RelationTupleContext) GetType_() IRelationTypeContext { return s.type_ }

func (s *RelationTupleContext) GetV() IMultiColumnValueContext { return s.v }

func (s *RelationTupleContext) GetT1() IMultiColumnValueContext { return s.t1 }

func (s *RelationTupleContext) GetT2() IMultiColumnValueContext { return s.t2 }

func (s *RelationTupleContext) SetIds(v ITupleOfIdentifiersContext) { s.ids = v }

func (s *RelationTupleContext) SetRt(v IInOperatorContext) { s.rt = v }

func (s *RelationTupleContext) SetMinValue(v IMultiColumnInValuesContext) { s.minValue = v }

func (s *RelationTupleContext) SetType_(v IRelationTypeContext) { s.type_ = v }

func (s *RelationTupleContext) SetV(v IMultiColumnValueContext) { s.v = v }

func (s *RelationTupleContext) SetT1(v IMultiColumnValueContext) { s.t1 = v }

func (s *RelationTupleContext) SetT2(v IMultiColumnValueContext) { s.t2 = v }

func (s *RelationTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationTupleContext) TupleOfIdentifiers() ITupleOfIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleOfIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleOfIdentifiersContext)
}

func (s *RelationTupleContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BETWEEN, 0)
}

func (s *RelationTupleContext) K_AND() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AND, 0)
}

func (s *RelationTupleContext) InOperator() IInOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RelationTupleContext) MultiColumnInValues() IMultiColumnInValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiColumnInValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiColumnInValuesContext)
}

func (s *RelationTupleContext) RelationType() IRelationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationTypeContext)
}

func (s *RelationTupleContext) AllMultiColumnValue() []IMultiColumnValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiColumnValueContext); ok {
			len++
		}
	}

	tst := make([]IMultiColumnValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiColumnValueContext); ok {
			tst[i] = t.(IMultiColumnValueContext)
			i++
		}
	}

	return tst
}

func (s *RelationTupleContext) MultiColumnValue(i int) IMultiColumnValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiColumnValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiColumnValueContext)
}

func (s *RelationTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationTokenContext struct {
	RelationContext
	l             ITupleOfIdentifiersContext
	type_         IRelationTypeContext
	t             ITermContext
	betweenValues ISingleColumnBetweenValuesContext
}

func NewRelationTokenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationTokenContext {
	var p = new(RelationTokenContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationTokenContext) GetL() ITupleOfIdentifiersContext { return s.l }

func (s *RelationTokenContext) GetType_() IRelationTypeContext { return s.type_ }

func (s *RelationTokenContext) GetT() ITermContext { return s.t }

func (s *RelationTokenContext) GetBetweenValues() ISingleColumnBetweenValuesContext {
	return s.betweenValues
}

func (s *RelationTokenContext) SetL(v ITupleOfIdentifiersContext) { s.l = v }

func (s *RelationTokenContext) SetType_(v IRelationTypeContext) { s.type_ = v }

func (s *RelationTokenContext) SetT(v ITermContext) { s.t = v }

func (s *RelationTokenContext) SetBetweenValues(v ISingleColumnBetweenValuesContext) {
	s.betweenValues = v
}

func (s *RelationTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationTokenContext) K_TOKEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TOKEN, 0)
}

func (s *RelationTokenContext) TupleOfIdentifiers() ITupleOfIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleOfIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleOfIdentifiersContext)
}

func (s *RelationTokenContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BETWEEN, 0)
}

func (s *RelationTokenContext) RelationType() IRelationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationTypeContext)
}

func (s *RelationTokenContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *RelationTokenContext) SingleColumnBetweenValues() ISingleColumnBetweenValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleColumnBetweenValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleColumnBetweenValuesContext)
}

func (s *RelationTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitRelationToken(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Cql3ParserRULE_relation)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRelationColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1225)

			var _x = p.Cident()

			localctx.(*RelationColumnContext).name = _x
		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1226)

				var _x = p.RelationType()

				localctx.(*RelationColumnContext).type_ = _x
			}
			{
				p.SetState(1227)

				var _x = p.Term()

				localctx.(*RelationColumnContext).t = _x
			}

		case 2:
			{
				p.SetState(1229)
				p.Match(Cql3ParserK_BETWEEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1230)

				var _x = p.SingleColumnBetweenValues()

				localctx.(*RelationColumnContext).betweenValues = _x
			}

		case 3:
			{
				p.SetState(1231)
				p.Match(Cql3ParserK_LIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1232)

				var _x = p.Term()

				localctx.(*RelationColumnContext).t = _x
			}

		case 4:
			{
				p.SetState(1233)
				p.Match(Cql3ParserK_IS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1234)
				p.Match(Cql3ParserK_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1235)
				p.Match(Cql3ParserK_NULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(1236)

				var _x = p.InOperator()

				localctx.(*RelationColumnContext).rtInOperator = _x
			}
			{
				p.SetState(1237)

				var _x = p.SingleColumnInValues()

				localctx.(*RelationColumnContext).inValue = _x
			}

		case 6:
			{
				p.SetState(1239)

				var _x = p.ContainsOperator()

				localctx.(*RelationColumnContext).rtContainsOperator = _x
			}
			{
				p.SetState(1240)

				var _x = p.Term()

				localctx.(*RelationColumnContext).t = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		localctx = NewRelationTokenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1244)
			p.Match(Cql3ParserK_TOKEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1245)

			var _x = p.TupleOfIdentifiers()

			localctx.(*RelationTokenContext).l = _x
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserT__16, Cql3ParserT__17, Cql3ParserT__18, Cql3ParserT__19, Cql3ParserT__20, Cql3ParserT__21:
			{
				p.SetState(1246)

				var _x = p.RelationType()

				localctx.(*RelationTokenContext).type_ = _x
			}
			{
				p.SetState(1247)

				var _x = p.Term()

				localctx.(*RelationTokenContext).t = _x
			}

		case Cql3ParserK_BETWEEN:
			{
				p.SetState(1249)
				p.Match(Cql3ParserK_BETWEEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1250)

				var _x = p.SingleColumnBetweenValues()

				localctx.(*RelationTokenContext).betweenValues = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewRelationCollectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1253)

			var _x = p.Cident()

			localctx.(*RelationCollectionContext).name = _x
		}
		{
			p.SetState(1254)
			p.Match(Cql3ParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)

			var _x = p.Term()

			localctx.(*RelationCollectionContext).key = _x
		}
		{
			p.SetState(1256)
			p.Match(Cql3ParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1257)

			var _x = p.RelationType()

			localctx.(*RelationCollectionContext).type_ = _x
		}
		{
			p.SetState(1258)

			var _x = p.Term()

			localctx.(*RelationCollectionContext).t = _x
		}

	case 4:
		localctx = NewRelationTupleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1260)

			var _x = p.TupleOfIdentifiers()

			localctx.(*RelationTupleContext).ids = _x
		}
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cql3ParserK_IN, Cql3ParserK_NOT:
			{
				p.SetState(1261)

				var _x = p.InOperator()

				localctx.(*RelationTupleContext).rt = _x
			}
			{
				p.SetState(1262)

				var _x = p.MultiColumnInValues()

				localctx.(*RelationTupleContext).minValue = _x
			}

		case Cql3ParserT__16, Cql3ParserT__17, Cql3ParserT__18, Cql3ParserT__19, Cql3ParserT__20, Cql3ParserT__21:
			{
				p.SetState(1264)

				var _x = p.RelationType()

				localctx.(*RelationTupleContext).type_ = _x
			}
			{
				p.SetState(1265)

				var _x = p.MultiColumnValue()

				localctx.(*RelationTupleContext).v = _x
			}

		case Cql3ParserK_BETWEEN:
			{
				p.SetState(1267)
				p.Match(Cql3ParserK_BETWEEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1268)

				var _x = p.MultiColumnValue()

				localctx.(*RelationTupleContext).t1 = _x
			}
			{
				p.SetState(1269)
				p.Match(Cql3ParserK_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1270)

				var _x = p.MultiColumnValue()

				localctx.(*RelationTupleContext).t2 = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewRelationRecursiveContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1274)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.Relation()
		}
		{
			p.SetState(1276)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContainsOperatorContext is an interface to support dynamic dispatch.
type IContainsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CONTAINS() antlr.TerminalNode
	K_KEY() antlr.TerminalNode
	K_NOT() antlr.TerminalNode

	// IsContainsOperatorContext differentiates from other interfaces.
	IsContainsOperatorContext()
}

type ContainsOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainsOperatorContext() *ContainsOperatorContext {
	var p = new(ContainsOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_containsOperator
	return p
}

func InitEmptyContainsOperatorContext(p *ContainsOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_containsOperator
}

func (*ContainsOperatorContext) IsContainsOperatorContext() {}

func NewContainsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainsOperatorContext {
	var p = new(ContainsOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_containsOperator

	return p
}

func (s *ContainsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainsOperatorContext) K_CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CONTAINS, 0)
}

func (s *ContainsOperatorContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEY, 0)
}

func (s *ContainsOperatorContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOT, 0)
}

func (s *ContainsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainsOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitContainsOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ContainsOperator() (localctx IContainsOperatorContext) {
	localctx = NewContainsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Cql3ParserRULE_containsOperator)
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_CONTAINS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1280)
			p.Match(Cql3ParserK_CONTAINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1281)
				p.Match(Cql3ParserK_KEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case Cql3ParserK_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1284)
			p.Match(Cql3ParserK_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.Match(Cql3ParserK_CONTAINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1286)
				p.Match(Cql3ParserK_KEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInOperatorContext is an interface to support dynamic dispatch.
type IInOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IN() antlr.TerminalNode
	K_NOT() antlr.TerminalNode

	// IsInOperatorContext differentiates from other interfaces.
	IsInOperatorContext()
}

type InOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInOperatorContext() *InOperatorContext {
	var p = new(InOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_inOperator
	return p
}

func InitEmptyInOperatorContext(p *InOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_inOperator
}

func (*InOperatorContext) IsInOperatorContext() {}

func NewInOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InOperatorContext {
	var p = new(InOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_inOperator

	return p
}

func (s *InOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InOperatorContext) K_IN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IN, 0)
}

func (s *InOperatorContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOT, 0)
}

func (s *InOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitInOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) InOperator() (localctx IInOperatorContext) {
	localctx = NewInOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Cql3ParserRULE_inOperator)
	p.SetState(1294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_IN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1291)
			p.Match(Cql3ParserK_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1292)
			p.Match(Cql3ParserK_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1293)
			p.Match(Cql3ParserK_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInMarkerContext is an interface to support dynamic dispatch.
type IInMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() INoncol_identContext

	// SetName sets the name rule contexts.
	SetName(INoncol_identContext)

	// Getter signatures
	QMARK() antlr.TerminalNode
	Noncol_ident() INoncol_identContext

	// IsInMarkerContext differentiates from other interfaces.
	IsInMarkerContext()
}

type InMarkerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   INoncol_identContext
}

func NewEmptyInMarkerContext() *InMarkerContext {
	var p = new(InMarkerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_inMarker
	return p
}

func InitEmptyInMarkerContext(p *InMarkerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_inMarker
}

func (*InMarkerContext) IsInMarkerContext() {}

func NewInMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InMarkerContext {
	var p = new(InMarkerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_inMarker

	return p
}

func (s *InMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *InMarkerContext) GetName() INoncol_identContext { return s.name }

func (s *InMarkerContext) SetName(v INoncol_identContext) { s.name = v }

func (s *InMarkerContext) QMARK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQMARK, 0)
}

func (s *InMarkerContext) Noncol_ident() INoncol_identContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoncol_identContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoncol_identContext)
}

func (s *InMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitInMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) InMarker() (localctx IInMarkerContext) {
	localctx = NewInMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Cql3ParserRULE_inMarker)
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1296)
			p.Match(Cql3ParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserT__14:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.Match(Cql3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1298)

			var _x = p.Noncol_ident()

			localctx.(*InMarkerContext).name = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleOfIdentifiersContext is an interface to support dynamic dispatch.
type ITupleOfIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetN1 returns the n1 rule contexts.
	GetN1() ICidentContext

	// GetNi returns the ni rule contexts.
	GetNi() ICidentContext

	// SetN1 sets the n1 rule contexts.
	SetN1(ICidentContext)

	// SetNi sets the ni rule contexts.
	SetNi(ICidentContext)

	// Getter signatures
	AllCident() []ICidentContext
	Cident(i int) ICidentContext

	// IsTupleOfIdentifiersContext differentiates from other interfaces.
	IsTupleOfIdentifiersContext()
}

type TupleOfIdentifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	n1     ICidentContext
	ni     ICidentContext
}

func NewEmptyTupleOfIdentifiersContext() *TupleOfIdentifiersContext {
	var p = new(TupleOfIdentifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfIdentifiers
	return p
}

func InitEmptyTupleOfIdentifiersContext(p *TupleOfIdentifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfIdentifiers
}

func (*TupleOfIdentifiersContext) IsTupleOfIdentifiersContext() {}

func NewTupleOfIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleOfIdentifiersContext {
	var p = new(TupleOfIdentifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tupleOfIdentifiers

	return p
}

func (s *TupleOfIdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleOfIdentifiersContext) GetN1() ICidentContext { return s.n1 }

func (s *TupleOfIdentifiersContext) GetNi() ICidentContext { return s.ni }

func (s *TupleOfIdentifiersContext) SetN1(v ICidentContext) { s.n1 = v }

func (s *TupleOfIdentifiersContext) SetNi(v ICidentContext) { s.ni = v }

func (s *TupleOfIdentifiersContext) AllCident() []ICidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICidentContext); ok {
			len++
		}
	}

	tst := make([]ICidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICidentContext); ok {
			tst[i] = t.(ICidentContext)
			i++
		}
	}

	return tst
}

func (s *TupleOfIdentifiersContext) Cident(i int) ICidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICidentContext)
}

func (s *TupleOfIdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleOfIdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleOfIdentifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTupleOfIdentifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TupleOfIdentifiers() (localctx ITupleOfIdentifiersContext) {
	localctx = NewTupleOfIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Cql3ParserRULE_tupleOfIdentifiers)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1301)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1302)

		var _x = p.Cident()

		localctx.(*TupleOfIdentifiersContext).n1 = _x
	}
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1303)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)

			var _x = p.Cident()

			localctx.(*TupleOfIdentifiersContext).ni = _x
		}

		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1310)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleColumnInValuesContext is an interface to support dynamic dispatch.
type ISingleColumnInValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() ITermsContext

	// GetM returns the m rule contexts.
	GetM() IInMarkerContext

	// SetT sets the t rule contexts.
	SetT(ITermsContext)

	// SetM sets the m rule contexts.
	SetM(IInMarkerContext)

	// Getter signatures
	Terms() ITermsContext
	InMarker() IInMarkerContext

	// IsSingleColumnInValuesContext differentiates from other interfaces.
	IsSingleColumnInValuesContext()
}

type SingleColumnInValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t      ITermsContext
	m      IInMarkerContext
}

func NewEmptySingleColumnInValuesContext() *SingleColumnInValuesContext {
	var p = new(SingleColumnInValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_singleColumnInValues
	return p
}

func InitEmptySingleColumnInValuesContext(p *SingleColumnInValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_singleColumnInValues
}

func (*SingleColumnInValuesContext) IsSingleColumnInValuesContext() {}

func NewSingleColumnInValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleColumnInValuesContext {
	var p = new(SingleColumnInValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_singleColumnInValues

	return p
}

func (s *SingleColumnInValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleColumnInValuesContext) GetT() ITermsContext { return s.t }

func (s *SingleColumnInValuesContext) GetM() IInMarkerContext { return s.m }

func (s *SingleColumnInValuesContext) SetT(v ITermsContext) { s.t = v }

func (s *SingleColumnInValuesContext) SetM(v IInMarkerContext) { s.m = v }

func (s *SingleColumnInValuesContext) Terms() ITermsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermsContext)
}

func (s *SingleColumnInValuesContext) InMarker() IInMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInMarkerContext)
}

func (s *SingleColumnInValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleColumnInValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleColumnInValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitSingleColumnInValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) SingleColumnInValues() (localctx ISingleColumnInValuesContext) {
	localctx = NewSingleColumnInValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Cql3ParserRULE_singleColumnInValues)
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__10:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1312)

			var _x = p.Terms()

			localctx.(*SingleColumnInValuesContext).t = _x
		}

	case Cql3ParserT__14, Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1313)

			var _x = p.InMarker()

			localctx.(*SingleColumnInValuesContext).m = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermsContext is an interface to support dynamic dispatch.
type ITermsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITermContext

	// GetTi returns the ti rule contexts.
	GetTi() ITermContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITermContext)

	// SetTi sets the ti rule contexts.
	SetTi(ITermContext)

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsTermsContext differentiates from other interfaces.
	IsTermsContext()
}

type TermsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITermContext
	ti     ITermContext
}

func NewEmptyTermsContext() *TermsContext {
	var p = new(TermsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_terms
	return p
}

func InitEmptyTermsContext(p *TermsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_terms
}

func (*TermsContext) IsTermsContext() {}

func NewTermsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermsContext {
	var p = new(TermsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_terms

	return p
}

func (s *TermsContext) GetParser() antlr.Parser { return s.parser }

func (s *TermsContext) GetT1() ITermContext { return s.t1 }

func (s *TermsContext) GetTi() ITermContext { return s.ti }

func (s *TermsContext) SetT1(v ITermContext) { s.t1 = v }

func (s *TermsContext) SetTi(v ITermContext) { s.ti = v }

func (s *TermsContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *TermsContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTerms(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Terms() (localctx ITermsContext) {
	localctx = NewTermsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Cql3ParserRULE_terms)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621500254109346336) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-68216617073) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&9142306144050413567) != 0) {
		{
			p.SetState(1317)

			var _x = p.Term()

			localctx.(*TermsContext).t1 = _x
		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cql3ParserT__1 {
			{
				p.SetState(1318)
				p.Match(Cql3ParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1319)

				var _x = p.Term()

				localctx.(*TermsContext).ti = _x
			}

			p.SetState(1324)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1327)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiColumnValueContext is an interface to support dynamic dispatch.
type IMultiColumnValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ITupleLiteralContext

	// GetM returns the m rule contexts.
	GetM() IMarkerContext

	// SetL sets the l rule contexts.
	SetL(ITupleLiteralContext)

	// SetM sets the m rule contexts.
	SetM(IMarkerContext)

	// Getter signatures
	TupleLiteral() ITupleLiteralContext
	Marker() IMarkerContext

	// IsMultiColumnValueContext differentiates from other interfaces.
	IsMultiColumnValueContext()
}

type MultiColumnValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	l      ITupleLiteralContext
	m      IMarkerContext
}

func NewEmptyMultiColumnValueContext() *MultiColumnValueContext {
	var p = new(MultiColumnValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_multiColumnValue
	return p
}

func InitEmptyMultiColumnValueContext(p *MultiColumnValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_multiColumnValue
}

func (*MultiColumnValueContext) IsMultiColumnValueContext() {}

func NewMultiColumnValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiColumnValueContext {
	var p = new(MultiColumnValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_multiColumnValue

	return p
}

func (s *MultiColumnValueContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiColumnValueContext) GetL() ITupleLiteralContext { return s.l }

func (s *MultiColumnValueContext) GetM() IMarkerContext { return s.m }

func (s *MultiColumnValueContext) SetL(v ITupleLiteralContext) { s.l = v }

func (s *MultiColumnValueContext) SetM(v IMarkerContext) { s.m = v }

func (s *MultiColumnValueContext) TupleLiteral() ITupleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralContext)
}

func (s *MultiColumnValueContext) Marker() IMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *MultiColumnValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiColumnValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitMultiColumnValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) MultiColumnValue() (localctx IMultiColumnValueContext) {
	localctx = NewMultiColumnValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Cql3ParserRULE_multiColumnValue)
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserT__10:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)

			var _x = p.TupleLiteral()

			localctx.(*MultiColumnValueContext).l = _x
		}

	case Cql3ParserT__14, Cql3ParserQMARK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)

			var _x = p.Marker()

			localctx.(*MultiColumnValueContext).m = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiColumnInValuesContext is an interface to support dynamic dispatch.
type IMultiColumnInValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m rule contexts.
	GetM() IInMarkerContext

	// GetTl returns the tl rule contexts.
	GetTl() ITupleOfTupleLiteralsContext

	// GetTm returns the tm rule contexts.
	GetTm() ITupleOfMarkersForTuplesContext

	// SetM sets the m rule contexts.
	SetM(IInMarkerContext)

	// SetTl sets the tl rule contexts.
	SetTl(ITupleOfTupleLiteralsContext)

	// SetTm sets the tm rule contexts.
	SetTm(ITupleOfMarkersForTuplesContext)

	// Getter signatures
	InMarker() IInMarkerContext
	TupleOfTupleLiterals() ITupleOfTupleLiteralsContext
	TupleOfMarkersForTuples() ITupleOfMarkersForTuplesContext

	// IsMultiColumnInValuesContext differentiates from other interfaces.
	IsMultiColumnInValuesContext()
}

type MultiColumnInValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	m      IInMarkerContext
	tl     ITupleOfTupleLiteralsContext
	tm     ITupleOfMarkersForTuplesContext
}

func NewEmptyMultiColumnInValuesContext() *MultiColumnInValuesContext {
	var p = new(MultiColumnInValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_multiColumnInValues
	return p
}

func InitEmptyMultiColumnInValuesContext(p *MultiColumnInValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_multiColumnInValues
}

func (*MultiColumnInValuesContext) IsMultiColumnInValuesContext() {}

func NewMultiColumnInValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiColumnInValuesContext {
	var p = new(MultiColumnInValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_multiColumnInValues

	return p
}

func (s *MultiColumnInValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiColumnInValuesContext) GetM() IInMarkerContext { return s.m }

func (s *MultiColumnInValuesContext) GetTl() ITupleOfTupleLiteralsContext { return s.tl }

func (s *MultiColumnInValuesContext) GetTm() ITupleOfMarkersForTuplesContext { return s.tm }

func (s *MultiColumnInValuesContext) SetM(v IInMarkerContext) { s.m = v }

func (s *MultiColumnInValuesContext) SetTl(v ITupleOfTupleLiteralsContext) { s.tl = v }

func (s *MultiColumnInValuesContext) SetTm(v ITupleOfMarkersForTuplesContext) { s.tm = v }

func (s *MultiColumnInValuesContext) InMarker() IInMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInMarkerContext)
}

func (s *MultiColumnInValuesContext) TupleOfTupleLiterals() ITupleOfTupleLiteralsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleOfTupleLiteralsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleOfTupleLiteralsContext)
}

func (s *MultiColumnInValuesContext) TupleOfMarkersForTuples() ITupleOfMarkersForTuplesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleOfMarkersForTuplesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleOfMarkersForTuplesContext)
}

func (s *MultiColumnInValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnInValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiColumnInValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitMultiColumnInValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) MultiColumnInValues() (localctx IMultiColumnInValuesContext) {
	localctx = NewMultiColumnInValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Cql3ParserRULE_multiColumnInValues)
	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1333)
			p.Match(Cql3ParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Match(Cql3ParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1335)

			var _x = p.InMarker()

			localctx.(*MultiColumnInValuesContext).m = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1336)

			var _x = p.TupleOfTupleLiterals()

			localctx.(*MultiColumnInValuesContext).tl = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1337)

			var _x = p.TupleOfMarkersForTuples()

			localctx.(*MultiColumnInValuesContext).tm = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleOfTupleLiteralsContext is an interface to support dynamic dispatch.
type ITupleOfTupleLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() ITupleLiteralContext

	// GetTi returns the ti rule contexts.
	GetTi() ITupleLiteralContext

	// SetT1 sets the t1 rule contexts.
	SetT1(ITupleLiteralContext)

	// SetTi sets the ti rule contexts.
	SetTi(ITupleLiteralContext)

	// Getter signatures
	AllTupleLiteral() []ITupleLiteralContext
	TupleLiteral(i int) ITupleLiteralContext

	// IsTupleOfTupleLiteralsContext differentiates from other interfaces.
	IsTupleOfTupleLiteralsContext()
}

type TupleOfTupleLiteralsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     ITupleLiteralContext
	ti     ITupleLiteralContext
}

func NewEmptyTupleOfTupleLiteralsContext() *TupleOfTupleLiteralsContext {
	var p = new(TupleOfTupleLiteralsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfTupleLiterals
	return p
}

func InitEmptyTupleOfTupleLiteralsContext(p *TupleOfTupleLiteralsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfTupleLiterals
}

func (*TupleOfTupleLiteralsContext) IsTupleOfTupleLiteralsContext() {}

func NewTupleOfTupleLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleOfTupleLiteralsContext {
	var p = new(TupleOfTupleLiteralsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tupleOfTupleLiterals

	return p
}

func (s *TupleOfTupleLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleOfTupleLiteralsContext) GetT1() ITupleLiteralContext { return s.t1 }

func (s *TupleOfTupleLiteralsContext) GetTi() ITupleLiteralContext { return s.ti }

func (s *TupleOfTupleLiteralsContext) SetT1(v ITupleLiteralContext) { s.t1 = v }

func (s *TupleOfTupleLiteralsContext) SetTi(v ITupleLiteralContext) { s.ti = v }

func (s *TupleOfTupleLiteralsContext) AllTupleLiteral() []ITupleLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			len++
		}
	}

	tst := make([]ITupleLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleLiteralContext); ok {
			tst[i] = t.(ITupleLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TupleOfTupleLiteralsContext) TupleLiteral(i int) ITupleLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralContext)
}

func (s *TupleOfTupleLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleOfTupleLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleOfTupleLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTupleOfTupleLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TupleOfTupleLiterals() (localctx ITupleOfTupleLiteralsContext) {
	localctx = NewTupleOfTupleLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Cql3ParserRULE_tupleOfTupleLiterals)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1341)

		var _x = p.TupleLiteral()

		localctx.(*TupleOfTupleLiteralsContext).t1 = _x
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1342)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)

			var _x = p.TupleLiteral()

			localctx.(*TupleOfTupleLiteralsContext).ti = _x
		}

		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1349)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleOfMarkersForTuplesContext is an interface to support dynamic dispatch.
type ITupleOfMarkersForTuplesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM1 returns the m1 rule contexts.
	GetM1() IMarkerContext

	// GetMi returns the mi rule contexts.
	GetMi() IMarkerContext

	// SetM1 sets the m1 rule contexts.
	SetM1(IMarkerContext)

	// SetMi sets the mi rule contexts.
	SetMi(IMarkerContext)

	// Getter signatures
	AllMarker() []IMarkerContext
	Marker(i int) IMarkerContext

	// IsTupleOfMarkersForTuplesContext differentiates from other interfaces.
	IsTupleOfMarkersForTuplesContext()
}

type TupleOfMarkersForTuplesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	m1     IMarkerContext
	mi     IMarkerContext
}

func NewEmptyTupleOfMarkersForTuplesContext() *TupleOfMarkersForTuplesContext {
	var p = new(TupleOfMarkersForTuplesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfMarkersForTuples
	return p
}

func InitEmptyTupleOfMarkersForTuplesContext(p *TupleOfMarkersForTuplesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tupleOfMarkersForTuples
}

func (*TupleOfMarkersForTuplesContext) IsTupleOfMarkersForTuplesContext() {}

func NewTupleOfMarkersForTuplesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleOfMarkersForTuplesContext {
	var p = new(TupleOfMarkersForTuplesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tupleOfMarkersForTuples

	return p
}

func (s *TupleOfMarkersForTuplesContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleOfMarkersForTuplesContext) GetM1() IMarkerContext { return s.m1 }

func (s *TupleOfMarkersForTuplesContext) GetMi() IMarkerContext { return s.mi }

func (s *TupleOfMarkersForTuplesContext) SetM1(v IMarkerContext) { s.m1 = v }

func (s *TupleOfMarkersForTuplesContext) SetMi(v IMarkerContext) { s.mi = v }

func (s *TupleOfMarkersForTuplesContext) AllMarker() []IMarkerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMarkerContext); ok {
			len++
		}
	}

	tst := make([]IMarkerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMarkerContext); ok {
			tst[i] = t.(IMarkerContext)
			i++
		}
	}

	return tst
}

func (s *TupleOfMarkersForTuplesContext) Marker(i int) IMarkerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerContext)
}

func (s *TupleOfMarkersForTuplesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleOfMarkersForTuplesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleOfMarkersForTuplesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTupleOfMarkersForTuples(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) TupleOfMarkersForTuples() (localctx ITupleOfMarkersForTuplesContext) {
	localctx = NewTupleOfMarkersForTuplesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Cql3ParserRULE_tupleOfMarkersForTuples)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1351)
		p.Match(Cql3ParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1352)

		var _x = p.Marker()

		localctx.(*TupleOfMarkersForTuplesContext).m1 = _x
	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1353)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1354)

			var _x = p.Marker()

			localctx.(*TupleOfMarkersForTuplesContext).mi = _x
		}

		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1360)
		p.Match(Cql3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparatorTypeContext is an interface to support dynamic dispatch.
type IComparatorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s token.
	GetS() antlr.Token

	// SetS sets the s token.
	SetS(antlr.Token)

	// GetN returns the n rule contexts.
	GetN() INative_typeContext

	// GetC returns the c rule contexts.
	GetC() ICollection_typeContext

	// GetTt returns the tt rule contexts.
	GetTt() ITuple_typeContext

	// GetVc returns the vc rule contexts.
	GetVc() IVector_typeContext

	// GetId returns the id rule contexts.
	GetId() IUserTypeNameContext

	// GetF returns the f rule contexts.
	GetF() IComparatorTypeContext

	// SetN sets the n rule contexts.
	SetN(INative_typeContext)

	// SetC sets the c rule contexts.
	SetC(ICollection_typeContext)

	// SetTt sets the tt rule contexts.
	SetTt(ITuple_typeContext)

	// SetVc sets the vc rule contexts.
	SetVc(IVector_typeContext)

	// SetId sets the id rule contexts.
	SetId(IUserTypeNameContext)

	// SetF sets the f rule contexts.
	SetF(IComparatorTypeContext)

	// Getter signatures
	Native_type() INative_typeContext
	Collection_type() ICollection_typeContext
	Tuple_type() ITuple_typeContext
	Vector_type() IVector_typeContext
	UserTypeName() IUserTypeNameContext
	K_FROZEN() antlr.TerminalNode
	ComparatorType() IComparatorTypeContext
	STRING_LITERAL() antlr.TerminalNode

	// IsComparatorTypeContext differentiates from other interfaces.
	IsComparatorTypeContext()
}

type ComparatorTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	n      INative_typeContext
	c      ICollection_typeContext
	tt     ITuple_typeContext
	vc     IVector_typeContext
	id     IUserTypeNameContext
	f      IComparatorTypeContext
	s      antlr.Token
}

func NewEmptyComparatorTypeContext() *ComparatorTypeContext {
	var p = new(ComparatorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_comparatorType
	return p
}

func InitEmptyComparatorTypeContext(p *ComparatorTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_comparatorType
}

func (*ComparatorTypeContext) IsComparatorTypeContext() {}

func NewComparatorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparatorTypeContext {
	var p = new(ComparatorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_comparatorType

	return p
}

func (s *ComparatorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparatorTypeContext) GetS() antlr.Token { return s.s }

func (s *ComparatorTypeContext) SetS(v antlr.Token) { s.s = v }

func (s *ComparatorTypeContext) GetN() INative_typeContext { return s.n }

func (s *ComparatorTypeContext) GetC() ICollection_typeContext { return s.c }

func (s *ComparatorTypeContext) GetTt() ITuple_typeContext { return s.tt }

func (s *ComparatorTypeContext) GetVc() IVector_typeContext { return s.vc }

func (s *ComparatorTypeContext) GetId() IUserTypeNameContext { return s.id }

func (s *ComparatorTypeContext) GetF() IComparatorTypeContext { return s.f }

func (s *ComparatorTypeContext) SetN(v INative_typeContext) { s.n = v }

func (s *ComparatorTypeContext) SetC(v ICollection_typeContext) { s.c = v }

func (s *ComparatorTypeContext) SetTt(v ITuple_typeContext) { s.tt = v }

func (s *ComparatorTypeContext) SetVc(v IVector_typeContext) { s.vc = v }

func (s *ComparatorTypeContext) SetId(v IUserTypeNameContext) { s.id = v }

func (s *ComparatorTypeContext) SetF(v IComparatorTypeContext) { s.f = v }

func (s *ComparatorTypeContext) Native_type() INative_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INative_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INative_typeContext)
}

func (s *ComparatorTypeContext) Collection_type() ICollection_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollection_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *ComparatorTypeContext) Tuple_type() ITuple_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuple_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuple_typeContext)
}

func (s *ComparatorTypeContext) Vector_type() IVector_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVector_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVector_typeContext)
}

func (s *ComparatorTypeContext) UserTypeName() IUserTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeNameContext)
}

func (s *ComparatorTypeContext) K_FROZEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FROZEN, 0)
}

func (s *ComparatorTypeContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *ComparatorTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *ComparatorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparatorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparatorTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitComparatorType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) ComparatorType() (localctx IComparatorTypeContext) {
	localctx = NewComparatorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Cql3ParserRULE_comparatorType)
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1362)

			var _x = p.Native_type()

			localctx.(*ComparatorTypeContext).n = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1363)

			var _x = p.Collection_type()

			localctx.(*ComparatorTypeContext).c = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1364)

			var _x = p.Tuple_type()

			localctx.(*ComparatorTypeContext).tt = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1365)

			var _x = p.Vector_type()

			localctx.(*ComparatorTypeContext).vc = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1366)

			var _x = p.UserTypeName()

			localctx.(*ComparatorTypeContext).id = _x
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1367)
			p.Match(Cql3ParserK_FROZEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.Match(Cql3ParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1369)

			var _x = p.ComparatorType()

			localctx.(*ComparatorTypeContext).f = _x
		}
		{
			p.SetState(1370)
			p.Match(Cql3ParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1372)

			var _m = p.Match(Cql3ParserSTRING_LITERAL)

			localctx.(*ComparatorTypeContext).s = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INative_typeContext is an interface to support dynamic dispatch.
type INative_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ASCII() antlr.TerminalNode
	K_BIGINT() antlr.TerminalNode
	K_BLOB() antlr.TerminalNode
	K_BOOLEAN() antlr.TerminalNode
	K_COUNTER() antlr.TerminalNode
	K_DECIMAL() antlr.TerminalNode
	K_DOUBLE() antlr.TerminalNode
	K_DURATION() antlr.TerminalNode
	K_FLOAT() antlr.TerminalNode
	K_INET() antlr.TerminalNode
	K_INT() antlr.TerminalNode
	K_SMALLINT() antlr.TerminalNode
	K_TEXT() antlr.TerminalNode
	K_TIMESTAMP() antlr.TerminalNode
	K_TINYINT() antlr.TerminalNode
	K_UUID() antlr.TerminalNode
	K_VARCHAR() antlr.TerminalNode
	K_VARINT() antlr.TerminalNode
	K_TIMEUUID() antlr.TerminalNode
	K_DATE() antlr.TerminalNode
	K_TIME() antlr.TerminalNode

	// IsNative_typeContext differentiates from other interfaces.
	IsNative_typeContext()
}

type Native_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNative_typeContext() *Native_typeContext {
	var p = new(Native_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_native_type
	return p
}

func InitEmptyNative_typeContext(p *Native_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_native_type
}

func (*Native_typeContext) IsNative_typeContext() {}

func NewNative_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Native_typeContext {
	var p = new(Native_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_native_type

	return p
}

func (s *Native_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Native_typeContext) K_ASCII() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ASCII, 0)
}

func (s *Native_typeContext) K_BIGINT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BIGINT, 0)
}

func (s *Native_typeContext) K_BLOB() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BLOB, 0)
}

func (s *Native_typeContext) K_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BOOLEAN, 0)
}

func (s *Native_typeContext) K_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COUNTER, 0)
}

func (s *Native_typeContext) K_DECIMAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DECIMAL, 0)
}

func (s *Native_typeContext) K_DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DOUBLE, 0)
}

func (s *Native_typeContext) K_DURATION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DURATION, 0)
}

func (s *Native_typeContext) K_FLOAT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FLOAT, 0)
}

func (s *Native_typeContext) K_INET() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INET, 0)
}

func (s *Native_typeContext) K_INT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INT, 0)
}

func (s *Native_typeContext) K_SMALLINT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SMALLINT, 0)
}

func (s *Native_typeContext) K_TEXT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TEXT, 0)
}

func (s *Native_typeContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TIMESTAMP, 0)
}

func (s *Native_typeContext) K_TINYINT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TINYINT, 0)
}

func (s *Native_typeContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_UUID, 0)
}

func (s *Native_typeContext) K_VARCHAR() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VARCHAR, 0)
}

func (s *Native_typeContext) K_VARINT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VARINT, 0)
}

func (s *Native_typeContext) K_TIMEUUID() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TIMEUUID, 0)
}

func (s *Native_typeContext) K_DATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DATE, 0)
}

func (s *Native_typeContext) K_TIME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TIME, 0)
}

func (s *Native_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Native_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Native_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitNative_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Native_type() (localctx INative_typeContext) {
	localctx = NewNative_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Cql3ParserRULE_native_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-36028797018963967) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&12799) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() IComparatorTypeContext

	// GetT2 returns the t2 rule contexts.
	GetT2() IComparatorTypeContext

	// GetT returns the t rule contexts.
	GetT() IComparatorTypeContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IComparatorTypeContext)

	// SetT2 sets the t2 rule contexts.
	SetT2(IComparatorTypeContext)

	// SetT sets the t rule contexts.
	SetT(IComparatorTypeContext)

	// Getter signatures
	K_MAP() antlr.TerminalNode
	AllComparatorType() []IComparatorTypeContext
	ComparatorType(i int) IComparatorTypeContext
	K_LIST() antlr.TerminalNode
	K_SET() antlr.TerminalNode

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IComparatorTypeContext
	t2     IComparatorTypeContext
	t      IComparatorTypeContext
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collection_type
	return p
}

func InitEmptyCollection_typeContext(p *Collection_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_collection_type
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) GetT1() IComparatorTypeContext { return s.t1 }

func (s *Collection_typeContext) GetT2() IComparatorTypeContext { return s.t2 }

func (s *Collection_typeContext) GetT() IComparatorTypeContext { return s.t }

func (s *Collection_typeContext) SetT1(v IComparatorTypeContext) { s.t1 = v }

func (s *Collection_typeContext) SetT2(v IComparatorTypeContext) { s.t2 = v }

func (s *Collection_typeContext) SetT(v IComparatorTypeContext) { s.t = v }

func (s *Collection_typeContext) K_MAP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MAP, 0)
}

func (s *Collection_typeContext) AllComparatorType() []IComparatorTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			len++
		}
	}

	tst := make([]IComparatorTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparatorTypeContext); ok {
			tst[i] = t.(IComparatorTypeContext)
			i++
		}
	}

	return tst
}

func (s *Collection_typeContext) ComparatorType(i int) IComparatorTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *Collection_typeContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIST, 0)
}

func (s *Collection_typeContext) K_SET() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SET, 0)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitCollection_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Cql3ParserRULE_collection_type)
	p.SetState(1394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_MAP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1377)
			p.Match(Cql3ParserK_MAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Match(Cql3ParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1379)

			var _x = p.ComparatorType()

			localctx.(*Collection_typeContext).t1 = _x
		}
		{
			p.SetState(1380)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1381)

			var _x = p.ComparatorType()

			localctx.(*Collection_typeContext).t2 = _x
		}
		{
			p.SetState(1382)
			p.Match(Cql3ParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_LIST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1384)
			p.Match(Cql3ParserK_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1385)
			p.Match(Cql3ParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)

			var _x = p.ComparatorType()

			localctx.(*Collection_typeContext).t = _x
		}
		{
			p.SetState(1387)
			p.Match(Cql3ParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_SET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1389)
			p.Match(Cql3ParserK_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1390)
			p.Match(Cql3ParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1391)

			var _x = p.ComparatorType()

			localctx.(*Collection_typeContext).t = _x
		}
		{
			p.SetState(1392)
			p.Match(Cql3ParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuple_typeContext is an interface to support dynamic dispatch.
type ITuple_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT1 returns the t1 rule contexts.
	GetT1() IComparatorTypeContext

	// GetTn returns the tn rule contexts.
	GetTn() IComparatorTypeContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IComparatorTypeContext)

	// SetTn sets the tn rule contexts.
	SetTn(IComparatorTypeContext)

	// Getter signatures
	K_TUPLE() antlr.TerminalNode
	AllComparatorType() []IComparatorTypeContext
	ComparatorType(i int) IComparatorTypeContext

	// IsTuple_typeContext differentiates from other interfaces.
	IsTuple_typeContext()
}

type Tuple_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IComparatorTypeContext
	tn     IComparatorTypeContext
}

func NewEmptyTuple_typeContext() *Tuple_typeContext {
	var p = new(Tuple_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tuple_type
	return p
}

func InitEmptyTuple_typeContext(p *Tuple_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_tuple_type
}

func (*Tuple_typeContext) IsTuple_typeContext() {}

func NewTuple_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tuple_typeContext {
	var p = new(Tuple_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_tuple_type

	return p
}

func (s *Tuple_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tuple_typeContext) GetT1() IComparatorTypeContext { return s.t1 }

func (s *Tuple_typeContext) GetTn() IComparatorTypeContext { return s.tn }

func (s *Tuple_typeContext) SetT1(v IComparatorTypeContext) { s.t1 = v }

func (s *Tuple_typeContext) SetTn(v IComparatorTypeContext) { s.tn = v }

func (s *Tuple_typeContext) K_TUPLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TUPLE, 0)
}

func (s *Tuple_typeContext) AllComparatorType() []IComparatorTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			len++
		}
	}

	tst := make([]IComparatorTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparatorTypeContext); ok {
			tst[i] = t.(IComparatorTypeContext)
			i++
		}
	}

	return tst
}

func (s *Tuple_typeContext) ComparatorType(i int) IComparatorTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *Tuple_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tuple_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tuple_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitTuple_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Tuple_type() (localctx ITuple_typeContext) {
	localctx = NewTuple_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Cql3ParserRULE_tuple_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1396)
		p.Match(Cql3ParserK_TUPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1397)
		p.Match(Cql3ParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1398)

		var _x = p.ComparatorType()

		localctx.(*Tuple_typeContext).t1 = _x
	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cql3ParserT__1 {
		{
			p.SetState(1399)
			p.Match(Cql3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1400)

			var _x = p.ComparatorType()

			localctx.(*Tuple_typeContext).tn = _x
		}

		p.SetState(1405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1406)
		p.Match(Cql3ParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVector_typeContext is an interface to support dynamic dispatch.
type IVector_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// GetT1 returns the t1 rule contexts.
	GetT1() IComparatorTypeContext

	// SetT1 sets the t1 rule contexts.
	SetT1(IComparatorTypeContext)

	// Getter signatures
	K_VECTOR() antlr.TerminalNode
	ComparatorType() IComparatorTypeContext
	INTEGER() antlr.TerminalNode

	// IsVector_typeContext differentiates from other interfaces.
	IsVector_typeContext()
}

type Vector_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	t1     IComparatorTypeContext
	d      antlr.Token
}

func NewEmptyVector_typeContext() *Vector_typeContext {
	var p = new(Vector_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_vector_type
	return p
}

func InitEmptyVector_typeContext(p *Vector_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_vector_type
}

func (*Vector_typeContext) IsVector_typeContext() {}

func NewVector_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vector_typeContext {
	var p = new(Vector_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_vector_type

	return p
}

func (s *Vector_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Vector_typeContext) GetD() antlr.Token { return s.d }

func (s *Vector_typeContext) SetD(v antlr.Token) { s.d = v }

func (s *Vector_typeContext) GetT1() IComparatorTypeContext { return s.t1 }

func (s *Vector_typeContext) SetT1(v IComparatorTypeContext) { s.t1 = v }

func (s *Vector_typeContext) K_VECTOR() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VECTOR, 0)
}

func (s *Vector_typeContext) ComparatorType() IComparatorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparatorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparatorTypeContext)
}

func (s *Vector_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserINTEGER, 0)
}

func (s *Vector_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vector_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vector_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitVector_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Vector_type() (localctx IVector_typeContext) {
	localctx = NewVector_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Cql3ParserRULE_vector_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.Match(Cql3ParserK_VECTOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1409)
		p.Match(Cql3ParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)

		var _x = p.ComparatorType()

		localctx.(*Vector_typeContext).t1 = _x
	}
	{
		p.SetState(1411)
		p.Match(Cql3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1412)

		var _m = p.Match(Cql3ParserINTEGER)

		localctx.(*Vector_typeContext).d = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1413)
		p.Match(Cql3ParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsernameContext is an interface to support dynamic dispatch.
type IUsernameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	QUOTED_NAME() antlr.TerminalNode

	// IsUsernameContext differentiates from other interfaces.
	IsUsernameContext()
}

type UsernameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsernameContext() *UsernameContext {
	var p = new(UsernameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_username
	return p
}

func InitEmptyUsernameContext(p *UsernameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_username
}

func (*UsernameContext) IsUsernameContext() {}

func NewUsernameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsernameContext {
	var p = new(UsernameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_username

	return p
}

func (s *UsernameContext) GetParser() antlr.Parser { return s.parser }

func (s *UsernameContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *UsernameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *UsernameContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *UsernameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsernameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsernameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUsername(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Username() (localctx IUsernameContext) {
	localctx = NewUsernameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Cql3ParserRULE_username)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1415)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&515) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityContext is an interface to support dynamic dispatch.
type IIdentityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	QUOTED_NAME() antlr.TerminalNode

	// IsIdentityContext differentiates from other interfaces.
	IsIdentityContext()
}

type IdentityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityContext() *IdentityContext {
	var p = new(IdentityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_identity
	return p
}

func InitEmptyIdentityContext(p *IdentityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_identity
}

func (*IdentityContext) IsIdentityContext() {}

func NewIdentityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityContext {
	var p = new(IdentityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_identity

	return p
}

func (s *IdentityContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *IdentityContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserSTRING_LITERAL, 0)
}

func (s *IdentityContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *IdentityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitIdentity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Identity() (localctx IIdentityContext) {
	localctx = NewIdentityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Cql3ParserRULE_identity)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&515) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INon_type_identContext is an interface to support dynamic dispatch.
type INon_type_identContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNon_type_identContext differentiates from other interfaces.
	IsNon_type_identContext()
}

type Non_type_identContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_type_identContext() *Non_type_identContext {
	var p = new(Non_type_identContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_non_type_ident
	return p
}

func InitEmptyNon_type_identContext(p *Non_type_identContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_non_type_ident
}

func (*Non_type_identContext) IsNon_type_identContext() {}

func NewNon_type_identContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_type_identContext {
	var p = new(Non_type_identContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_non_type_ident

	return p
}

func (s *Non_type_identContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_type_identContext) CopyAll(ctx *Non_type_identContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Non_type_identContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_type_identContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NonTypeQuotedIdentContext struct {
	Non_type_identContext
	t antlr.Token
}

func NewNonTypeQuotedIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonTypeQuotedIdentContext {
	var p = new(NonTypeQuotedIdentContext)

	InitEmptyNon_type_identContext(&p.Non_type_identContext)
	p.parser = parser
	p.CopyAll(ctx.(*Non_type_identContext))

	return p
}

func (s *NonTypeQuotedIdentContext) GetT() antlr.Token { return s.t }

func (s *NonTypeQuotedIdentContext) SetT(v antlr.Token) { s.t = v }

func (s *NonTypeQuotedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonTypeQuotedIdentContext) QUOTED_NAME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserQUOTED_NAME, 0)
}

func (s *NonTypeQuotedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitNonTypeQuotedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type NonTypeIdentContext struct {
	Non_type_identContext
	i  antlr.Token
	k  IBasic_unreserved_keywordContext
	kk antlr.Token
}

func NewNonTypeIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonTypeIdentContext {
	var p = new(NonTypeIdentContext)

	InitEmptyNon_type_identContext(&p.Non_type_identContext)
	p.parser = parser
	p.CopyAll(ctx.(*Non_type_identContext))

	return p
}

func (s *NonTypeIdentContext) GetI() antlr.Token { return s.i }

func (s *NonTypeIdentContext) GetKk() antlr.Token { return s.kk }

func (s *NonTypeIdentContext) SetI(v antlr.Token) { s.i = v }

func (s *NonTypeIdentContext) SetKk(v antlr.Token) { s.kk = v }

func (s *NonTypeIdentContext) GetK() IBasic_unreserved_keywordContext { return s.k }

func (s *NonTypeIdentContext) SetK(v IBasic_unreserved_keywordContext) { s.k = v }

func (s *NonTypeIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonTypeIdentContext) IDENT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserIDENT, 0)
}

func (s *NonTypeIdentContext) K_DATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DATE, 0)
}

func (s *NonTypeIdentContext) Basic_unreserved_keyword() IBasic_unreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasic_unreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasic_unreserved_keywordContext)
}

func (s *NonTypeIdentContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEY, 0)
}

func (s *NonTypeIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitNonTypeIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Non_type_ident() (localctx INon_type_identContext) {
	localctx = NewNon_type_identContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Cql3ParserRULE_non_type_ident)
	var _la int

	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_DATE, Cql3ParserIDENT:
		localctx = NewNonTypeIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1419)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NonTypeIdentContext).i = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == Cql3ParserK_DATE || _la == Cql3ParserIDENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NonTypeIdentContext).i = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case Cql3ParserQUOTED_NAME:
		localctx = NewNonTypeQuotedIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1420)

			var _m = p.Match(Cql3ParserQUOTED_NAME)

			localctx.(*NonTypeQuotedIdentContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cql3ParserK_AS, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		localctx = NewNonTypeIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1421)

			var _x = p.Basic_unreserved_keyword()

			localctx.(*NonTypeIdentContext).k = _x
		}

	case Cql3ParserK_KEY:
		localctx = NewNonTypeIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1422)

			var _m = p.Match(Cql3ParserK_KEY)

			localctx.(*NonTypeIdentContext).kk = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnreserved_keywordContext is an interface to support dynamic dispatch.
type IUnreserved_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k token.
	GetK() antlr.Token

	// SetK sets the k token.
	SetK(antlr.Token)

	// GetU returns the u rule contexts.
	GetU() IUnreserved_function_keywordContext

	// SetU sets the u rule contexts.
	SetU(IUnreserved_function_keywordContext)

	// Getter signatures
	Unreserved_function_keyword() IUnreserved_function_keywordContext
	K_TTL() antlr.TerminalNode
	K_COUNT() antlr.TerminalNode
	K_WRITETIME() antlr.TerminalNode
	K_MAXWRITETIME() antlr.TerminalNode
	K_KEY() antlr.TerminalNode
	K_CAST() antlr.TerminalNode
	K_JSON() antlr.TerminalNode
	K_DISTINCT() antlr.TerminalNode

	// IsUnreserved_keywordContext differentiates from other interfaces.
	IsUnreserved_keywordContext()
}

type Unreserved_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IUnreserved_function_keywordContext
	k      antlr.Token
}

func NewEmptyUnreserved_keywordContext() *Unreserved_keywordContext {
	var p = new(Unreserved_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unreserved_keyword
	return p
}

func InitEmptyUnreserved_keywordContext(p *Unreserved_keywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unreserved_keyword
}

func (*Unreserved_keywordContext) IsUnreserved_keywordContext() {}

func NewUnreserved_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unreserved_keywordContext {
	var p = new(Unreserved_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_unreserved_keyword

	return p
}

func (s *Unreserved_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Unreserved_keywordContext) GetK() antlr.Token { return s.k }

func (s *Unreserved_keywordContext) SetK(v antlr.Token) { s.k = v }

func (s *Unreserved_keywordContext) GetU() IUnreserved_function_keywordContext { return s.u }

func (s *Unreserved_keywordContext) SetU(v IUnreserved_function_keywordContext) { s.u = v }

func (s *Unreserved_keywordContext) Unreserved_function_keyword() IUnreserved_function_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_function_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_function_keywordContext)
}

func (s *Unreserved_keywordContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TTL, 0)
}

func (s *Unreserved_keywordContext) K_COUNT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COUNT, 0)
}

func (s *Unreserved_keywordContext) K_WRITETIME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_WRITETIME, 0)
}

func (s *Unreserved_keywordContext) K_MAXWRITETIME() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MAXWRITETIME, 0)
}

func (s *Unreserved_keywordContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEY, 0)
}

func (s *Unreserved_keywordContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CAST, 0)
}

func (s *Unreserved_keywordContext) K_JSON() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_JSON, 0)
}

func (s *Unreserved_keywordContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DISTINCT, 0)
}

func (s *Unreserved_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unreserved_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unreserved_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUnreserved_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Unreserved_keyword() (localctx IUnreserved_keywordContext) {
	localctx = NewUnreserved_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Cql3ParserRULE_unreserved_keyword)
	var _la int

	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_AS, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TIMESTAMP, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_DATE, Cql3ParserK_TIME, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1425)

			var _x = p.Unreserved_function_keyword()

			localctx.(*Unreserved_keywordContext).u = _x
		}

	case Cql3ParserK_KEY, Cql3ParserK_DISTINCT, Cql3ParserK_COUNT, Cql3ParserK_TTL, Cql3ParserK_CAST, Cql3ParserK_WRITETIME, Cql3ParserK_MAXWRITETIME, Cql3ParserK_JSON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1426)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Unreserved_keywordContext).k = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-28)) & ^0x3f) == 0 && ((int64(1)<<(_la-28))&1649267453953) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&2147483651) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Unreserved_keywordContext).k = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnreserved_function_keywordContext is an interface to support dynamic dispatch.
type IUnreserved_function_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetU returns the u rule contexts.
	GetU() IBasic_unreserved_keywordContext

	// GetT returns the t rule contexts.
	GetT() INative_typeContext

	// SetU sets the u rule contexts.
	SetU(IBasic_unreserved_keywordContext)

	// SetT sets the t rule contexts.
	SetT(INative_typeContext)

	// Getter signatures
	Basic_unreserved_keyword() IBasic_unreserved_keywordContext
	Native_type() INative_typeContext

	// IsUnreserved_function_keywordContext differentiates from other interfaces.
	IsUnreserved_function_keywordContext()
}

type Unreserved_function_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	u      IBasic_unreserved_keywordContext
	t      INative_typeContext
}

func NewEmptyUnreserved_function_keywordContext() *Unreserved_function_keywordContext {
	var p = new(Unreserved_function_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unreserved_function_keyword
	return p
}

func InitEmptyUnreserved_function_keywordContext(p *Unreserved_function_keywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_unreserved_function_keyword
}

func (*Unreserved_function_keywordContext) IsUnreserved_function_keywordContext() {}

func NewUnreserved_function_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unreserved_function_keywordContext {
	var p = new(Unreserved_function_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_unreserved_function_keyword

	return p
}

func (s *Unreserved_function_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Unreserved_function_keywordContext) GetU() IBasic_unreserved_keywordContext { return s.u }

func (s *Unreserved_function_keywordContext) GetT() INative_typeContext { return s.t }

func (s *Unreserved_function_keywordContext) SetU(v IBasic_unreserved_keywordContext) { s.u = v }

func (s *Unreserved_function_keywordContext) SetT(v INative_typeContext) { s.t = v }

func (s *Unreserved_function_keywordContext) Basic_unreserved_keyword() IBasic_unreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasic_unreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasic_unreserved_keywordContext)
}

func (s *Unreserved_function_keywordContext) Native_type() INative_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INative_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INative_typeContext)
}

func (s *Unreserved_function_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unreserved_function_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unreserved_function_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitUnreserved_function_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Unreserved_function_keyword() (localctx IUnreserved_function_keywordContext) {
	localctx = NewUnreserved_function_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Cql3ParserRULE_unreserved_function_keyword)
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cql3ParserK_AS, Cql3ParserK_KEYS, Cql3ParserK_PER, Cql3ParserK_PARTITION, Cql3ParserK_KEYSPACES, Cql3ParserK_TABLES, Cql3ParserK_CUSTOM, Cql3ParserK_VALUES, Cql3ParserK_TYPE, Cql3ParserK_TYPES, Cql3ParserK_COMPACT, Cql3ParserK_STORAGE, Cql3ParserK_FILTERING, Cql3ParserK_CONTAINS, Cql3ParserK_BETWEEN, Cql3ParserK_GROUP, Cql3ParserK_CLUSTER, Cql3ParserK_INTERNALS, Cql3ParserK_ONLY, Cql3ParserK_ALL, Cql3ParserK_PERMISSION, Cql3ParserK_PERMISSIONS, Cql3ParserK_MBEAN, Cql3ParserK_MBEANS, Cql3ParserK_USER, Cql3ParserK_USERS, Cql3ParserK_ROLE, Cql3ParserK_ROLES, Cql3ParserK_SUPERUSERS, Cql3ParserK_SUPERUSER, Cql3ParserK_NOSUPERUSER, Cql3ParserK_GENERATED, Cql3ParserK_PASSWORD, Cql3ParserK_HASHED, Cql3ParserK_LOGIN, Cql3ParserK_NOLOGIN, Cql3ParserK_OPTIONS, Cql3ParserK_ACCESS, Cql3ParserK_DATACENTERS, Cql3ParserK_CIDRS, Cql3ParserK_IDENTITY, Cql3ParserK_CLUSTERING, Cql3ParserK_EXISTS, Cql3ParserK_MAP, Cql3ParserK_LIST, Cql3ParserK_TUPLE, Cql3ParserK_TRIGGER, Cql3ParserK_STATIC, Cql3ParserK_FROZEN, Cql3ParserK_FUNCTION, Cql3ParserK_FUNCTIONS, Cql3ParserK_AGGREGATE, Cql3ParserK_AGGREGATES, Cql3ParserK_SFUNC, Cql3ParserK_STYPE, Cql3ParserK_FINALFUNC, Cql3ParserK_INITCOND, Cql3ParserK_RETURNS, Cql3ParserK_CALLED, Cql3ParserK_INPUT, Cql3ParserK_LANGUAGE, Cql3ParserK_REPLACE, Cql3ParserK_DEFAULT, Cql3ParserK_UNSET, Cql3ParserK_LIKE, Cql3ParserK_MASKED, Cql3ParserK_UNMASK, Cql3ParserK_SELECT_MASKED, Cql3ParserK_VECTOR, Cql3ParserK_ANN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)

			var _x = p.Basic_unreserved_keyword()

			localctx.(*Unreserved_function_keywordContext).u = _x
		}

	case Cql3ParserK_TIMESTAMP, Cql3ParserK_ASCII, Cql3ParserK_BIGINT, Cql3ParserK_BLOB, Cql3ParserK_BOOLEAN, Cql3ParserK_COUNTER, Cql3ParserK_DECIMAL, Cql3ParserK_DOUBLE, Cql3ParserK_DURATION, Cql3ParserK_FLOAT, Cql3ParserK_INET, Cql3ParserK_INT, Cql3ParserK_SMALLINT, Cql3ParserK_TINYINT, Cql3ParserK_TEXT, Cql3ParserK_UUID, Cql3ParserK_VARCHAR, Cql3ParserK_VARINT, Cql3ParserK_TIMEUUID, Cql3ParserK_DATE, Cql3ParserK_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1430)

			var _x = p.Native_type()

			localctx.(*Unreserved_function_keywordContext).t = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasic_unreserved_keywordContext is an interface to support dynamic dispatch.
type IBasic_unreserved_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k token.
	GetK() antlr.Token

	// SetK sets the k token.
	SetK(antlr.Token)

	// Getter signatures
	K_KEYS() antlr.TerminalNode
	K_AS() antlr.TerminalNode
	K_CLUSTER() antlr.TerminalNode
	K_CLUSTERING() antlr.TerminalNode
	K_COMPACT() antlr.TerminalNode
	K_STORAGE() antlr.TerminalNode
	K_TABLES() antlr.TerminalNode
	K_TYPE() antlr.TerminalNode
	K_TYPES() antlr.TerminalNode
	K_VALUES() antlr.TerminalNode
	K_MAP() antlr.TerminalNode
	K_LIST() antlr.TerminalNode
	K_FILTERING() antlr.TerminalNode
	K_PERMISSION() antlr.TerminalNode
	K_PERMISSIONS() antlr.TerminalNode
	K_KEYSPACES() antlr.TerminalNode
	K_ALL() antlr.TerminalNode
	K_USER() antlr.TerminalNode
	K_USERS() antlr.TerminalNode
	K_ROLE() antlr.TerminalNode
	K_ROLES() antlr.TerminalNode
	K_IDENTITY() antlr.TerminalNode
	K_SUPERUSER() antlr.TerminalNode
	K_SUPERUSERS() antlr.TerminalNode
	K_NOSUPERUSER() antlr.TerminalNode
	K_LOGIN() antlr.TerminalNode
	K_NOLOGIN() antlr.TerminalNode
	K_OPTIONS() antlr.TerminalNode
	K_PASSWORD() antlr.TerminalNode
	K_GENERATED() antlr.TerminalNode
	K_HASHED() antlr.TerminalNode
	K_EXISTS() antlr.TerminalNode
	K_CUSTOM() antlr.TerminalNode
	K_TRIGGER() antlr.TerminalNode
	K_CONTAINS() antlr.TerminalNode
	K_INTERNALS() antlr.TerminalNode
	K_ONLY() antlr.TerminalNode
	K_STATIC() antlr.TerminalNode
	K_FROZEN() antlr.TerminalNode
	K_TUPLE() antlr.TerminalNode
	K_FUNCTION() antlr.TerminalNode
	K_FUNCTIONS() antlr.TerminalNode
	K_AGGREGATE() antlr.TerminalNode
	K_AGGREGATES() antlr.TerminalNode
	K_SFUNC() antlr.TerminalNode
	K_STYPE() antlr.TerminalNode
	K_FINALFUNC() antlr.TerminalNode
	K_INITCOND() antlr.TerminalNode
	K_RETURNS() antlr.TerminalNode
	K_LANGUAGE() antlr.TerminalNode
	K_CALLED() antlr.TerminalNode
	K_INPUT() antlr.TerminalNode
	K_LIKE() antlr.TerminalNode
	K_PER() antlr.TerminalNode
	K_PARTITION() antlr.TerminalNode
	K_GROUP() antlr.TerminalNode
	K_DATACENTERS() antlr.TerminalNode
	K_CIDRS() antlr.TerminalNode
	K_ACCESS() antlr.TerminalNode
	K_DEFAULT() antlr.TerminalNode
	K_MBEAN() antlr.TerminalNode
	K_MBEANS() antlr.TerminalNode
	K_REPLACE() antlr.TerminalNode
	K_UNSET() antlr.TerminalNode
	K_MASKED() antlr.TerminalNode
	K_UNMASK() antlr.TerminalNode
	K_SELECT_MASKED() antlr.TerminalNode
	K_VECTOR() antlr.TerminalNode
	K_ANN() antlr.TerminalNode
	K_BETWEEN() antlr.TerminalNode

	// IsBasic_unreserved_keywordContext differentiates from other interfaces.
	IsBasic_unreserved_keywordContext()
}

type Basic_unreserved_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      antlr.Token
}

func NewEmptyBasic_unreserved_keywordContext() *Basic_unreserved_keywordContext {
	var p = new(Basic_unreserved_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_basic_unreserved_keyword
	return p
}

func InitEmptyBasic_unreserved_keywordContext(p *Basic_unreserved_keywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cql3ParserRULE_basic_unreserved_keyword
}

func (*Basic_unreserved_keywordContext) IsBasic_unreserved_keywordContext() {}

func NewBasic_unreserved_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Basic_unreserved_keywordContext {
	var p = new(Basic_unreserved_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cql3ParserRULE_basic_unreserved_keyword

	return p
}

func (s *Basic_unreserved_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Basic_unreserved_keywordContext) GetK() antlr.Token { return s.k }

func (s *Basic_unreserved_keywordContext) SetK(v antlr.Token) { s.k = v }

func (s *Basic_unreserved_keywordContext) K_KEYS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEYS, 0)
}

func (s *Basic_unreserved_keywordContext) K_AS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AS, 0)
}

func (s *Basic_unreserved_keywordContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CLUSTER, 0)
}

func (s *Basic_unreserved_keywordContext) K_CLUSTERING() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CLUSTERING, 0)
}

func (s *Basic_unreserved_keywordContext) K_COMPACT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_COMPACT, 0)
}

func (s *Basic_unreserved_keywordContext) K_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_STORAGE, 0)
}

func (s *Basic_unreserved_keywordContext) K_TABLES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TABLES, 0)
}

func (s *Basic_unreserved_keywordContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TYPE, 0)
}

func (s *Basic_unreserved_keywordContext) K_TYPES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TYPES, 0)
}

func (s *Basic_unreserved_keywordContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VALUES, 0)
}

func (s *Basic_unreserved_keywordContext) K_MAP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MAP, 0)
}

func (s *Basic_unreserved_keywordContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIST, 0)
}

func (s *Basic_unreserved_keywordContext) K_FILTERING() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FILTERING, 0)
}

func (s *Basic_unreserved_keywordContext) K_PERMISSION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PERMISSION, 0)
}

func (s *Basic_unreserved_keywordContext) K_PERMISSIONS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PERMISSIONS, 0)
}

func (s *Basic_unreserved_keywordContext) K_KEYSPACES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_KEYSPACES, 0)
}

func (s *Basic_unreserved_keywordContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ALL, 0)
}

func (s *Basic_unreserved_keywordContext) K_USER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USER, 0)
}

func (s *Basic_unreserved_keywordContext) K_USERS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_USERS, 0)
}

func (s *Basic_unreserved_keywordContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ROLE, 0)
}

func (s *Basic_unreserved_keywordContext) K_ROLES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ROLES, 0)
}

func (s *Basic_unreserved_keywordContext) K_IDENTITY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_IDENTITY, 0)
}

func (s *Basic_unreserved_keywordContext) K_SUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SUPERUSER, 0)
}

func (s *Basic_unreserved_keywordContext) K_SUPERUSERS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SUPERUSERS, 0)
}

func (s *Basic_unreserved_keywordContext) K_NOSUPERUSER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOSUPERUSER, 0)
}

func (s *Basic_unreserved_keywordContext) K_LOGIN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LOGIN, 0)
}

func (s *Basic_unreserved_keywordContext) K_NOLOGIN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_NOLOGIN, 0)
}

func (s *Basic_unreserved_keywordContext) K_OPTIONS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_OPTIONS, 0)
}

func (s *Basic_unreserved_keywordContext) K_PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PASSWORD, 0)
}

func (s *Basic_unreserved_keywordContext) K_GENERATED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_GENERATED, 0)
}

func (s *Basic_unreserved_keywordContext) K_HASHED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_HASHED, 0)
}

func (s *Basic_unreserved_keywordContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_EXISTS, 0)
}

func (s *Basic_unreserved_keywordContext) K_CUSTOM() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CUSTOM, 0)
}

func (s *Basic_unreserved_keywordContext) K_TRIGGER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TRIGGER, 0)
}

func (s *Basic_unreserved_keywordContext) K_CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CONTAINS, 0)
}

func (s *Basic_unreserved_keywordContext) K_INTERNALS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INTERNALS, 0)
}

func (s *Basic_unreserved_keywordContext) K_ONLY() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ONLY, 0)
}

func (s *Basic_unreserved_keywordContext) K_STATIC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_STATIC, 0)
}

func (s *Basic_unreserved_keywordContext) K_FROZEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FROZEN, 0)
}

func (s *Basic_unreserved_keywordContext) K_TUPLE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_TUPLE, 0)
}

func (s *Basic_unreserved_keywordContext) K_FUNCTION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FUNCTION, 0)
}

func (s *Basic_unreserved_keywordContext) K_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FUNCTIONS, 0)
}

func (s *Basic_unreserved_keywordContext) K_AGGREGATE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AGGREGATE, 0)
}

func (s *Basic_unreserved_keywordContext) K_AGGREGATES() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_AGGREGATES, 0)
}

func (s *Basic_unreserved_keywordContext) K_SFUNC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SFUNC, 0)
}

func (s *Basic_unreserved_keywordContext) K_STYPE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_STYPE, 0)
}

func (s *Basic_unreserved_keywordContext) K_FINALFUNC() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_FINALFUNC, 0)
}

func (s *Basic_unreserved_keywordContext) K_INITCOND() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INITCOND, 0)
}

func (s *Basic_unreserved_keywordContext) K_RETURNS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_RETURNS, 0)
}

func (s *Basic_unreserved_keywordContext) K_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LANGUAGE, 0)
}

func (s *Basic_unreserved_keywordContext) K_CALLED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CALLED, 0)
}

func (s *Basic_unreserved_keywordContext) K_INPUT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_INPUT, 0)
}

func (s *Basic_unreserved_keywordContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_LIKE, 0)
}

func (s *Basic_unreserved_keywordContext) K_PER() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PER, 0)
}

func (s *Basic_unreserved_keywordContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_PARTITION, 0)
}

func (s *Basic_unreserved_keywordContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_GROUP, 0)
}

func (s *Basic_unreserved_keywordContext) K_DATACENTERS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DATACENTERS, 0)
}

func (s *Basic_unreserved_keywordContext) K_CIDRS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_CIDRS, 0)
}

func (s *Basic_unreserved_keywordContext) K_ACCESS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ACCESS, 0)
}

func (s *Basic_unreserved_keywordContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_DEFAULT, 0)
}

func (s *Basic_unreserved_keywordContext) K_MBEAN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MBEAN, 0)
}

func (s *Basic_unreserved_keywordContext) K_MBEANS() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MBEANS, 0)
}

func (s *Basic_unreserved_keywordContext) K_REPLACE() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_REPLACE, 0)
}

func (s *Basic_unreserved_keywordContext) K_UNSET() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_UNSET, 0)
}

func (s *Basic_unreserved_keywordContext) K_MASKED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_MASKED, 0)
}

func (s *Basic_unreserved_keywordContext) K_UNMASK() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_UNMASK, 0)
}

func (s *Basic_unreserved_keywordContext) K_SELECT_MASKED() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_SELECT_MASKED, 0)
}

func (s *Basic_unreserved_keywordContext) K_VECTOR() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_VECTOR, 0)
}

func (s *Basic_unreserved_keywordContext) K_ANN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_ANN, 0)
}

func (s *Basic_unreserved_keywordContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(Cql3ParserK_BETWEEN, 0)
}

func (s *Basic_unreserved_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Basic_unreserved_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Basic_unreserved_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cql3Visitor:
		return t.VisitBasic_unreserved_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cql3Parser) Basic_unreserved_keyword() (localctx IBasic_unreserved_keywordContext) {
	localctx = NewBasic_unreserved_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Cql3ParserRULE_basic_unreserved_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1433)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*Basic_unreserved_keywordContext).k = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&621496955305984000) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&72057525821310849) != 0) || ((int64((_la-146)) & ^0x3f) == 0 && ((int64(1)<<(_la-146))&17137926023) != 0)) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*Basic_unreserved_keywordContext).k = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
